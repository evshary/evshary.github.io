<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一些減少code size的方法]]></title>
    <url>%2F2019%2F08%2F03%2F%E4%B8%80%E4%BA%9B%E6%B8%9B%E5%B0%91code-size%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言在開發嵌入式系統的時候，很常遇到需要在資源緊張的環境上進行開發，所謂的資源緊張大概不外乎memory不夠使用、flash不夠大，但是老闆或PM仍然希望RD在產品上面新增feature，這時候就只能針對code size進行優化了。我自己待的部門剛好就是遇到這種產品已經維護10年以上，可是又希望加新feature的狀況，因此開始尋找減少code size的方法，這邊分享一些我自己的心得。 Compile Optimization首先我們可以看一下compiler是不是已經做過優化了，大家都知道gcc在編譯的時候可以選擇optimization的level，從0-3。0代表的是default，而隨著數字越高，對code size和execution time的優化就越高。 大部分的人都會建議使用-O2，在code size和execution time取平衡，但是如果真的對code size十分在意的話，其實也可以使用-Os，代表的是-O2但是不包含部分會影響code size的優化。 到底每個optimization的level是做了那些優化，可參考GCC的官方文件 stripstrip算是最基本的降低code size工具，他會移除debug資訊(可供gdb使用的資訊)以及symbol table，因此size會降低許多。 這邊簡單做個實驗： 我們先寫個簡單程式： 123456789#include &lt;stdio.h&gt;void func() &#123; printf("func\n");&#125;int main() &#123; func(); return 0;&#125; 接著來編譯，為了凸顯strip的效果，我們加上-g來加上gdb debug訊息 1gcc -g test.c -o test 接著我們可以用nm -a test來看到他的symbol table 123450000000000000000 a0000000000201030 b .bss0000000000201030 B __bss_start0000000000000000 n .comment.... 以及用objdump -h test來看到有哪些section header，可以發現有許多debug資訊 123456789101112... 27 .debug_aranges 00000030 0000000000000000 0000000000000000 0000105d 2**0 CONTENTS, READONLY, DEBUGGING 28 .debug_info 0000033a 0000000000000000 0000000000000000 0000108d 2**0 CONTENTS, READONLY, DEBUGGING 29 .debug_abbrev 000000f6 0000000000000000 0000000000000000 000013c7 2**0 CONTENTS, READONLY, DEBUGGING 30 .debug_line 000000d4 0000000000000000 0000000000000000 000014bd 2**0 CONTENTS, READONLY, DEBUGGING 31 .debug_str 0000028a 0000000000000000 0000000000000000 00001591 2**0 CONTENTS, READONLY, DEBUGGING... 接著執行strip test後，會發現symbol table已經消失了(無法使用nm)，以及沒有debug的section header。兩者size有極大差異。 12345&gt; ls -al-rwxrwxrwx 1 evshary evshary 11152 Aug 4 11:34 test&gt; strip test&gt; ls -al-rwxrwxrwx 1 evshary evshary 6304 Aug 4 11:39 test objcopystrip可以減少極大部分的code size，但是如果這樣還不夠的話，我們可以用objcopy把一些沒用到的section header移除掉，但是要提醒一下，這個移除幾乎不會影響太大，大概就幾百byte而已。 1234&gt; objcopy -R .comment -R .note.ABI-tag -R .gnu.version test small_test-&gt; ls -al-rwxrwxrwx 1 evshary evshary 6304 Aug 4 11:39 test-rwxrwxrwx 1 evshary evshary 6024 Aug 4 11:45 small_test 這邊所謂的沒用到section header主要是一些環境的版本資訊，到底這些header代表什麼意思，可以參考Linux Standard Base PDA Specification 3.0RC1 - Chapter 5. Special Sections 利用 compile option 來移除沒用到的 symbol我們知道程式裡面常常會有些程式碼(function/data)並沒有被人使用到，不論是因為長久maintain被修修改改，還是因為本身就有預留給未來使用。但是這些沒用到的功能如果都被編進去程式中其實是很浪費的，我們這邊可以用一些小手段來移除。 在gcc的編譯過程中我們可以加上特別的編譯參數-fdata-sections和-ffunction-sections，這兩個的意思是把每個symbol(function或data)獨立成不同的section。為什麼要這樣做呢？當然是為了後面在link的時候我們可以直接移除沒用到的section，在link的時候多加上--gc-sections參數即可。 細節可以參考How to remove unused C/C++ symbols with GCC and ld?。 觀察 map filemap file是我們在編譯過程中很重要的一個工具，他可以用來檢視目前symbol的size有多大，我們可以用nm來取得symbol table，甚至根據symbol的size大小來排序(指令是nm --size-sort -r -S [執行檔])。透過觀察map file，我們可以瞭解程式內部每個功能佔的大小為何，進一步思考有沒有優化的空間，甚至發現該功能根本是沒有在使用的。 我自己也曾經有遇過code size的問題，那時候我一樣是用nm來讀取map file，忽然發現某個變數大到不可思議，觀察了一下發現那個變數是直接用global的方式宣告，並不是要用的時候才malloc，導致在一般firmware運作的過程中那塊記憶體完全沒辦法被使用。更重要的是那個功能並不常被使用，而且還會隨著硬體平台有不一樣的大小，結果RD為了方便，直接保留可能會用到的最大值，造成空間的極度浪費。 Remove debug message其實RD在開發的過程中，或多或少都會留一些debug訊息，雖然少少的，但是累積起來量也是很驚人，畢竟一個debug訊息就是一個字串。在code size緊張的情況下，應該可以審視一下，看能不能把debug訊息移除。 值得注意的是有些embedded的firmware確實是會有關閉debug資訊的方式，但是這個有可能只是不顯示(例如關閉console顯示)，並不是真的移除，要仔細確認自己的狀況是哪種。 不過如果真的到了一定要移除debug訊息程式才能夠被使用的情況，這樣也挺危險的了，因為未來如果要maintain，必要的debug訊息還是逃不了。我會建議程式開發的過程中每個功能都可以自行決定要不要把debug的程式碼編進去，至少遇到bug還可以只開啟相關功能的debug訊息，而不是全部訊息都全開。 移除沒用到的功能(library)、檔案在我們的embedded firmware裡面有些會需要使用SSL或SSH這種非常龐大的library，可能佔firmware的size超過1/3。像是這種library其實有很多功能是我們沒有用到的，以SSL、SSH來說，其實我們只會用到其中少部分的加密cipher，而不是全部。如果真要使用，建議要對library本身功能機制足夠熟悉，在編譯的時候只開用到的option即可。 除了library外，一個產品經過長時間的maintain，中間一定會有許多功能是後來沒用到，卻沒被移除的。如果只是程式碼倒還好，可以用前面提到的gc-section來排除，但是如果是file system的檔案，那就要靠自己來處理了。我個人的經驗是，有很多功能是過去產品有的，但是因為後來時代不符合被移除，結果相關檔案就都一直遺留下來，例如可在browser上面運作的java plugin等等，這些的size是也很可觀的。 Compression壓縮也是減少code size的其中一個方法，除了啟動的程式外，我們可以把runtime過程才要load的東西進行壓縮。通常這類的角色可以是kernel啟動完成後另外加載的AP，或是filesystem。不過壓縮要考慮的點就是壓縮率、解壓的程式碼的大小以及速度，最好可以在這其中之間取得平衡。壓縮率對我們來說就是可以把程式縮小到什麼地步，如果縮小不大就沒有意義了，然後解壓的部分也很重要，要是有很高壓縮率，但是解壓程式很大，那整體來說並沒有得到多高的效益。而如果壓縮率高，但解壓速度過慢，也會影響到使用者體驗，這些都需要考慮到。 filesystem的部分有點可以稍微注意一下，大部分的應用都是web居多，而web其實是有壓縮的空間，且不需另外解壓的。我們知道一般web都是由html、CSS、javascript所組成，而這些內容丟給browser的時候並不需要是人眼比較好閱讀的方式，例如說不需要換行、縮排等等。這麼一來我們就有可以動手腳的空間，可以在編譯過程中，把原始的檔案做壓縮，最後才變成file system，這樣的壓縮率是很可觀的。除了減少size外，這還帶來另外一個很大的好處就是減少網路流量的傳輸，特別在embedded system中系統效能其實都不快。提醒一下，記得開發過程使用git追蹤的web檔案最好是原始檔案(人眼好讀的)，編譯過程才壓縮，不然這只是給自己帶來開發的困擾而已。 web壓縮的方式網路上有很多，有些甚至提供online的服務，例如HTMLCompressor或是textfixer等等，可以自己尋找適合的工具。 結語上面分享了許多方法，但最後我要先澄清一下，自己需要搞清楚到底不夠的是flash還是memory，上面的方法並不是做了兩個都一定會減少。舉個例子來說，移除沒有必要用到的大變數通常只會影響memory的使用率，因為compile出來firmware的size並沒有包括大變數(因為是bss section，未初始化區段)，而file system的壓縮通常也只會影響flash的使用率，除非firmware有把檔案預先從flash讀出來放在memory中。我想強調的是使用這些方法時，還是要有必備的系統觀以及對你的系統有一定熟悉程度。 老實說軟體開發者最討厭的大概就是被各種硬體條件所限制，然而這些在embedded的世界中還是有很大的機會會遇到，特別是考量到成本的時候。雖然很討厭這類的問題，但是解決後其實還是蠻有成就感的。以上分享希望能夠幫助大家解決code size issue。 參考 程式減肥三步走]]></content>
      <categories>
        <category>系統程式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三年的工作省思]]></title>
    <url>%2F2019%2F06%2F23%2F%E4%B8%89%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%9C%81%E6%80%9D%2F</url>
    <content type="text"><![CDATA[前言工作到現在已經三年半了，雖然有許多成長，但也看見自己很多的不足，可以再進步的地方。個人覺得如果要能夠更快速地成長，需要定期總結自己的經驗以及所學習的東西，並且思考未來可以再怎麼做會更好。平常我有做日記的習慣，但是還沒有為自己統整工作上面的心得，這邊除了當作紀錄以外，也是可以提供給跟我差不多狀況的人參考。不過老實說，這些分享並不一定正確，但是至少是此時此刻的我最真實的想法，也歡迎大家多多指教。 經歷畢業前我是從研替開始軟體工程師的生涯，以前在大學、研究所時，雖然有寫程式，但是畢竟都還是學生等級的程式，個人是覺得不夠深入與成熟。不過另一方面其實也累積了不少基礎，有許多重要的知識都是那時紮根的，包括Linux的使用、git的使用、Network的概念、Security的概念，這些對後來的自己都有很多幫助。雖然有時會想要是現在的自己回到過去的話，肯定可以學得更快更好、更有效率，畢竟產業和學術上還是有多少落差，但這也都有點後見之明了，而且正是因為曾經經歷過，才會有不同看事情的角度。會覺得過去要是怎樣怎樣現在就會更好，大概是人免不了的通病吧！ 第一年進到職場後，最不習慣的是每件事都要很清楚是在做什麼，過去在學校基本上只要code能work就行了，所以最常做的就是上stack overflow找找，然後copy &amp; paste，不太會去理清背後的原理，或是思考怎麼做才會更有效率。然而在職場上，如果只是剪剪貼貼的話，遲早會出問題的，被同事問回答不出來還是小事，更慘的是自己做完了導致其他的bug出現。另外一點是動作需要很迅速，我記得剛過試用期後就被交付了要porting BSP上的ICMP的功能到FreeRTOS，時間給我3天，結果最後花費的時間還是超過，這跟學校其實差異很大，我在學校光是改一個memory leak的bug就改了2個月(雖然是因為還要兼顧課業)。最後，關於品質的部分，也是那時的我需要克服的坎，我不喜歡做測試，可是當時的主管就很強調要做自我驗證，才不會提供的程式上面有很多顯而易見的問題，給出去的程式也是代表自己的品牌，需要細心驗證才行。 其實整體來說，我在職場上的第一年大概是以調整心態並且適應工作為主，而工作內容大概都是偏向AP層的修改，或是開發些應用程式。最常見的case大概是做客製化的firmware以及處理客戶回報的問題，改的內容不外乎是web上的修改，或是AP層上面的邏輯的問題。不過也不是沒有要寫新feature，包括在JAVA應用程式上用JNI連結到C library、Linux command line tool、帳號管理API等等，或多或少訓練了怎麼設計程式架構。 第二年第二年開始我已經有能力解決比較困難的問題，那時團隊遇到SDRAM不足的問題，後來我透過分析map檔找到一個沒有必要使用的巨大global variable，克服這個難關。不過老實說，我現在回想起來這個問題也不是太難，只是要對firmware compile過程有比較深一點的認知而已。另外當時遇到了過熱當機的問題，這個老實說是幫助我成長最大的問題，我把NXP的MCU spec讀了好幾次，了解了ARM的exception架構，另外也深入理解FreeRTOS以及lwip等NXP提供的BSP是怎麼與MCU互動的。除此之外，我基於資深同事提出的proprietary protocol架構上做改進，並且設計提供給AP使用的API，其實也理解了設計protocol的原則，包括易用、相容性、功能獨立性等等。 這一年對我來說是技術成長最快的一年，開始練習解決問題需要有系統的思維，除了AP層以外，更加理解軟體與硬體的相依性，BSP的概念等等。那時候我常常都是在ARM的exception handler中加上dump stack的功能，然後反推造成當機的原因。這些經驗對後來看待問題時有很大的幫助，會思考這個OS的運作性質是什麼，怎麼去分配記憶體的，比較能夠有系統觀去解決問題。 第三年第三年因為要做經驗傳承，開始跟資深同事學習公司既有的proprietary OS，除了AP以外，更重要的是底層kernel的運作，類似UNIX上面STREAM的架構。由於FreeRTOS的架構相對來說比較簡單(有些人甚至認為比較像library)，所以proprietary OS也是強化了我對OS的理解，而且多了可以比較的參照物。除此之外，因緣巧合下我開始有了機會可以當project leader，雖然團隊加上我只有3個人，不過也算是個不錯的經驗。我主要負責的是與PM、測試溝通，然後分配feature &amp; bug給團隊，並且確保merge的code沒有任何問題。同時間，我也開始和其他同事合作導入CI/CD、code review的概念，剛好就在我的project上進行實驗。 這個時間點對我來說除了技術以外，開始有了與人相關的任務，不論是領導還是溝通。另外因為自己有比較多一點的權力，所以也嘗試導入自己所喜歡的文化，如CI/CD。比較有趣的是，我發現以前的同學也差不多在這個時間擔任leader的角色，也許大家走的路都差不多吧！ 現在延續前一年，我開始擔任既有產品的maintain窗口，學習分配工作給團隊的其他人，並且思考要怎麼進行有效率的溝通，不論是團隊內還團隊外。技術方面則是開始接觸eCos這個系統，雖然外界已經沒人在用了，但是這個產品仍然需要有人maintain。發現挺有趣的是我差不多一年接觸一種OS，也加深了以前學OS的一些概念，例如synchronization、scheduler等等。 其實到了現在我覺得已經進入了一個坎，技術開始進步緩慢，而且因為既有產品線眾多，有許多maintain的effort，沒有心力去學新技術。目前，不得不好好反思自己的職涯規劃，以往我都是認為只要有學習成長就可以了，沒有想太多自己未來的走向，包括什麼是自己的強項，我接下來的時間要學什麼，可以成長多少等等。如果再宏觀一點，從人生角度來說，我規劃學習這些技術對工作有什麼幫助？在我的生命中是什麼樣的地位？我的人生究竟是想要什麼？成就感嗎？還是只要賺夠多錢就行了？這些都是以前有想過，但是沒有仔細思量的，現在因爲工作上面遇到了些障礙，所以會開始思考什麼才是自己想要的。 雖然我是因為感覺沒有成長所以思考是不是要改變跑道，但是另一方面來說，我覺得也是因為這個契機才開始會反省工作在自己人生中的意義是什麼，這倒也不是什麼壞事。人本來就應該要很清楚自己想要什麼，留在某個地方就是要承擔自己失去的其他機會成本，離開某個地方就是要能捨棄當前環境的舒適以及穩定，沒有好或壞，就只是要自己承擔相對應的責任。 總結這職場三年多下來，其實我也學習了很多事情，比起技術而言，我覺得最重要的是觀念的改變。從一個人的觀念和面對事情的態度，大概就可以推估他的未來發展。技術要學其實是可以很快，但是個人特質是很難短時間內改變，因此我覺得這是影響個人成就非常深遠的關鍵。以下就我的觀點分享認為重要的事情。 發問前一定要再三思考 在問別人問題的時候，要先思考想從對方那邊得到什麼樣的答案。簡單來說就是不要無腦發問，同事都是很忙的，所以相對應來說可以問問題的次數是有限制。因此每次發問都先思考：我問的問題是否其實查一查資料或做做實驗就可以解決？我想問的問題到底是什麼？有時候整理一下自己的想法後，就赫然發現其實問題已經得到了解答，根本不需要問人，這也是常聽到的Rubber Duck Debugging。 一般來說我們遇到不確定的問題都會去請教主管，看要怎麼做會比較好，這個做法在剛進公司時是OK的，畢竟對工作內容還不熟，但是隨著自己慢慢熟悉，要做的應該是自己能夠做主並且決策。以公司的角度來說，多請人就是要減少大家的工作量，如果事事都要去問人的話，那就不需要多請人了。當然有些問題可能是一定要主管做決策的，那可以提出自己的想法以及建議的解決方式，主管只要確認我們的解法沒有什麼大問題就可以了。 定期反省，找出更有效率的做法 可以的話，建議每天做日記，思考今天的工作內容有什麼可以改進之處。不過老實說這樣確實是蠻累的，而且會變成無腦的慣性，所以也可以改成每週一次。一個人在工作上的表現，大概就是解決問題的能力和效率，如果這個能力能不斷提升，能創造的價值就越高。 舉例來說，在我的公司就是要處理很多文件流程，每次要跑大家就都要到處問人，後來我受不了了，乾脆自己整理一份跑流程的SOP，每次跑我就參考SOP執行，如果有錯再修改SOP，大大減少我在工作上的煩躁感。而且後來有新人進來要跑流程時，我也可以請他們看SOP，而不需要手把手教學，減少時間的浪費。 用目的論思考，了解自己做的事情是為了什麼，要解決什麼問題 我發現有時候自己做的事情和別人對我的期待其實是有落差，我認為重要的東西，別人卻覺得那個不是重點。因此面對任何任務，都要確定做這件事的目的是什麼，例如是要給客戶滿意的解釋，還是要百分之百肯定問題的根因，然後是不是值得投入相對應的資源。 常常做事情都會不小心過度鑽研在細節上面，大家各自提出自己的意見，而無法做出正確的決策，這時候最好都是要回到最初的問題：我們到底是要解決什麼，怎麼決策才能符合我們最一開始的目的。不會有完美的解答，但是只要能達到設定的目標，那就是可以接受的答案。 溝通的時候，站在對方的立場思考 工作上基本上一定會有cowork的機會，而很多的爭論幾乎都是來自於溝通不夠完全。回應他人的問題時，可以站在他的角度思考，他想得到什麼答案，我能提供什麼答案，怎麼在中間取得平衡，不要變成事情都是某一方去承擔，另一方面也是提高溝通效率，不會信件來回很多次都得不到共識。 有時候不要太依賴信件，有些情況直接面對面溝通會來得有效率，且也不會太過生硬，讓人有距離感，有時候都是因為雙方文字上彼此誤會而吵起來。 要定期盤點自己的能力 我會強烈建議要隨時maintain一份A4的履歷，並不是說要騎驢找馬，而是為了把自己重點且精華的能力精簡成一份履歷，其實也是認識自我的一種方式。整理完後會發現原來自己的強項是什麼、還欠缺什麼，工作的時候就比較不會得過且過，而是會用宏觀的視野思考為什麼要做，還能怎麼做會更好，因為這些都將變成未來與人談判的籌碼。當然如果有好的機會的話，已經有一份履歷在手，就可以隨時把握。 負起責任 負起責任有幾個方面，首先就是對自己做的事情，任務交到自己的手上，那就是要把它做好，如果發現有任何問題就是要隨時反應，不要到了最後一刻才說。另外這也隱含了一點：我不是機器人，別人說什麼就做什麼，而是要有能力自己判斷、決策並且承擔最後的結果。能做到這點，周圍的人就可以放心與自己合作了。 另外一方面是對自己負責，永遠要記得不管做什麼決定，承擔結果的是自己。不管是想要加班做事情、針對某個問題作深入鑽研、隱藏遇到的問題裝做表面一片和諧，其實都無妨，只要能夠接受最終結果就好。既然都已經是成年人了，就不要想著拿盡所有好處而且可以逃避責任。以職業生涯來說，選擇自己的去留也是同樣的道理，如果放棄了現在的位置，那就別未來才後悔失去了許多福利，如果選擇留著，那也別再抱怨沒有新的成長，一切都是在於自己的選擇。 不過老實說，上面的分享也只適用於想不斷提升自己的情況，但是人生是有很多面向的，我也曾經看過有人工作只出五分力，剩下的時間都是專注在自己的生活品質上面。這並沒有什麼不好，甚至如果以長遠來看，他說不定活得還比認真努力打拼的人更快樂。反正，最重要的還是要記得人生是自己的，做什麼決定都沒關係，只要肯承擔後果就好。]]></content>
      <categories>
        <category>自我反省</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPython Notebook - Jupyter教學]]></title>
    <url>%2F2018%2F12%2F02%2FIPython-Notebook-Jupyter%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[簡介Jupyter Notebook，過去被稱為ipython notebook，是ipython內的強大工具。 Jupyter最常用在學習資料處理上面，因為輸入指令後就可以產生相對應的圖形結果，做到資料視覺化的功能。而且更重要的是我們可以將自己的結果輸出成html或上傳Github，分享給其他人進行討論。 安裝MAC如果有安裝python-pip了，可以直接用如下指令安裝。要是遇到權限問題可以再加上sudo。1pip install &quot;ipython[notebook]&quot; 使用基本操作 創造一個資料夾，然後在裡面開啟jupyter notebook 123mkdir ipython_notebook &amp;&amp; cd ipython_notebookjupyter notebook# 原本是可以用ipython notebook，但是未來可能會被捨棄 如果要在別的port開啟 1jupyter notebook --port 8080 接下來在web上應該可以直接連線Jupyter。 選擇New-&gt;python3後就可以在web新創一個notebook，值得注意的是這個notebook的副檔名是.ipynb，存放位置就是在我們當前的目錄，也就是ipython_notebook 登入機制jupyter notebook其實是有登出機制的，在右上角logout後，就要用密碼或token才能登入。 這時候其實可以直接重啟server，或是輸入jupyter notebook list來查看token，就可以再次登入了。 編輯方式在Jupyter中，進入notebook後會看到一個可以輸入值的空間，這個叫做cell。cell上面輸入python語法後，按下shift+enter就會產生執行結果。而我們可以增加或減少這些cell。 特別注意原本cell是藍色的，代表在command mode，但是如果點選cell後就會變成綠色，代表進入edit mode。從edit mode跳回command mode只要按下ESC即可。 另外可以注意每個cell可以選擇不同屬性，最常用的還是Code和Markdown。Code就是python的部分，而Markdown則是可以寫上相關的文字敘述。 常用快捷鍵主要可以點選Help-&gt;Keyboard Shortcuts來看目前快速鍵怎麼使用(或是按ESC+h更快) 常用快速鍵如下所示： c：複製當前的cell x：剪下當前的cell v：貼上剪貼簿的cell dd：刪除當前cell a：在上方插入新的cell b：在下方插入新的cell shift+enter：執行當前cell並跳到下一個cell ctrl+enter：執行當前cell shift+tab：可以顯示當前函式的使用方法 分享我們除了可以把當前notebook下載成html外，也可以push到Github上並且利用nbviewer這個網站來分享。 舉個例子，A gallery of interesting Jupyter Notebooks就收集了不少有趣的Juypter Notebook範例。 只要有ipynb上傳到Github，我們就可以看到輸出結果，就像這個GitHub的結果可以被nbviewer顯示出來。 參考 ipython notebook安裝教學 [Day02]Jupyter Notebook操作介紹！ [資料分析&amp;機器學習] 第1.2講：Jupyter Notebook介紹]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ARM CortexM3/4權限切換]]></title>
    <url>%2F2018%2F12%2F02%2FARM-CortexM3-4%E6%AC%8A%E9%99%90%E5%88%87%E6%8F%9B%2F</url>
    <content type="text"><![CDATA[簡介最近我在研究怎麼在ARM Cortex M3/4上面跑一個自己寫的OS，最主要是參考jserv的mini-arm-os和pikoRT，相關程式碼放在arm-os-4fun。最近發現自己遇到了些問題，想說再研究怎麼解決的過程中順便把細節紀錄下，供自己未來可以參考。 這邊首先要探討的是Cortex M3/4上面有的權限模式，以及它們是怎麼進行切換等細節。原本我是在qemu上面跑STM32虛擬機，但是後來發現好像跟真實硬體有點不一致，所以後來我都在STM32F429的硬體上面來測試了。 Cortex M權限設計首先我們先了解Cortex上面有哪些權限模式，處理器上面有兩種Operation Modes：Thread mode和Handler mode。 Thread Mode：一般程式運行的狀態。 Handler Mode：處理exception的狀態。 然而除了這個以外，還有不同的Privilege Levels，避免一般使用者可以存取敏感資源。 Privileged：可以存取所有資源，在CPU reset之後就是privileged。 Unprivileged：通常是讓OS中userspace的程式運行用的，在幾個方面存取資源是受限的。 MSR、MRS指令存取上會有限制。 無法存取system timer、NVIC。 有些memory無法存取。 Operation Modes和Privilege Levels的關係如下所示，Unprivileged不能進入Handler Mode的。 - Privileged Level Unprivileged Level Handler Mode O(state1) X Thread Mode O(state2) O(state3) 上面標註的state 1-3是為了方便我們後面講解而標的。 如何切換權限與模式關於切換的部分可參考下圖，圖片來源A tour of the Cortex-M3 Core 下面我們先看怎麼樣從state2,state3進入state1，也就是發生exception，然後再從state1回來。 Exception Entry進入exception有兩種情況： 目前我們在thread mode preempts：發生的exception比目前我們所在的exception權限還高 發生exception時，ARM會自動把當前的register的資訊存起來，順序為xPSR, PC, LR, R12, R3, R2, R1, R0。儲存的方式就是push到當前的stack中，可能是main stack(SP=MSP)，也可能是process stack(SP=PSP)。 address register SP+00 R0 &lt;- SP after exception SP+0x04 R1 SP+0x08 R2 SP+0x0C R3 SP+0x10 R12 SP+0x14 LR SP+0x18 PC SP+0x1C xPSR SP+0x20 xxx &lt;- SP before exception 完成後接著會開始執行exception handler，並且把EXC_RETURN寫入LR。 Exception Return要從exception跳還必須要符合兩個條件： 目前正在Handler Mode。 PC的值是合法的EXC_RETURN。 關於EXC_RETURN的值，其實代表了ARM從handler mode回去的路徑，有三種可能： 目前是nested exception，回去上層還是handler mode。 是由privileged thread mode呼叫的，也就是要回到state2。 是由unprivileged thread mode呼叫的，也就是要回到state3。 因此EXC_RETURN有三個可能的值 EXC_RETURN Description 0xFFFFFFF1 Return to Handler mode.Exception return gets state from the main stack.Execution uses MSP after return. 0xFFFFFFF9 Return to Thread mode.Exception Return get state from the main stack.Execution uses MSP after return. 0xFFFFFFFD Return to Thread mode.Exception return gets state from the process stack.Execution uses PSP after return. Privileged to Unprivileged接著我們要來探討怎麼從Privileged進入Unprivileged，也就是state2進入state3的部分。 如果要進入Unprivileged，那必須使用到特殊register - control。 bit Description CONTROL[1] 0：Use MSP, 1: Use PSP CONTROL[0] 0：Privileged thread mode, 1：Unprivileged thread mode 要特別注意操作control register一定要用MRS和MSR register1234# CONTROL值搬到R0MRS R0, CONTROL# R0的值放入CONTROLMSR CONTROL, R0 進入Unprivileged Thread Mode的操作12MOV R0, 3MSR CONTROL, R0 ARM在切換上面的設計ARM在處理nested exception上有自己的一套做法來加快速度，確保高優先權的exception能更快被執行到，達到更高的即時性(real-time)。 下面介紹兩種在Cortex M上面的機制： tail-chained： 情況：如果發生exception1的時候又發生exception2，但是exception2的優先權沒有高於exception1，必須等待。 原本：一般來說exception1結束的時候會先pop stack，然後再push stack進入處理exception2。 改進：exception1到exception2中間的pop&amp;push其實是沒意義的，所以ARM Cortex M會在exception1結束後直接執行exception2，減少了中間的浪費。 late-arriving 情況：如果發生exception1並且執行state saving(上面說的push register)，這時候有更高優先權的exception2進來，發生preempts。 原本：會中斷exception1的state saving，優先讓給exception2。 改進：exception2其實也是需要state saving，所以繼續維持state saving，然後直接執行exception2。當exception2結束後，就又可以使用tail-chained的模式來執行exception1。 參考關於Cortex M相關的資料非常推薦下面兩本書籍，都有中文的翻譯。JosephYiu有參與ARM Cortex M的設計，比較有權威性。 ARM Cortex-M3權威指南 ARM Cortex-M3與Cortex-M4權威指南, 3/e ARM Cortex-M3与Cortex-M4权威指南 可參考jserv老師和學生撰寫的rtenv+簡介，裡面也有提到ARM CM3權限的部分。 rtenv+]]></content>
      <categories>
        <category>ARM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gnuplot：報告必備的繪圖工具]]></title>
    <url>%2F2018%2F12%2F02%2Fgnuplot%EF%BC%9A%E5%A0%B1%E5%91%8A%E5%BF%85%E5%82%99%E7%9A%84%E7%B9%AA%E5%9C%96%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[簡介當我們要製作報告或論文的圖表時，除了excel以外，其實也可以使用gnuplot這套工具。gnuplot非常的強大，除了可以畫各種圖表以外，還可以跨不同平台使用。 我們這邊簡單紀錄一些常用圖表怎麼繪畫。 安裝MAC如果我們要正常顯示圖表的話需要有x11，這部分可以安裝APPLE的XQuartz即可，這樣啟動gnuplot的時候就會自動啟動XQuartz了，可參考Can’t plot with gnuplot on my Mac 接下來安裝gnuplot的時候要特別注意，如果沒有加上--with-x11的話，可能會造成Terminal type set to &#39;unknown&#39;的warning，可參考Can’t find x11 terminal in gnuplot Octave on Mac OS1brew install gnuplot --with-x11 使用基本操作12345678910# 啟動gnuplot# 畫出sin(x)的圖plot sin(x)# 設定範圍，x軸是-10到10，y軸是0到2的cos(x)plot [x=-10:10] [0:2] cos(x)# 清空之前的設定reset# 結束exit 讀取檔案我們可以把多筆資料先存成檔案，然後再讓gnuplot來讀 我們先存資料到data.txt，中間用空格隔開123451 52 103 154 105 5 執行gnuplot就會看到有許多一點一點資料散佈在plot上12gnuplotplot &quot;data.txt&quot; 如果要開啟多個檔案1plot &quot;data1.txt&quot;, &quot;data2.txt&quot;, &quot;data3.txt&quot; 存成程式每次都要自己一個個輸入指令說實在太麻煩了，我們可以存成.plt檔，以下面為例存成plot.plt1plot &quot;data.txt&quot; 進入gnuplot後輸入如下指令即可1load &quot;plot.plt&quot; 圖表上的文字圖表上面總是要有些文字說明，可參考如下設定123456789101112# 設定標題set title &quot;pic_title&quot;# x軸說明set xlabel &quot;x(unit)&quot;# y軸說明set ylabel &quot;y(unit)&quot;# 設定線條說明外框set key box# 不要線條說明set nokey# 如果要修改線條說明plot &quot;data1.txt&quot; title &quot;title 1&quot;, &quot;data2.txt&quot; title &quot;title 2&quot; 圖表的顯示也許我們會想改變圖表上面的顯示12345678910# 增加格線set grid# 數據連成一條線set style data lines# x軸的範圍set xrange [-10:10]# y軸的範圍set yrange [-10:10]# X軸的單位set xtics x: 每次x軸都增加x plot上其實也可以做一些操作12345678# 使用data.txt，並且畫成線，linestyle為1，linewidth也為1plot &quot;data.txt&quot; with lines linestyle 1 linewidth 1# 使用data.txt，pointtype為1，pointsize也為1plot &quot;data.txt&quot; with point pointtype 1 pointsize 1# 如果線和點都要的話plot &quot;data.txt&quot; with linespoints# 如果要變成長條圖的話plot &quot;data.txt&quot; with boxes 儲存成圖片12345678910# 要存成png檔案set terminal png# 可以加上size資訊set terminal png size 1200,800# 輸出圖片，這個指令會等待後續的plotset output &quot;output.png&quot;# 輸出圖片plot .....# 記得要再改回x11set terminal x11 常用 折線圖 先產生出data.txt 使用在gnuplot中load如下plt檔1234567resetset title &quot;pic_title&quot;set xlabel &quot;x(unit)&quot;set ylabel &quot;y(unit)&quot;set terminal pngset output &quot;output.png&quot;plot &quot;data.txt&quot; with linespoints title &quot;title 1&quot; 長條圖 先產生出data.txt 使用在gnuplot中load如下plt檔123456789resetset title &quot;pic_title&quot;set xlabel &quot;x(unit)&quot;set ylabel &quot;y(unit)&quot;set terminal pngset output &quot;output.png&quot;# 設定長條圖的sizeset boxwidth 0.3plot &quot;data.txt&quot; with boxes title &quot;title 1&quot; 參考 實驗基本數據製圖指令 gnuplot Gnuplot 簡單數據繪圖 gnuplot 語法解說和示範]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg影音處理工具]]></title>
    <url>%2F2018%2F12%2F01%2Fffmpeg%E5%BD%B1%E9%9F%B3%E8%99%95%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[簡介有時候需要對影片、音樂做各種處理，例如轉檔、切割等等，這時候可以使用很強大的影音處理神器ffmpeg來做這些操作。 這邊不會細談調整編碼等細節，只是記錄日常常用到的操作指令而已。 安裝MAC1brew install ffmpeg 使用轉檔-f代表format1ffmpeg -i [要轉的檔案] -f [目標格式] [輸出檔名] 有哪些格式可選可用如下指令1ffmpeg -formats 裁減影片-ss代表從何時開始，-t代表維持時間，-to代表停止的時間1234# 從5秒開始後的30秒ffmpeg -i [要轉的檔案] -ss 00:00:05 -t 00:00:30 [輸出檔名]# 從5秒到25秒ffmpeg -i [要轉的檔案] -ss 00:00:05 -to 00:00:25 [輸出檔名] 顛倒影像-vf代表vedio filter，可以讓影片經過處理，轉換影片角度有下面三種常用 hflip：水平翻轉 vflip：垂直翻轉 transpose=1：順時針轉90度12345678# 水平翻轉ffmpeg -i [要轉的檔案] -vf hflip [輸出檔名]# 垂直翻轉ffmpeg -i [要轉的檔案] -vf vflip [輸出檔名]# 順時針轉90度ffmpeg -i [要轉的檔案] -vf transpose=1 [輸出檔名]# 逆時針轉90度ffmpeg -i [要轉的檔案] -vf transpose=2 [輸出檔名] 影片截圖-an代表不需要聲音，-vframes代表要抓幾張圖，-r代表每秒抓幾張圖12345ffmpeg -i [要轉的檔案] -an -ss [抓取時間] -vframes [幾張圖] -r [幾張圖] [輸出圖檔]# 在開始的時間抓一張圖ffmpeg -i [要轉的檔案] -an -ss 00:00:00 -vframes 1 cover.jpg# 從頭開始，每10秒抓一張圖ffmpeg -i [要轉的檔案] -an -ss 00:00:00 -vframes 1 -r 0.1 tmp-%d.jpg 調整音量大小-vol代表聲音大小，256是正常1ffmpeg -i [要轉的檔案] -n [聲音大小] [輸出檔名] 播放影音在ffmpeg內有一個tool是ffplay，可以簡單用來播放影音 雖然沒有進度條，但是如果按著右鍵左右移動也會有進度條的效果 1ffplay [影片名稱] 如果只想要播放音樂 1ffplay -vn [影片名稱] 如果只想要播放影片 1ffplay -an [影片名稱] 重複循環，0代表無限次 1ffplay -loop [次數] [影片名稱] 常用 影片轉音樂 1ffmpeg -i [要轉的檔案] -f mp3 [輸出檔名] 轉換成mp4 1ffmpeg -i [要轉的檔案] -f mp4 [輸出檔名] 裁減影片 1ffmpeg -i [要轉的檔案] -ss [開始時間] -to [結束時間] [輸出檔名] 抓截圖 1ffmpeg -i [要轉的檔案] -an -ss 00:00:00 -vframes 1 cover.jpg 聲音調整 1234# 調大聲音ffmpeg -i [要轉的檔案] -vol 300 [輸出檔名]# 調小聲音ffmpeg -i [要轉的檔案] -vol 200 [輸出檔名] 手機拍攝如果是反的情況 1234# 順時針ffmpeg -i [要轉的檔案] -vf transpose=1 [輸出檔名]# 逆時針ffmpeg -i [要轉的檔案] -vf transpose=2 [輸出檔名] 參考 FFmepg — 開源且功能強大的影音處理框架 - 針對ffmepg的架構進行介紹 FFmpeg 常用選項功能說明 ffplay常用命令 ffmpeg常用指令介紹]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dd - 資料處理的好工具]]></title>
    <url>%2F2018%2F11%2F25%2Fdd-%E8%B3%87%E6%96%99%E8%99%95%E7%90%86%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[簡介dd全名叫做data duplicator，這個工具最主要的功能是對資料作複製、修改、備份，是一個很方便的小工具。通常Linux中預設都會有，不需要額外安裝。 使用教學基本 輸入輸出參數 if=FILE：輸入名稱 of=FILE：輸出名稱 1dd if=[input_file] of=[output_file] 轉換 做相對應的轉換conv=CONVS lcase：大寫字母換小寫 ucase：小寫字母換大寫 nocreat：不要建立輸出檔案 notrunc：input小於output時，仍維持output大小 fdatasync：讓資料同步寫入硬碟 12# 轉為小寫dd if=[input_file] of=[output_file] conv=lcase 區塊 bs=[bytes]：等同於同時設定ibs和obs，一次讀或寫的block size。 ibs=[bytes]：指定每次讀取的block size(default 512 bytes) obs=[bytes]：指定每次寫入的block size(default 512 bytes) count=[number]：只處理前[number]輸入區塊，block size要參考ibs。 seek=[number]：輸出檔案跳過前[number]個區塊，block size要參考obs。 skip=[number]：輸入檔案跳過前[number]個區塊，block size要參考ibs。 常用指令 大小寫轉換 1234# 換大寫dd if=[input] of=[output] conv=ucase# 換小寫dd if=[input] of=[output] conv=lcase 產生一個特定大小的檔案 1234# 內容為空的1KB檔案dd if=/dev/zero of=[output] bs=1024 count=1# 內容為亂數的1MB檔案dd if=/dev/urandom of=[output] bs=1m count=1 把特定檔案的開頭512 byte清空 1dd if=/dev/zero of=[output] bs=512 count=1 conv=notrunc 備份硬碟 123dd if=[來源] of=[目標]# 例如從/dev/sda備份到/dev/sdbdd if=/dev/sda of=/dev/sdb 備份光碟，可參考Create an ISO Image from a source CD or DVD under Linux 先觀察/dev/cdrom 1isoinfo -d -i /dev/cdrom | grep -i -E &apos;block size|volume size&apos; 然後應該會出現類似如下內容 12Logical block size is: 2048Volume size is: 327867 接著參考上面的數字使用dd指令(bs大部分都是2048，而count其實有加沒加都沒差) 123dd if=/dev/cdrom of=test.iso bs=&lt;block size from above&gt; count=&lt;volume size from above&gt;# 以上述例子dd if=/dev/cdrom of=outputCD.iso bs=2048 count=327867 拆分&amp;合併檔案，可參考Splitting and Merging files using dd 拆分檔案，例如把檔案切成好幾個1G 123dd if=[大檔案] of=[part1] bs=1m count=1024dd if=[大檔案] of=[part2] bs=1m count=1024.... 合併檔案，例如好幾個1G合併起來 123dd if=[part1] of=大檔案 bs=1m count=1024dd if=[part2] of=大檔案 bs=1m count=1024 seek=1024.... 參考 dd 指令教學與實用範例，備份與回復資料的小工具]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[youtube-dl網路影片下載器]]></title>
    <url>%2F2018%2F11%2F25%2Fyoutube-dl%E7%B6%B2%E8%B7%AF%E5%BD%B1%E7%89%87%E4%B8%8B%E8%BC%89%E5%99%A8%2F</url>
    <content type="text"><![CDATA[簡介當我們要下載網路影片時，通常會去使用browser上的套件來下載，其實除了browser套件外，我們也可以使用command-line的方式，也就是這篇要介紹的youtube-dl。 youtube-dl功能十分強大，也有很多參數可以調整，能下載的網站不只是youtube，也可以是其他熱門網站，例如Facebook等等，更重要的是這個工具有多個平台可以使用(Windows、Mac、Linux)。 除了指令youtube-dl以外，我們也可以用GUI的介面的工具youtube-DLG，使用上更為方便，詳請可參考最強的網路影片下載器 Youtube-dl-gui 只要有網址就能幫你搞定。 安裝MAC123brew install youtube-dl# 如果有需要後續轉檔的話brew install ffmpeg Ubuntu123sudo apt-get install youtube-dl# 如果需要後續轉檔的話sudo apt-get install ffmpeg Python其實更好的方法是使用Python的pip來安裝，因為youtube-dl本身就是使用Python所寫成的，而由於影片的網站更新很快，所以可能要隨時更新到最新版的youtube-dl才行，OS distribution不一定會出的那麼快。123pip install --upgrade youtube_dl# 如果使用python3的話pip3 install --upgrade youtube_dl 使用這邊介紹一些常用的指令 支援 確定有支援下載哪些影片網站，相關列表也可以從官網查詢1youtube-dl --extractor-descriptions 格式如果我們沒有指定格式的話，通常youtube-dl會幫我們挑最好的 指定下載的影片格式123456# 先查詢有哪些格式可下載youtube-dl -F [URL]# 指定下載格式youtube-dl -f mp4 [URL]# 或是用format codeyoutube-dl -f [列表中的format code] [URL] 輸出格式由於官方的輸出格式預設有帶ID(%(title)s-%(id)s.%(ext)s)，我們可以將其去除1youtube-dl -o &apos;%(title)s.%(ext)s&apos; [URL] 字幕 選擇嵌入特定字幕 --write-sub代表下載字幕 --embed-sub代表嵌入字幕 --sub-lang代表要選擇的字幕1234# 先列出可下載的字幕列表youtube-dl --list-subs [URL]# 嵌入想要的字幕youtube-dl --write-sub --embed-sub --sub-lang [字幕] [URL] 直接嵌入所有字幕 --all-subs選擇所有字幕1youtube-dl --write-sub --embed-sub --all-subs [URL] 轉為音樂格式如果我們要下載音樂格式的話，基本上需要有ffmpeg的輔助 選擇要下載的音樂格式，例如mp3、m4a、flac等等 1youtube-dl -x --audio-format [音樂格式] [URL] 可以用--audio-quality強迫ffmpeg轉換較高品質的音樂，0是最好，9是最差 1youtube-dl -x --audio-format [音樂格式] --audio-quality [音樂品質] [URL] 下載時附上封面(使用youtube截圖)和音樂資訊(作曲者等等) 1youtube-dl -x --audio-format [音樂格式] --embed-thumbnail --add-metadata [URL] 下載播放清單 其實只要把[URL]換成播放清單的網址即可，不過我們也可以指定開始和結束位址 --playlist-start：開始 --playlist-end：結束，也就是倒數第幾個影片1youtube-dl --playlist-start [開始位置] --playlist-end [結束位置] [URL] 常用我這邊直接列出常用的指令，如果要使用可以直接copy比較快 下載mp4影片並加上字幕 1youtube-dl -f mp4 --write-sub --embed-sub --all-subs -o &apos;%(title)s.%(ext)s&apos; [URL] 下載mp3音樂，並加上封面 1youtube-dl -x --audio-format mp3 --audio-quality 0 --embed-thumbnail --add-metadata [URL] 參考 youtube-dl：下載 YouTube 影片的指令工具（支援 Windows、Linux 與 Mac OS X） Youtube-dl濃縮教學筆記]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「被討厭的勇氣」-擁有承擔責任的勇氣]]></title>
    <url>%2F2018%2F10%2F21%2F%E3%80%8C%E8%A2%AB%E8%A8%8E%E5%8E%AD%E7%9A%84%E5%8B%87%E6%B0%A3%E3%80%8D-%E6%93%81%E6%9C%89%E6%89%BF%E6%93%94%E8%B2%AC%E4%BB%BB%E7%9A%84%E5%8B%87%E6%B0%A3%2F</url>
    <content type="text"><![CDATA[簡介這篇想要介紹的是「被討厭的勇氣」這本書，書中用哲學家和年輕人用對話方式來闡述阿德勒心理學。由於阿德勒心理學跟較廣為人知的佛洛伊德心理學相比更冷門一點，所以很多想法都給現代人帶來啟發，也因此廣受歡迎。這系列書分為兩集，上集是對阿德勒心理學有個綜觀認識，而下集則是因為讀者有回饋不少意見而針對這些疑問的回答。個人認為下集比較偏向怎麼去實踐方面，其中幾乎有八成是在講教育部分。雖然我覺得一般人如何去實踐部分較少有點可惜，但是對諮商師、教師來說可能極具價值吧！其實書中討論的阿德勒心理學範圍還蠻廣的，原本我想嘗試用整體架構來分析，但是發現可能以目前所掌握的相關知識不足以做這樣的評論，所以我改成會針對幾點比較有收穫的概念來介紹。 目的論目的論其實是這本書很重要的精華，反對了宿命論，強調了人類可以自我改變的能力。我們常常太過注重因果關係了，「因為過去發生怎樣怎樣，所以現在的我才變成這樣」或是「都是因為他先怎樣怎樣，我才會這樣」。雖然某種層面上可能是對的，但是更可能的是這些都只是藉口，因為我們並非受制過去原因而行動，而是朝向自己決定好的目的而行動。換句話說，自己之所以不幸，完全是自己親手所選擇的。這個概念很重要，如果強調因果論，那代表的是現在的我是無法改變的，因為過去是無法改變的，這是宿命。然而將其想成是我們為了什麼目的才變成現在的自己，那隱含的意思是只要改變了目的，現在的自己也會跟著改變。不是因為過去的經驗形塑了現在的我，而是我去賦予過去經驗什麼意義來解釋自己的人生。由此可知，重要的不是經歷了什麼，而是如何去運用它。我們在生活中常常會對現狀不滿，這時候就會去找理由，都是因為環境、過去等等什麼原因導致自己這樣的。但是如果用目的理論來看，我們可能是「不想去改變」而去找理由。雖然現狀令人不滿，但是改變更加痛苦，為了不去改變，我們必須要有可以歸罪的理由。說直白一點，我們是因為缺乏「改變的勇氣」，所以寧可選擇了不幸的現狀。在目的論下，一切的理由都是藉口，當前現況完全是自己所選擇的。在下集有提到一個三角柱的概念，我們跟親人、朋友常常會抱怨誰誰誰很可惡，自己很可憐，這也就是三角柱其中兩面，「可惡的他」和「可憐的我」，但是更為重要的是第三面「今後該怎麼辦」。不斷地找理由不會改變現況，要專注於自己能改變的事情上面。老實說，目的論真的蠻殘酷的，我們為了讓自己好過一點，感性上會想逃避自己的責任，去抱怨外在的環境，但是就現實與邏輯而言，如果真的要改變現狀，那就得承擔起自己應負的責任，並找出改變的方法。「責任」與「勇氣」說起來容易，但是當想到要用在自己身上時，才真正感受到其重量。 逃離競爭關係阿德勒説：「一切的煩惱都是人際關係的煩惱」。雖然有點極端，不過確實人類的煩惱大多數是來自人際關係。其中對我而言，最常見的煩惱是怕自己輸給別人。人類與身俱來就有「追求卓越」的慾望，想奮發向上，但是一旦理想無法達成時，就會有產生自己低劣無能的「自卑感」。在當前社會上，其實都會有「競爭」的關係，在學校時是同學，在公司時是同事，會害怕自己輸給別人，擔心自己可能會輸，因此要不斷贏下去。儘管這種方式可以不斷促進自己進步，但也導致看到別人成功幸福時，會無法發自內心地去祝福，甚至更惡劣的，看到別人不幸會覺得可以證明自己的成功。其實我從求學階段就或多或少發現自己也有這樣的心態，不斷去比較自己與同儕間。然而競爭是一個無限循環，我打敗了一群人，還有更厲害的人在等著，就算我打敗所有人站在巔峰，還是會時時擔心自己會輸，不斷去維持自己的地位，這也意味著永遠得不到幸福。如果我們真的想獲得幸福，必須要脫離競爭模式，放棄比較。目前的我會把人生當做擁有一筆錢可以隨意去買自己想要的東西，如果去比較我買的東西跟別人比起來有沒有比較大、比較好，那並不會得到快樂。不如專心在選擇自己要買哪些東西，我想要買的東西組合肯定跟別人不一樣，也無從比較起，重點是買到的東西能不能帶給我快樂，而不是比別人還要好。 課題的切割其實從上面提到的目的論可以看出，阿德勒心理學很重視可控制這件事，因為可控這件事對人類而言十分重要，甚至有研究指出會影響到健康。如果用目的論來看，那代表人生是可控制的，我們能去改變。然而事實上人生還是有很多層面是不能控制的，特別是人與人關係，我沒辦法掌握別人怎麼想，如果不能控制，那就會造成自己的不安，對幸福人生來說是種破壞。關於這點，阿德勒提出了「課題切割」，劃清界線，這件事從哪邊開始是自己的課題，哪邊是別人的，最簡單的區分方式是思考「因為這個決定而帶來的結果，最後會由誰來承受？」。切割課題後，不去介入他人課題，也不讓他人介入自己的課題。介入他人的課題會背負他人的人生，而讓他人介入自己的課題則會讓自己左右為難，就像父子騎驢的故事，不管自己怎麼做，都有人會不滿意的。課題切割最高明的點在於確認了什麼是自己可控，什麼不是。我們只要專注在自己能改變的事情上，其他則不用太在意。按照書中的說法，這個就是人際關係的王牌，因為主動權在我手上，不用在意他人想法。也許會有人認為這樣會很招人厭惡，不太能夠做到。然而不這麼做，將會讓自己的人生變得很被動，因為要不斷去迎合別人。這邊也帶出了本書的書名，為了行使自由，讓自己依照自己的生活方針過日子，必須要能接受別人的討厭，因此需要擁有被討厭的勇氣。 建立橫向關係人際關係有分為橫向和縱向，阿德勒心理學否定一切的「縱向關係」，提倡所有的人際關係都應該是「橫向關係」。縱向關係帶來的是稱讚、責罵，然而橫向關係帶來的是尊敬、感謝。我會特別把這點拿出來提的原因是書中有舉一個很有趣的例子：假設你遵從上司的指示，結果卻因此面臨工作上的挫敗，這應該是誰的責任？如果是縱向關係的人就會認為是上司的責任，因為是上司的指示，然而這個卻是隱含著自己逃避了責任、閃避複雜的人際關係，因為不用思考太過困難的事、不必為失敗負責，所以仰賴他人的指示過日子。對於橫向關係的人來說，應該要拒絕並提出更好的方案，工作成敗是自己要負責的，沒有任何理由推託。其實在工作上還蠻常遇到為了避免麻煩，把問題交給別人決定的情況，讓別人決定別人負責，但是真正負責任的做法也許是自己也提出想法，然後再與別人共同討論並共識出較好的做法。除了對上關係外，對下也是「縱向關係」的一種，像是對孩童的讚賞或責罵。阿德勒很尖銳地指出，大人說對孩子好而去責罵通常不是真正為了小孩好，而是因為小孩犯錯隱含著大人有教育失敗的責任，而為了自己不要被批評，所以想要控制他照著自己的想法走。然而教育是為了讓孩子能夠自立，我們只能從旁提供協助，就算是失敗也是要由自己去負起責任。有點像是學習騎腳踏車，真正騎車的人是小孩自己，跌倒也必須是自己去承擔，但我們可以提供他建議和方法，如果怕小孩受傷而不放手，那他就永遠學不會騎車，只能不斷依賴我們。這跟教育有關的部分目前我大概只有這樣的了解，也許未來有小孩之後可能會有更多的體悟吧！ 活在當下「活在當下」這句話大部分的人都聽膩了，幾乎都變成是一個政治正確的口號，不過這邊我想提提阿德勒對活在當下的看法。本書用旅遊來比喻人生，出去旅遊絕對不是到達目的才叫旅行，如果是這樣我們就用最快的方式飛到目的地，然後再快速返回不就達成目標了？從自己踏出家門的那一刻起，就已經稱作旅行，旅行的概念是在到達目的前的每個瞬間，認真享受每個瞬間才是旅行的目的。同理人生也一樣，人生就像是登山攻頂的活動，有大半時間都在半路上，如果不能認真對待這個過程，只期待登頂的那個瞬間，那不就代表人生有一大半是沒有價值的？對我而言，常常也會期待未來會變得更好，希望「當下」趕快過去，只要我做完什麼事情人生就會不一樣了，像是學生時期要準備大考、工作時要面對大案子等等。可是再回過頭來想，面對困難挑戰永遠只想說熬過去人生會更好，好像完全沒有真正更好過，因為我只有完成挑戰那一瞬間獲得解脫的快樂，但很快又會有下一個挑戰。與其自己只能在這樣的痛苦中不斷輪迴，不如專心面對當下每個瞬間。關於活在當下，其實也是呼應了前面目的論的看法。「人生是一連串的剎那，過去和未來都不存在，別想要藉著回顧過去、預見未來，給自己一個免除責任的藉口。」由於自己真正擁有的是現在，如果用過去當做藉口，就意味著放棄了現在所擁有的選擇權。當自己想把現在的不如意推給過去，或是期盼未來會更好時，都要注意是不是根本沒有活在現在，應該要認真做當下自己所能做改變的事情。 評價以書寫手法來說，兩本書的結尾基本上是年輕人被哲學家說服，受到感動想去嘗試阿德勒心理學，說實在這有點讓人覺得矯情，我覺得其實不用用這種傳教意味濃厚的結尾也不會讓書的價值打折扣，不太清楚為什麼用這種想煽動人心的結尾。另外，很多觀念在對話中並沒辦法越辯越明，個人認為講不夠詳細、邏輯不夠清楚的地方還蠻多的。舉個例子，書中有提到要無條件相信別人，但下集又提到相信不是照單全收，對於對方的思想信念要持懷疑態度，如果我都對人產生懷疑了，還稱得上是信任嗎？這裡作者沒有做更詳細的解釋。當然這可能也是對話方式的書籍所受限之處，畢竟對話類型的書比起理論類型更能讓一般人接受，但對話勢必要省略比較細節的內容了。看完上下兩集後，我認為如果是要把阿德勒心理學當作是自己的人生觀，還有太多需要釐清之處了，而且這也會有洗腦之嫌。然而不可否認，他在百年前提出的這些思想確實有其高明之處，簡而有力地戳破我們不敢面對的一面，這些部分可以再好好理解並且善用在生活中。我們可以利用前人的思想來形塑自己的人生觀，但是不要只是照本宣科去執行，這樣就跟下集一開始的年輕人一樣會陷入苦惱之中了。如果認為完完全全照著某個理論做就可以得到幸福，那其實不也是逃避負責任，缺乏真正去面對自己人生的勇氣呢？]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GnuPG教學]]></title>
    <url>%2F2018%2F10%2F14%2FGnuPG%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[簡介GPG全名為Gnu Privacy Guard(GnuPG) ，最初的目的是為了加密通訊的加密軟體，是為了替代PGP並符合GPL而產生的。目前很多自由軟體社群要驗證身份也都會需要用到這套工具。 使用安裝 指令 1234# Ubuntusudo apt-get install gnupg# MAXbrew install gnupg GUI 其實現在GUI介面都做得很好看了，而且也很容易上手，建議可以用GUI的tools。 MAC的GUI tools可從gpgtools.org安裝 建立key 先產生key 可選擇”RSA &amp; RSA”，key長度為4096 真實姓名就填自己的英文名字，備註可填中文 產生的key會放在~/.gnupg這個目錄下 記得要輸入密碼，防止別人入侵系統時可以直接拿到私鑰 最後會產生出user ID的hash(UID)123gpg --full-generate-key# 如果gen key發生問題，可用如下指令後再一次gpgconf --kill gpg-agent 接下來就是產生撤銷憑證，未來忘記密碼可以用來撤銷，因此要小心保管 注意如果key有填utf-8，這步在MAC可能會出問題，不過如果是用GUI卻沒問題，原因並不清楚。123gpg -o revocation.crt --gen-revoke [UID]# 也可以直接放到.gnupg內gpg --gen-revoke [UID] &gt; ~/.gnupg/revocation-[UID].crt 釋出公鑰，這個公鑰可以傳給朋友，或是上傳到server -a：代表匯出明碼 -o：代表輸出檔名1gpg -ao mypublic.asc --export [UID] 如果是要把朋友的公鑰放入已知道人的清單 1gpg --import friends.asc 可以用fingerprint顯示自已的公鑰後，弄到pdf上印出 1gpg -v --fingerprint [UID] 管理key查看、編輯與刪除key 查看目前的鑰匙 123456# 列出所有公鑰gpg --list-keys# 同時看簽名gpg --list-sigs # 列出所有私鑰gpg --list-secret-keys 編輯key(對key簽名也是用同樣的方法) 1gpg --edit-key [UID] 刪除已存入key的方式，如果有私鑰要先刪除 1234# 先刪除私鑰gpg --delete-secret-key [UID]# 刪除公鑰gpg --delete-key [UID] 搜尋 首先先搜尋對象的public key 這裡指定的key server是用MIT的，可以找其他也有公信力的Server，可參考wiki)1gpg --keyserver hkp://pgp.mit.edu --search-keys &apos;Linus Torvalds&apos; 得到對方的public key後，將其存入~/.gnupg/pubring.gpg 1gpg --keyserver hkp://pgp.mit.edu --recv-keys 79BE3E4300411886 可查看與更新朋友的public key 12gpg --list-keysgpg --refresh-keys import/export 除了搜尋以外，也可以用import/export的方式管理朋友的公鑰 12gpg --import public_keys_list.txtgpg --export -ao public_keys_list.txt import/export自己的金鑰 123456# export 公鑰gpg --armor --output public-key.asc --export [UID]# export 私鑰gpg --armor --output private-key.asc --export-secret-keys [UID]# importgpg --import [金鑰] 用key傳送接收信件 假設我們要傳送secret.tgz給朋友，可以先進行加密 1gpg -ear 朋友 &lt; secret.tgz &gt; secret.tgz.asc 朋友收到secret.tgz.asc後可用如下指令變回secret.tgz 1gpg -d &lt; secret.tgz.asc &gt; secret.tgz 如果要確認發信人身份 1234# 先對檔案簽名gpg --clearsign file.txt# 驗證檔案身份gpg --verify &lt; file.txt.asc 參考 使用 GnuPG 建立你的 PGP 金鑰， 讓別人能夠私密寄信給你 Debian關於Keysigning的教學 GnuPG (正體中文)-GnuPG) GPG入门教程-阮一峰 gpg 數位簽章]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[軟技能：軟體界的「原則」]]></title>
    <url>%2F2018%2F07%2F04%2F%E8%BB%9F%E6%8A%80%E8%83%BD%EF%BC%9A%E8%BB%9F%E9%AB%94%E7%95%8C%E7%9A%84%E3%80%8C%E5%8E%9F%E5%89%87%E3%80%8D%2F</url>
    <content type="text"><![CDATA[今天想要來介紹一本對軟體工程師來說很棒的書，叫做軟技能：代碼之外的生存指南 (Soft Skills : The software developer’s life manual) 。最一開始會關注到這本書是因為有人介紹說這本書堪稱是軟體界的「原則」。由於對「原則」有還不錯的評價，所以就有了閱讀的興趣。這本書號稱是給軟體工程師看的書，但是裡面卻沒有任何一行程式碼，作者希望告訴讀者的是要成好的軟體工程師，不能只專注在專業上，要把重點放在「整個人」上。書中分享了如何找工作、自我營銷、自我學習等等，甚至還有理財、健身和愛情。同樣身為軟體工程師，我認為可以從前人身上觀察和學習他的經驗應該是蠻有幫助的，因此下面會分享幾個從書中學到比較重要的概念。 第一個是就算是受聘於公司，也應該要當作自己是在經營生意。只有把「我」當成是一家公司看待，才能做出好的商業決策。在一般公司朝九晚六(如果沒加班的話)的生活，很容易把個人的思維限制住，認為就是把固定事情做好然後領固定的薪水。然而，如果從經濟學的角度來看，其實我們都是在販賣服務並且獲取報酬，只是販賣的對象是固定某個客戶而已。當可以用比較宏觀的角度看待工作的時候，就會發現可以選擇的策略比想像中多很多，例如開始評估自己所提供的服務和價錢跟當前市場狀況是否有吻合，不吻合的話就會進一步精進服務的內容(提升能力)，或是開拓其他可能的客戶(找其他公司)。這種心態上的轉變會讓我們不會只是被動接受現況，而會有積極的思維去影響現實，獲得更好的結果。 再來關於自我行銷的方面作者也提到很多，自我行銷其實跟前面相呼應，如果要把工作當作在經營生意，怎麼讓潛在客戶知道自己就很重要。找工作最容易的方法是讓工作來找你，當別人有求於你時，就更容易得到比較好的條件。對軟體工程師來說，最好的行銷方式就是寫blog，有許多有價值的文章，自然知名度就會打開。書中強調了好幾次經營blog的重要性，然後還提到最重要的就是毅力，只要持之以恆地撰寫文章，就已經勝過大多數的同行了。雖然我本身已經有意識地在經營blog了，但是常常都只是想說留個紀錄供自己未來參考。然而作者反對這種做法，他認為如果要能吸引別人最重要的是出發點是對他人有益，如果能夠對他人產生價值，就會受到關注，因此文章不是自己寫開心就好。這對我過去寫文章的方式是一種震撼，現在開始會思考我的記錄事情的角度是否可以解決讀者遇到的問題，是否容易閱讀及理解。 在變動很快的科技業中，如何自我學習是非常重要的，特別是軟體業，沒多久就有新的framework或程式語言出現，這些技術大概很難透過學校老師教導，只能靠著自己尋找資源去學習。書中作者介紹了十步學習法，不過我不打算在這裡細部講解這個方法，取而代之，我想分享作者提到的四個自學方式循環：學習、實踐、掌握、教授。我們不應該期待自己把某個領域學完後再開始應用，要盡量在最短時間內找到必須要學會的內容，然後就去實踐，從實踐過程中一定會遇到問題，這時再回去翻資料掌握這些問題，當有一定程度的理解後，嘗試跟他人分享，確認是否真的理解。透過這樣的循環，可以幫助自己更快掌握該領域知識。其實這套方法跟之前我看過的有效自學方式很類似，例如最小必要知識架構術、費曼法，很明顯這些方法已經成為主流了。我想，不應該被傳統的學習概念(從基礎知識一步步慢慢學習)所限制，而是從應用面來學習，也就是知道自己要做到什麼，反推回去需要學習哪些知識，不但有效率，而且也更符合這個社會緊湊的腳步。 關於時間管理的部分，作者推薦用使用番茄鐘(通常代表的是工作25min後休息5min)，如果不知道番茄鐘可以參考wiki的介紹。這一年下來，其實我都是用番茄鐘來管理我的時間，目前也覺得透過番茄鐘，確實可以幫助專注力，然而我卻從書中發現自己並沒有善用番茄鐘最大的威力。番茄鐘並不只是用來幫助自己提升效率的工具，更重要的是可以用來幫助時間規劃。在時間管理上，最常遇到的問題就是不知道每項工作到底要花多少時間做完，而在固定時間內，到底可以做完多少事情。這兩個問題番茄鐘都幫忙解決了，透過把一項大任務切割成番茄鐘的長度，代表的是強迫自己分割大任務變成可估算完成時間的小任務，而每個人每天可以完成多少的番茄鐘是有數量限制的，也代表我們會很清楚每天可以做多少事情，這樣規劃方式可以加強預測工作進度的準確度。另外番茄鐘帶來的另一個好處是可以更安心地進行休閒活動，大家應該會有經驗如果去玩樂會有種罪惡感想逼自己去工作，如果清楚每日能做到的番茄鐘數量，那休息享樂時就不會感到內疚，因為每天該完成的工作都已經達成了！ 最後一點是關於自我弱點的方面，從小到大我們所受的教育都是要把缺點彌補起來，然而這在專業上其實是說不通的，大家應該常聽過樣樣通，樣樣鬆。與其告訴他人自己會很多東西，不如專精在比較小的領域(或是大領域中的某種應用)，也許在市場上並沒有那麼多的需求，但是錄取機率則會大幅增加。不過也是有要去彌補弱點的情況，那就是該弱點會大幅影響效率時。當不知道某項技術其實可以很容易達成某件事前，可能都會很排斥去學習，但其實只要花幾個小時就能獲得很大的效益，也就是常聽到的CP值很高。然而要怎麼找到這些CP值高的技術呢？我們可以記錄每個自己沒聽過技術的遇到頻率，當遇到頻率高於一定值時，那就代表有學習的價值。舉個例子，其實我有時候看經濟新聞都會聽到A輪、B輪等等名詞，但是都一直沒動力去搞懂，結果對新聞內容都一知半解。在看本書的理財部份時，作者有做一個簡單的解釋，結果花不到半小時，就對這些常見名詞有初步認識了，也變相了加深我對經濟新聞理解，像是這種知識就很值得花時間投資。 當然這本書還有很多很有價值的內容，不過受限於篇幅，無法每個都說。如果對上面的分享心有戚戚焉的話，我想這本書應該蠻適合你。進入科技業也不過快三年而已，未來應該還有很長的職業生涯，如何好好經營是很大的課題。目前還是以多多參考前輩們的經驗以及不斷自我反省為主，找出真正適合自己的道路。]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux和程式的互動]]></title>
    <url>%2F2018%2F06%2F12%2FLinux%E5%92%8C%E7%A8%8B%E5%BC%8F%E7%9A%84%E4%BA%92%E5%8B%95%2F</url>
    <content type="text"><![CDATA[簡介這篇我們想要來探討 Linux 是怎麼和程式互動的，這邊包括兩個部分：Linux 如何執行程式以及程式如何讓 Linux 做系統操作。 程式如何執行main一般要呼叫程式來執行的，我們知道的是只要在 shell 下類似./a.out的指令，程式就會執行我們程式中的 main，但是這其中的原理是什麼呢？讓我們看看到執行 main 前做了哪些事。 下面例子我們以Kernel v4.17為例 首先 shell 會 fork 一個 process，然後再呼叫 exec 系列函數把該 process 置換成指定的程式 execve 會呼叫 do_execve ，然後再呼叫 do_execveat_common，可參考fs/exec.c的1856行 12345678int do_execve(struct filename *filename, const char __user *const __user *__argv, const char __user *const __user *__envp)&#123; struct user_arg_ptr argv = &#123; .ptr.native = __argv &#125;; struct user_arg_ptr envp = &#123; .ptr.native = __envp &#125;; return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);&#125; 接著do_execveat_common會讀取struct linux_binprm，並且根據檔案格式尋找適合的binary header 12345678910111213141516171819202122232425262728static int do_execveat_common(int fd, struct filename *filename, struct user_arg_ptr argv, struct user_arg_ptr envp, int flags)&#123;... // 重要的structure，保留執行檔的相關訊息 struct linux_binprm *bprm;... // 打開要執行的ELF檔 file = do_open_execat(fd, filename, flags);... // 生成mm_struct，供執行檔使用 retval = bprm_mm_init(bprm); if (retval) goto out_unmark; // 計算帶入的參數 bprm-&gt;argc = count(argv, MAX_ARG_STRINGS); if ((retval = bprm-&gt;argc) &lt; 0) goto out;... // 讀取 header retval = prepare_binprm(bprm);... // 裡面會呼叫 search_binary_handler，根據檔案格式呼叫適合的binary_handler retval = exec_binprm(bprm);...&#125; ELF的binary handler位在fs/binfmt_elf.c的690行，做了header確認後會load program header和設定並執行elf_interpreter 12345678910111213141516171819202122static int load_elf_binary(struct linux_binprm *bprm)&#123;... // 讀取program header elf_phdata = load_elf_phdrs(&amp;loc-&gt;elf_ex, bprm-&gt;file);... // 讀取elf_interpreter retval = kernel_read(bprm-&gt;file, elf_interpreter, elf_ppnt-&gt;p_filesz, &amp;pos); // 把當前程式資訊清除並換上新的程式 retval = flush_old_exec(bprm);... current-&gt;mm-&gt;end_code = end_code; current-&gt;mm-&gt;start_code = start_code; current-&gt;mm-&gt;start_data = start_data; current-&gt;mm-&gt;end_data = end_data; current-&gt;mm-&gt;start_stack = bprm-&gt;p;... // 執行elf_interpreter start_thread(regs, elf_entry, bprm-&gt;p);...&#125; 經過Context Switch後，應該會從elf_interpreter執行，通常應該會是/lib/ld-x.x.so。ld-x.x.so的進入點是_start，最後會連結到glibc/elf/rtld.c的_dl_start，針對環境變數做處理。 我們常見的LD_PRELOAD也是在這邊進行處理的 當上述工作都做完後，就會進入 ELF binary 的_start，其中會呼叫 glibc 的__libc_start_main進行初始設定，最後就會呼叫main()1result = main (argc, argv, __environ MAIN_AUXVEC_PARAM); 使用 system call通常AP在Linux要跟kernel層互動大概只能透過system call，然而system call的使用大多數已經被包裝起來，所以幾乎不會看到，這邊我們來探討一下要怎麼在Linux直接呼叫system call。以下範例皆來自BINARY HACKS：駭客秘傳技巧一百招 syscall最簡單的呼叫system call方法是syscall。 syscall.c123456789101112#include &lt;stdio.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; int ret; ret = syscall(__NR_getpid); printf("ret=%d pid=%d\n", ret, getpid()); return 0;&#125; 執行結果如下123$ make syscall$ ./syscallret=18 pid=18 看起來是很順利取得PID。我們可以把__NR_getpid換成其他的system call數字，也可以達到同樣效果。 int 0x80當然我們也可以用int 0x80來做到同樣的事情，但是要注意的是這樣的效率不會比較好，可參考What is better “int 0x80” or “syscall”? 另外這個做法在x64的架構是無法被使用的，可參考What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code? syscall2.c1234567891011#include &lt;stdio.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; int ret; asm volatile (&quot;int $0x80&quot;:&quot;=a&quot;(ret):&quot;0&quot;(__NR_getpid)); printf(&quot;ret=%d pid=%d\n&quot;, ret, getpid()); return 0;&#125; sysenter這部分也是只能在x86的平台上使用，會出現這個機制的理由是int 0x80的效率實在太差了。這邊的使用方式有點複雜，就不列出來了。 比較這三種方式的比較簡單統整一下 syscall：現在主流，能在x64運行int 0x80：只能在x86，效率差，已被捨棄sysenter：只能在x86，用來替代int 0x80 詳情可以參考Linux系统调用机制int 0x80、sysenter/sysexit、syscall/sysret的原理与代码分析，寫得非常詳細。 參考 BINARY HACKS：駭客秘傳技巧一百招 Linux系统ELF程序的执行过程 _dl_start源码分析 Linux系统调用机制int 0x80、sysenter/sysexit、syscall/sysret的原理与代码分析]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc常用擴充功能]]></title>
    <url>%2F2018%2F06%2F09%2Fgcc%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[簡介GNU gcc其實在編譯時也可以帶許多特殊功能，讓程式更佳的彈性，並帶來優化或更好debug的效益。這邊我們主要介紹兩個功能，內建函式和屬性__attribute__。 內建函式要特別注意的是，這些內建函數是跟CPU架構息息相關，所以並不是每個平台都可以順利使用。另外就是編譯的時候不能帶上-fno-builtin選項，通常-fno-builtin是為了幫助我們確保程式的結果是如同我們所想像的樣子呈現，而不會被一些最佳化改變樣子，方便設定breakpoint和debug。 找呼叫者首先我們先來談談找呼叫者這件事，我想大家應該都有經驗曾經發現程式死在某一行，但是卻不知道是誰呼叫的，這時候只能痛苦地去從stack反推return address。但是其實gcc內是有特殊內建函式可以幫助我們的，這邊介紹下面兩個好用函式。 void *builtin_return_address(unsigned int LEVEL)：找到函式的return address是什麼，參數的LEVEL代表要往上找幾層，填0的話代表呼叫當前函式者的下一個執行指令。 void *builtin_frame_address(unsigned int LEVEL)：找到函式的frame pointer，參數的LEVEL代表要往上找幾層，填0的話代表呼叫當前函式者的frame pointer。 要注意的是LEVEL不能填變數，也就是編譯時必須確定該數字。 範例我們還是透過一個簡單的例子來說明一下 test.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;void test3(void)&#123; void *ret_addr, *frame_addr; ret_addr = __builtin_return_address(0); frame_addr = __builtin_frame_address(0); printf("0: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); ret_addr = __builtin_return_address(1); frame_addr = __builtin_frame_address(1); printf("1: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); ret_addr = __builtin_return_address(2); frame_addr = __builtin_frame_address(2); printf("2: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); ret_addr = __builtin_return_address(3); frame_addr = __builtin_frame_address(3); printf("3: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); printf("test3\n");&#125;void test2(void)&#123; void *ret_addr, *frame_addr; ret_addr = __builtin_return_address(0); frame_addr = __builtin_frame_address(0); printf("0: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); ret_addr = __builtin_return_address(1); frame_addr = __builtin_frame_address(1); printf("1: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); ret_addr = __builtin_return_address(2); frame_addr = __builtin_frame_address(2); printf("2: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); printf("test2\n"); test3();&#125;void test1(void)&#123; void *ret_addr, *frame_addr; ret_addr = __builtin_return_address(0); frame_addr = __builtin_frame_address(0); printf("0: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); ret_addr = __builtin_return_address(1); frame_addr = __builtin_frame_address(1); printf("1: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); printf("test1\n"); test2();&#125;void test(void)&#123; void *ret_addr, *frame_addr; ret_addr = __builtin_return_address(0); frame_addr = __builtin_frame_address(0); printf("0: "); printf("ret_addr=0x%x frame_addr=0x%x\n", ret_addr, frame_addr); printf("test\n"); test1();&#125;int main()&#123; test(); return 0;&#125; 好，那我們來編譯並執行看看12345678910111213141516$ make test$ ./test0: ret_addr=0x4007c8 frame_addr=0x2bba8ba0test0: ret_addr=0x4007bc frame_addr=0x2bba8b801: ret_addr=0x4007c8 frame_addr=0x2bba8ba0test10: ret_addr=0x40076d frame_addr=0x2bba8b601: ret_addr=0x4007bc frame_addr=0x2bba8b802: ret_addr=0x4007c8 frame_addr=0x2bba8ba0test20: ret_addr=0x4006e1 frame_addr=0x2bba8b401: ret_addr=0x40076d frame_addr=0x2bba8b602: ret_addr=0x4007bc frame_addr=0x2bba8b803: ret_addr=0x4007c8 frame_addr=0x2bba8ba0test3 可以看到每層function所對應的return address和frame address都被列出來，但是要怎麼驗證是否真的是這樣呢？我們把程式逆向一下看位置。這邊我們鎖定test1()的return address，也就是0x4007bc，應該是test()函式的呼叫test1()的下一行。1234567891011121314$ objdump -d test...0000000000400770 &lt;test&gt;: 400770: 55 push %rbp 400771: 48 89 e5 mov %rsp,%rbp... 4007b2: e8 59 fc ff ff callq 400410 &lt;puts@plt&gt; 4007b7: e8 28 ff ff ff callq 4006e4 &lt;test1&gt; 4007bc: 90 nop 4007bd: c9 leaveq 4007be: c3 retq00000000004007bf &lt;main&gt;:... 的確，下一行nop的位置就是就是4007bc，符合我們的想法。 其他有用的builtin函式除了上面的例子，其實還有其他有用的builtin函式，這邊就只是列出來提供參考： int __builtin_types_compatible_p(TYPE1, TYPE2)：檢查TYPE1和TYPE2是否是相同type，相同回傳1，否則為0。注意這邊const和非const會視為同種類型。 TYPE __builtin_choose_expr(CONST_EXP, EXP1, EXP2)：同CONST_EXP?EXP1:EXP2的概念，但是這個寫法會在編譯時就決定結果。常用方式是在寫macro時可以搭配__builtin_types_compatible_p當作CONST_EXP，選擇要呼叫什麼函式。 int __builtin_constant_p(EXP)：判斷EXP是否是常數。 long __builtin_expect(long EXP, long C)：預先知道EXP的值很大機率會是C，藉此做最佳化，kernel的likely和unlikely也是靠這個實現的。 void __builtin_prefetch(const void *ADDR, int RW, int LOCALITY)：把ADDR預先載入快取使用。 RW：1代表會寫入資料，0代表只會讀取 LOCALITY：範圍是0~3，0代表用了馬上就不用(不用關心time locality)、3代表之後還會常用到 int __builtin_ffs (int X)：回傳X中從最小位數開始計算第一個1的位置，例如__builtin_ffs(0xc)=3，當X是0時，回傳0。 int __builtin_popcount (unsigned int X)：在X中1的個數 int __builtin_ctz (unsigned int X)：X末尾的0個數，X=0時undefined。 int __builtin_clz (unsigned int X)：X前面的0個數，X=0時undefined。 int __builtin_parity (unsigned int x)：Ｘ值的parity。 __attribute__weak &amp; alias測試是否支援某function通常會使用__attribute__(weak)是為了避免有函式衝突的狀況，我們看個例子a.c12345678910111213141516#include &lt;stdio.h&gt;extern void printf_test(void) __attribute__((weak));int main()&#123; printf("This is main function\n"); if(printf_test) &#123; printf("Here is printf_test result: \n"); printf_test(); &#125; else printf("We don't support printf_test\n"); return 0;&#125; 1234$ make a$ ./aThis is main functionWe don&apos;t support printf_test 雖然我們沒有printf_test，但是直接編譯是會通過的，因為printf_test被視為weak，假設在連結時找不到，是會被填0的。 那如果有printf_test的情況呢？我們加上b.c重新編譯看看123456#include &lt;stdio.h&gt;void printf_test(void)&#123; printf("This is b function.\n");&#125; 12345$ gcc a.c b.c$ ./a.outThis is main functionHere is printf_test result:This is b function. 看起來就會執行printf_test了。這樣的功能對我們要動態看有無支援函式幫助很大。 為函式加上default值這邊我們會用到alias的attribute，alias的話通常會跟weak一起使用，最常被用到的是幫不確定有無支援的函式加上default值。 a.c1234567891011121314151617#include &lt;stdio.h&gt;void print_default(void)&#123; printf("Not support this function.\n");&#125;void print_foo(void) __attribute__((weak, alias("print_default")));void print_bar(void) __attribute__((weak, alias("print_default")));int main()&#123; printf("This is main function\n"); print_foo(); print_bar(); return 0;&#125; b.c123456#include &lt;stdio.h&gt;void print_foo(void)&#123; printf("foo function.\n");&#125; 12345$ gcc a.c b.c$ ./a.outThis is main functionfoo function.Not support this function. 可以看到因為print_bar並沒有被宣告，所以最後會執行alias的print_default。 在main前後執行程式有時候會想要在main的執行前後可以做些事，這時候就會用到下面兩個attribute constructor：main前做事 destructor：main之後做事 讓我們看個範例 test.c12345678910111213141516171819#include &lt;stdio.h&gt;__attribute__((constructor))void before(void)&#123; printf("before main\n");&#125;__attribute__((destructor))void after(void)&#123; printf("after main\n");&#125;int main()&#123; printf("This is main function\n"); return 0;&#125; 12345$ make test$ ./testbefore mainThis is main functionafter main 結果的確如我們所料。另外這邊有點要注意，跟前面不一樣的是，__attribute__((constructor))和__attribute__((destructor))必須放在函式前面，不然會有error: attributes should be specified before the declarator in a function definition的錯誤。 其他attribute剩下還有一些有機會會用到的attribute，這邊就不多談，只列出來參考。 __attribute__((section(&quot;section_name&quot;)))：代表要把這個symbol放到section_name中 __attribute__((used))：不管有沒有被引用，這個symbol都不會被優化掉 __attribute__((unused))：沒有被引用到的時候也不會跳出警告 __attribute__((deprecated))：用到的時候會跳出警告，用來警示使用者這個函式將要廢棄 __attribute__((stdcall))：從右到左把參數放入stack，由callee(被呼叫者)把stack恢復正常 __attribute__((cdecl))：C語言預設的作法，從右到左把參數放入stack，由caller把stack恢復正常 __attribute__((fastcall))：頭兩個參數是用register來存放，剩下一樣放入stack 參考 BINARY HACKS：駭客秘傳技巧一百招 gcc的__builtin_函数介绍 6.57 Other Built-in Functions Provided by GCC __attribute__之weak,alias属性]]></content>
      <categories>
        <category>系統程式</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linker script 簡單教學]]></title>
    <url>%2F2018%2F06%2F02%2Flinker-script-%E7%B0%A1%E5%96%AE%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[簡介最近由於工作常常會用到，所以打算來談談如何來撰寫 linker script，也可以當作未來自己參考用途。 linker的作用就是把輸入檔(object file)的 section 整理到輸出檔的 section。除此之外也會定下每個object file 中尚未確定的符號位址，所以如果有 object file 用到不存在的symbol，就會出現常看到的 undefined reference error。 而 linker script 就是提供給 linker 參考的文件，它告訴 linker 我想要怎麼擺放這些 section，甚至也可以定義程式的起始點在哪邊。 簡單範例最簡單的 linker script 是用SECTIONS指令去定義 section 的分佈。 test.ld12345678SECTIONS&#123;. = 0x10000;.text : &#123; *(.text) &#125;. = 0x8000000;.data : &#123; *(.data) &#125;.bss : &#123; *(.bss) &#125;&#125; 在上例，.被稱作 location counter，代表的是指向現在的位址，我們可以讀取或是移動它 (我覺得可以想像成我們在打電腦文件時的游標，代表現在要處理這個位置)。 這段 script 主要做的事是，先把 location counter 移到 0x10000，在這裡寫入所有輸入檔的.text section後，再來移到0x8000000放所有輸入檔的.data section跟.bss section。 當然，最重要的還是去嘗試，所以讓我們來試試看，結果是不是真的像我們所想的。 main.c123456789101112void test(void);int global_bss;int global_data = 123;int main()&#123; global_bss = 0; test(); global_data++; return 0;&#125; test.c123456void test(void)&#123; int i; // do nothing. for (i = 0; i &lt; 10000; i++);&#125; 嘗試編譯並看結果123456789101112131415161718$ gcc -c main.c test.c$ ld -T test.ld main.o test.o$ objdump -h a.outa.out: file format elf64-x86-64Sections:Idx Name Size VMA LMA File off Algn 0 .text 00000046 0000000000010000 0000000000010000 00010000 2**0 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .eh_frame 00000058 0000000000010048 0000000000010048 00010048 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 2 .data 00000004 0000000008000000 0000000008000000 00200000 2**2 CONTENTS, ALLOC, LOAD, DATA 3 .bss 00000004 0000000008000004 0000000008000004 00200004 2**2 ALLOC 4 .comment 00000011 0000000000000000 0000000000000000 00200004 2**0 CONTENTS, READONLY 我們可以看到在VMA和LMA的地方，text是從0x10000開始，data和bss則是從0x8000000開始放，跟我們所安排的結果一樣。 這邊說明一下，一定會有人覺得奇怪，為什麼編譯出來的檔案無法執行，這個是因為我們並沒有符合 Linux 可執行的格式來 link，如果你想要知道一般我們下 gcc 是使用什麼 linker script 的話，可以使用如下方式： 1gcc -Wl,-verbose main.c test.c 這樣就可以看到所使用的 linker script 了。 常用的功能接著我們來談談在linker script中常見到的功能，這邊我們可以參考 jserv 帶領成大同學開發的 rtenv 中的 linker script 那我們就一一了解每個符號的意義吧！ ENTRY用 ENTRY 可以指定程式進入點的符號，不設定的話 linker 會試圖用預設.text的起始點，或者用位址0的地方。 以 x86 為例，預設進入點是ENTRY(_start)，而 rtenv 則是設定為 ENTRY(main) MEMORYLinker 預設會取用全部的記憶體，我們可以用 MEMORY 指令指定記憶體大小，在 rtenv 的例子中，指定了 FLASH 跟 RAM 兩種的輸出位置與大小 ORIGIN代表起始位置，LENGTH為長度12345MEMORY&#123; FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 128K RAM (rwx) : ORIGIN = 0x20000000, LENGTH = 20K&#125; 接下來SECTION部分，就能用 &gt; 符號把資料寫到指定的位置12345.bss : &#123; _sbss = .; *(.bss) /* Zero-filled run time allocate data memory */ _ebss = .; &#125; &gt;RAM KEEPKEEP 指令保留某個符號不要被 garbage collection ，例如我們不希望 ARM 的 ISR vector 會被優化掉。 12345.text : &#123; KEEP(*(.isr_vector))... &#125; section 的本體section 的指定方式是 linker script 中的重點，其中也有許多設定。 我們可以參考官方文件先對 section 的功能做一個快速了解。 12345678910section [address] [(type)] : [AT(lma)] [ALIGN(section_align) | ALIGN_WITH_INPUT] [SUBALIGN(subsection_align)] [constraint] &#123; output-section-command output-section-command ... &#125; [&gt;region] [AT&gt;lma_region] [:phdr :phdr ...] [=fillexp] output-section-command 代表的就是我們要怎麼擺放每個 section。 在這個例子裡可以看到有許多 LMA，除了 LMA 外，其實還有 VMA，它們兩個究竟有什麼不同呢？ LMA/VMA 的概念這裡大概是最重要的部分，也是之前我一直搞不清楚的地方。 link script 中設計了兩種位址：VMA 和 LMA LMA (Load Memory Address) VMA (Virtual Memory Address) 位置 ROM/Flash RAM 意義 程式碼保存的位置 程式碼執行的位址 也就是 LMA 是 output file 的位置，VMA 是載入 section 到 RAM 時的位置，但是在大多數情況下兩者會是一樣的。 我們再看看上例是怎如何指定 LMA 和 VMA 的 LMA 是用AT或AT&gt;來決定位址，為可選，沒指定就用VMA當LMA AT(LMA)：告訴 linker 這個 section 應該要去哪個 LMA 載入資料到 VMA，要填 address AT&gt;lma_region：為 LMA 所在區域，需事先定義 &gt;region：為 VMA 所在區域，region需事先定義 在 linker script 的寫法基本上是這個架構[VMA] : [AT(LMA)] 繼續以 rtenv 為例，當指定了_sidata的 symbol 位置後，AT 就是要求載入到 FLASH 時要在.text的後面，換句話說.data的 LMA 要在.text後 12345678/* Initialized data will initially be loaded in FLASH at the end of the .text section. */.data : AT (_sidata)&#123; _sdata = .; *(.data) /* Initialized data */ *(.data*) _edata = .;&#125; &gt;RAM 取得 section 的位置在程式中，有時候可能還是會需要取得每個 section 的所在位址，我們可以用如下的方式取得123456789101112131415161718.text : &#123; KEEP(*(.isr_vector)) *(.text) *(.text.*) *(.rodata) *(.rodata*) _smodule = .; *(.module) _emodule = .; _sprogram = .; *(.program) _eprogram = .; _sromdev = .; *(.rom.*) _eromdev = .; _sidata = .; &#125; &gt;FLASH 上面的7個 symbol 分別代表開始和結束，例如_smodule代表 module 的開始，而_emodule則代表 module 的結束。 這樣的好處是 symbol 的部分我們可以在主程式這樣使用12345678extern uint32_t _sidata;extern uint32_t _sdata;extern uint32_t _edata;uint32_t *idata_begin = &amp;_sidata; uint32_t *data_begin = &amp;_sdata; uint32_t *data_end = &amp;_edata; while (data_begin &lt; data_end) *data_begin++ = *idata_begin++; 值得注意的是，如果 C 已經有用到該變數_sidata，那就要用PROVIDE(_sdata = .)來避免 linker 出現重複定義的錯誤 Stack 的位址通常 stack 位址我們都會放在 RAM 的最下方讓他往上長，所以我們可以用下面表示方式：1_estack = ORIGIN(RAM) + LENGTH(RAM); 代表 stack 的放置位址是在 RAM 的最下方。 常見問題如果section重複被使用，會發生什麼事？每個輸入檔的 section 只能在出現在 SECTIONS 中出現一次。什麼意思呢？讓我們看個例子 1234SECTIONS &#123;.data : &#123; *(.data) &#125;.data1 : &#123; data.o(.data) &#125;&#125; 我們可以看到data.o中的.data section應該在第一個 OUTPUT-SECTION-COMMAND (也就是.data : { *(.data) })被用掉了，所以在.data1 : { data.o(.data) }將不會再次出現，代表的就是.data1 section會是空的。 如果只想要把某個library的.o放入的話可用*xxx.a:*yyy.o (.bss*)的方式，舉例來說：1234567.bss_RAM2 : ALIGN(4) &#123; *libmytest.a:*.o (.bss*) *(.bss.$RAM2*) *(.bss.$RamLoc64*) . = ALIGN(4) ; &#125; &gt; RamLoc64 如果我不想要把特定檔案的section放入可以使用EXCLUDE_FILE，例如我想放除了 foo.o、bar.o 外，所有的.bss section，可以這麼做： 1(*(EXCLUDE_FILE (*foo.o *bar.o) .bss)) 詳細可參考下方連結 linker script之EXCLUDE_FILE語法 Linker Script: Put a particular file at a later position 參考 ld 官方文件 Linker script 簡介 嵌入式系統建構：開發運作於STM32的韌體程式 Linker Script初探 - GNU Linker Ld手冊略讀 GNU ld的linker script簡介 Rtenv的linker Script解釋 stm32f429 Linker Script簡介]]></content>
      <categories>
        <category>系統程式</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀缺其實是一種陷阱]]></title>
    <url>%2F2018%2F05%2F27%2F%E7%A8%80%E7%BC%BA%E5%85%B6%E5%AF%A6%E6%98%AF%E4%B8%80%E7%A8%AE%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[我們很常聽到這些例子：有人會因為缺錢去借高利貸，結果不得翻身。有些人因為太忙於事業，忽略了家人，到了後來才後悔。雖然很常聽到，但是我們都很難想像這些人為什麼會去做這樣的決策，畢竟理智上告訴我們高利貸是不能去碰觸的，因為利息很可怕、家人比起事業更為重要，要多陪家人。「 稀缺：我們是如何陷入貧窮與忙碌的 」這本書為我們做了解答，故事中的主角都是因為稀缺導致了無法做長遠思考。 稀缺，也是代表了資源有限，所以我們大腦會告訴我們要節省，不要浪費，使用的時候就會再三權衡。這個也是我們演化的機制，像是老祖先可能缺乏食物，就必須要對食物存量極度小心，確保自己的生存。這樣最大好處當然就是我們可以確保稀有資源有被最大化使用。我們在日常生活中其實也有相關經驗，當我們在死線最後一刻，效率會非常高，因為這時時間是稀缺資源，會排除掉其他不重要的事情只專注在當前需要被完成的事，這也就是作者所提到的「專注紅利」。 甚至，這樣的專注力也可以讓我們表現更好。我們知道經濟學總是假設人類是理性的，會跟著需求供給曲線走，但是現實生活卻不是如此，人常常會被感覺所誤導。舉個例子，如果有兩家店有一段距離，我們在A看到20塊錢的東西，但是知道B有賣10元的同樣商品，大多數人願意跑去B買。但是如果現在換成比較貴的就不一樣了，A賣3000，B賣2990，大部分的人寧可在A買一買就好。因為人類有這樣不合理性的行為，所以才有行為經濟學這門學科崛起。這些不合理的概念其實都來自我們對金錢比較沒有實感，我們很難估計省下的10元到底有什麼價值，這點就連經濟學家可能也會犯錯。但是貧窮的人在使用金錢上會更有概念，不會被誤導，因為他們很清楚省下的錢要用來做什麼。我們也可以這麼說，貧窮會讓人更加理性，更接近經濟學裡面理性個體的假設。 儘管稀缺擁有專注的好處，但是它帶來的壞處更多。首先，我們可能會因為過度專注在稀缺資源，所以有了「管窺」現象，只看到自己所關注的，忽略掉其他事情。舉個例子，當我們在忙碌時，可能對其他外界的打擾就會很敏感，甚至脾氣會很差。除了管窺，我們用來處理事情的「帶寬」也變少了，因為心裡心心念念想著稀缺的資源，做其他事情時會很難專心，效率變差。而且因為資源稀少，我們也必須花更多精力去「權衡」怎麼使用資源，作者用行李箱的例子來具體描述這個部分。如果我們行李箱很大，我們可以什麼都不用想，把所有可能用到的東西一股腦塞進去，但是如果行李箱很小，那就必須要仔細思考到底什麼東西會用到，什麼應該用不到。這個「權衡」的行為也是消耗精力(或說帶寬)的主要來源。 因為管窺、帶寬減少、權衡，我們會過度放大眼前的問題，無法好好的考慮未來並且做計畫。這時就很可能出現了「借用」的狀況。我們前面提到的會去借高利貸就是因為貧窮者為了解決眼前的問題，跟未來借錢(未來要還高利貸的利息)，而且因為沒辦法客觀評估未來，所以高估自己未來還錢的能力。不斷地跟未來借用，就會陷入稀缺陷阱中，因為現在的稀缺，導致未來的稀缺，讓人無法逃出這個輪迴。這個就像是我們一天的行事曆每項任務緊接下一項任務，假設第一個事情delay了，就會影響到後面的每個行程，陷入自己需要需要不斷趕下一個行程的輪迴中。 很明顯的，要解決稀缺陷阱的問題，就是要保留餘裕。以前面趕行程的例子，如果我們有留一個緩衝時間，那就能利用緩衝的資源把拖延到的時間補上。但是這個緩衝機制絕對不是在問題發生時才做，我們需要在資源還充足的時候就做好這些規劃。想像你自己已經都很忙了，怎麼可能還能夠想到要留一個緩衝時間呢？除此之外，我們還有其他手段可以應付稀缺陷阱，像是我們可以用預設取代需要主動操作，一次性的任務不要分多次去做、減少自己需要權衡的機會、多個milestone取代單一deadline。這邊我就不細多提了，但是我認為這邊最主要的概念是當自己已經陷入「稀缺」中，我們要減少需要消耗精力去做的事，因為稀缺必然會導致自己去處理其他事情的精力減少，進而增加出錯的機會。一旦出錯，這個就可能會變成下個你要去救火的點。這個概念其實跟之前讀到 精力管理 還蠻像：我們該管理的不是時間，而是精力，因為能讓你把事情做好做滿的是你的精力。減少自己的精力消耗，就可以讓你更能夠專注於處理重要的事情。 本書是2013所出，離現在已經有點時間。我原本也想說書中的概念大概早就過時了，但是沒想到卻出乎意料，讓我重新理解大家常掛在嘴上的「沒錢、沒時間」。了解了稀缺帶給我們的影響，才能知道要怎麼去面對它，避免落入稀缺陷阱，讓自己總是忙於救火。我想，人生在世大概都會遇到某項資源缺少的問題，所以了解「稀缺」應該是我們不得不去面對的課題。]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C語言的行內組譯]]></title>
    <url>%2F2018%2F05%2F20%2FC-Inline-Assembly%2F</url>
    <content type="text"><![CDATA[簡介有時候我們會在C的程式碼內看到asm{...}的結構，這代表的是行內組譯的概念，也就是在C語言中為了效率等目的直接要求compiler加入我們所指定組合語言。 舉個最簡單的範例，如果我們要求加入nop的指令，那就會變成如下： 123456/* 一個nop指令 */asm("nop");/* 多行要用\n隔開 */__asm__("nop\n" "nop\n"); 不管是asm還是__asm__都是合法的，只要不要跟自己的symbol有衝突即可。 聰明的你可能發覺一件事，剛剛的例子只有指令而已，那如果假設我們要跟自己設定的變數互動那要怎麼辦呢？這時候就要用比較複雜的格式 12345asm ( assembler template /* 組合語言內容 */ : output operands /* 輸出的參數 */ : input operands /* 輸入的參數 */ : list of clobbered registers /* 組合語言執行後會改變的項目 */ ); 範例我們還是直接來看看程式比較有感覺 範例一我們寫一個簡單的test.c，只負責做加法。1234567891011#include &lt;stdio.h&gt;int main()&#123; int sum, num1, num2; num1 = 1; num2 = 2; sum = num1 + num2; printf("sum=%d\r\n", sum); return 0;&#125; 編譯並且看一下組語的內容123456789101112131415161718192021222324252627282930313233343536373839$ gcc test.c -s test.s$ cat test.s .file &quot;test.c&quot; .text .section .rodata.LC0: .string &quot;sum=%d\r\n&quot; .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp movl $1, -4(%rbp) movl $2, -8(%rbp) movl -4(%rbp), %edx movl -8(%rbp), %eax addl %edx, %eax movl %eax, -12(%rbp) movl -12(%rbp), %eax movl %eax, %esi movl $.LC0, %edi movl $0, %eax call printf movl $0, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc.LFE0: .size main, .-main .ident &quot;GCC: (GNU) 8.1.0&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 先不管其他細節，可以看到中間有兩行addl %edx, %eax和movl %eax, -12(%rbp)，對應的也就是sum = num1 + num2;，那我們來改寫一下吧！ test.c12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int sum, num1, num2; num1 = 1; num2 = 2; sum = num1 + num2; asm( "addl %%edx, %%eax\n" :"=a"(sum) :"a"(num1), "d"(num2) ); printf("sum=%d\r\n", sum); return 0;&#125; 編譯並執行後就會發現結果是一樣的。不過到這邊我想大部分的人心中一定充滿了三個小朋友，所以還是在稍微解釋一下。 如前面所提，我們最主要執行的是addl %%edx, %%eax\n，這邊跟前面不一樣的是%另有用途(後面會提)，所以要表示暫存器%eax時，我們要用%%來取代%字元。然後第二行的&quot;=a&quot;(sum)中，=代表執行結束後我們要把某個值填到某個變數內(這邊指的就是括號中的sum)，可是某個值又是怎麼決定的呢？這個就是a的概念，也就是「規範條件」，要求編譯器只能對應到符合條件的register。 如果以x86的架構為例(這邊要注意每個CPU架構的規範條件都不同)： 規範條件 Register(s) a %eax, %ax, %al b %ebx, %bx, %bl c %ecx, %cx, %cl d %edx, %dx, %dl S %esi, %si D %edi, %di f fp 由此可知就是要把%eax的結果填入sum中。同理，第三行的input部分&quot;a&quot;(num1), &quot;d&quot;(num2)分別也代表在執行組合語言前為num1和num2選擇register(這邊的例子是num1填入%eax、num2填入%edx)。 回頭看一下如果編成組合語言會是什麼樣子123456789101112131415161718... movl $1, -4(%rbp) movl $2, -8(%rbp) movl -4(%rbp), %eax movl -8(%rbp), %edx#APP# 8 &quot;test.c&quot; 1 addl %edx, %eax# 0 &quot;&quot; 2#NO_APP movl %eax, -12(%rbp) movl -12(%rbp), %eax movl %eax, %esi movl $.LC0, %edi movl $0, %eax call printf.... 在#APP和#NO_APP間就是我們的組語部分，看起來蠻符合我們的預期。 範例二可是我們難道都一定要自行決定register嗎？我們想要交由compiler決定。這時候其實可以用比較寬鬆的限制條件。一樣是x86的架構才能用： 規範條件 Register(s) r %eax, %ebx, %ecx, %edx, %esi, %edi q %eax, %ebx, %ecx, %edx 0,1,2.. %0, %1, %2…(代表第幾個參數) 那就修改程式吧！ test.c1234567... asm( "addl %2, %0\n" :"=r"(sum) :"0"(num1), "r"(num2) );... 在這裡，我們input使用sum和num2使用r，代表交由compiler決定要用哪個register。但是num1為什麼是0呢？這個意思是我們要num1的值所放入的register要跟sum同樣。0,1,2分別代表我們所決定的register順序，也就是%0=&gt;之後要輸出到sum的register，%1=&gt;num1放入的register，%2=&gt;num2放入的register。 當然最後執行結果也會和範例一一樣。 參考 BINARY HACKS：駭客秘傳技巧一百招 在 C 語言當中內嵌 GNU 的組合語言 關於GNU Inline Assembly ARM GCC Inline Assembler Cookbook GCC-Inline-Assembly-HOWTO]]></content>
      <categories>
        <category>程式語言</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 openssl 工具與函式庫]]></title>
    <url>%2F2018%2F05%2F13%2Fopenssl-library-example%2F</url>
    <content type="text"><![CDATA[安裝opensslMAC1$ brew install openssl MAC上如果要使用library有點麻煩，需要先找到對應的路徑12345678$ find /usr/local/Cellar/ -name &quot;libssl.*&quot; # 找到library的路徑/usr/local/Cellar//openssl/1.0.2o_1/lib/pkgconfig/libssl.pc/usr/local/Cellar//openssl/1.0.2o_1/lib/libssl.dylib...$ find /usr/local/Cellar/ -name &quot;ssl.h&quot; # 找到header的路徑/usr/local/Cellar//node/8.4.0/include/node/openssl/ssl.h/usr/local/Cellar//openssl/1.0.2o_1/include/openssl/ssl.h... 看起來路徑是在/usr/local/Cellar/openssl/1.0.2o_1/我們先記起來，後面編譯時會用到。 創造憑證openssl本身就有提供很多好用的工具，我們最常用到的大概就是用來產生憑證吧！ 這邊介紹產生兩種常見憑證(RSA,ECC)的方法。 產生RSA憑證123456# 產生2048長度的key$ openssl genrsa -out server.key 2048# 用key產生CSR，指定用sha384簽CSR$ openssl req -new -sha384 -key server.key -out server.csr# 產生自簽名證書$ openssl x509 -req -sha1 -days 3650 -signkey server.key -in server.csr -out server.crt 產生ECC憑證123456# 產生ECC key$ openssl ecparam -genkey -name secp384r1 -out ecc.key# 用key產生CSR，指定用sha384簽CSR$ openssl req -new -sha384 -key ecc.key -out ecc.csr# 產生自簽名證書$ openssl x509 -req -sha1 -days 3650 -signkey ecc.key -in ecc.csr -out ecc.crt 使用openssl內建的連線工具有時候我們只是想要測試ssl連線而已，還要自己寫程式有點麻煩，還好我們可以使用openssl提供的連線工具 client和server都有提供，非常方便的！ client -msg：看細節(hex格式) -cipher：決定要用哪種cipher連線 -showcerts：把cert的chain也列出來 -curves：指定要用的橢圓算法，client hello的extension中的elliptic_curves -sigalgs：指定交換key要用的簽名方式，client hello的extension中的signature_algorithms -no_tls1 -no_ssl3：加上後就可以只用tls1.2連線了12345678# 最基本連線$ openssl s_client -connect [IP]:[port]# 看連線細節$ openssl s_client -msg -connect [IP]:[port]# 指定連線方式$ openssl s_client -connect sslanalyzer.comodoca.com:443 -cipher ECDHE-RSA-AES128-GCM-SHA256 -curves secp384r1 -sigals RSA+SHA512# 限制只能用TLS1.2連線$ openssl s_client -no_tls1 -no_ssl3 -connect [IP]:[port] server12# server開啟5678 port並且用server.key當private key，cert用server.pem$ openssl s_server -accept 5678 -key server.key -cert server.pem 其他12# 如果要看有哪些連線方式，可使用如下指令$ openssl ciphers ALL 函式庫使用我們來介紹openssl的函式庫最基本的使用方式。 基本範例 - client &amp; server這邊寫了兩個client和server的基本範例當作參考，大家可以基於這兩者來拓展自己的程式。 程式碼ssl_client.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;openssl/ssl.h&gt;#define RECV_SIZE 256SSL_CTX *create_sslcontext()&#123; const SSL_METHOD *method; SSL_CTX *ctx; // Support only TLSv1.2 method = TLSv1_2_client_method(); // Create context ctx = SSL_CTX_new(method); if (!ctx) return NULL; return ctx;&#125;int create_socket(char *ip, int port)&#123; int fd; struct sockaddr_in addr; // New socket if ((fd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0 ) return -1; // TCP connect to server memset(&amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = inet_addr(ip); if (connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) return -1; return fd;&#125;// Usage: ./ssl_client.out [IP] [port]int main(int argc, char *argv[])&#123; int fd; SSL_CTX *ctx; int port; int len; SSL *ssl; char buf[RECV_SIZE]; if (argc != 3) return -1; // Parse parameter port = atoi(argv[2]); printf("Connect to %s:%d\n", argv[1], port); // SSL init OpenSSL_add_ssl_algorithms(); // Create SSL_CTX if ((ctx = create_sslcontext()) == NULL) return -1; // Create socket if ((fd = create_socket(argv[1], port)) &lt; 0) return -1; // Start to build ssl connection ssl = SSL_new(ctx); SSL_set_fd(ssl, fd); if (SSL_connect(ssl) &lt;= 0) return -1; // SSL write/read do &#123; printf("Write data to server (q for quit): "); memset(buf, 0, sizeof(buf)); gets(buf); if (strcmp("q", buf) == 0) break; if (SSL_write(ssl, buf, strlen(buf)) &lt; 0) break; memset(buf, 0, sizeof(buf)); len = SSL_read(ssl, buf, RECV_SIZE); if (len &lt; 0) break; else printf("Recv %d bytes: %s\n", len, buf); &#125; while(1); // SSL close SSL_shutdown(ssl); // Free resource SSL_free(ssl); close(fd); SSL_CTX_free(ctx); EVP_cleanup(); return 0;&#125; ssl_server.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;openssl/ssl.h&gt;#define SSL_CERT "server.crt"#define SSL_KEY "server.key" #define BUF_LEN 256SSL_CTX *create_sslcontext()&#123; const SSL_METHOD *method; SSL_CTX *ctx; // Support only TLSv1.2 method = TLSv1_2_server_method(); // Create context ctx = SSL_CTX_new(method); if (!ctx) return NULL; return ctx;&#125;int configure_sslcertkey_file(SSL_CTX *ctx)&#123; SSL_CTX_set_ecdh_auto(ctx, 1); // Load certificate file if (SSL_CTX_use_certificate_file(ctx, SSL_CERT, SSL_FILETYPE_PEM) &lt;= 0) return -1; // Load private key file if (SSL_CTX_use_PrivateKey_file(ctx, SSL_KEY, SSL_FILETYPE_PEM) &lt;= 0 ) return -1; return 0;&#125;int create_socket(int port)&#123; int fd; struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); if ((fd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0 ) return -1; if (bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)) &lt; 0) return -1; if (listen(fd, 1) &lt; 0) return -1; return fd;&#125;// Usage: ./ssl_server.out [port]int main(int argc, char *argv[])&#123; int server_fd, client_fd; SSL_CTX *ctx; SSL *ssl; struct sockaddr_in addr; uint len = sizeof(addr); int port; char buf[BUF_LEN]; if (argc != 2) return -1; port = atoi(argv[1]); printf("Listen port: %d\n", port); // SSL init OpenSSL_add_ssl_algorithms(); // Create SSL_CTX if ((ctx = create_sslcontext()) == NULL) return -1; // Configure cert and key if (configure_sslcertkey_file(ctx) &lt; 0) return -1; // Create socket if ((server_fd = create_socket(port)) &lt; 0) return -1; // Accept connection if ((client_fd = accept(server_fd, (struct sockaddr*)&amp;addr, &amp;len)) &lt; 0) return -1; // Build SSL connection ssl = SSL_new(ctx); SSL_set_fd(ssl, client_fd); if (SSL_accept(ssl) &lt;= 0) return -1; // SSL read/write while(1) &#123; memset(buf, 0, sizeof(buf)); len = SSL_read(ssl, buf, BUF_LEN); if (len &lt;= 0) break; else SSL_write(ssl, buf, strlen(buf)); &#125; // Close client SSL_free(ssl); close(client_fd); // Close server and relase resource close(server_fd); SSL_CTX_free(ctx); EVP_cleanup(); return 0;&#125; 編譯與執行接下來寫個簡單的Makefile，這時候就要用到前面所找到的路徑了。12345678910111213141516SSL_PATH=/usr/local/Cellar/openssl/1.0.2o_1/CFLAGS=-I$(SSL_PATH)include -L$(SSL_PATH)lib/ -lcrypto -lsslCC=gccBIN=ssl_server ssl_clientall: $(BIN)ssl_server: ssl_server.c $(CC) $^ -o $@.out $(CFLAGS)ssl_client: ssl_client.c $(CC) $^ -o $@.out $(CFLAGS)clean: -rm *.o -rm *.out 這邊要特別記住-lcrypto -lssl要放最後面，不然有些平台會有error 然後就可以執行看看了123$ make$ ./ssl_server 2222Listen port: 2222 這時候另一邊再來執行client1234./ssl_client.out 127.0.0.1 2222Connect to 127.0.0.1:2222Write data to server (q for quit): abcdRecv 4 bytes: abcd 可以順利收送資料了！ 參考 How to link OpenSSL library in macOS using gcc? Simple TLS Server]]></content>
      <categories>
        <category>protocol</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[淺談函式庫]]></title>
    <url>%2F2018%2F05%2F12%2F%E6%B7%BA%E8%AB%87%E5%87%BD%E5%BC%8F%E5%BA%AB%2F</url>
    <content type="text"><![CDATA[比較shared/static library程式在執行的時候，大部分都會需要引用函式庫(library)，library有分shared和static，兩者代表不同的引用方式。 static library shared library 優點 不需要考慮執行環境的相依性問題 使用空間小(檔案和記憶體)、更換library不用重build 缺點 執行檔極大、更換library需重build 在異地執行可能會因為相依性無法執行 動態函式庫在開始前，先確定幾個名詞 soname：代表特定library的名稱，如libmylib.so.1，最後面的1是version real name：實際放有library程式的檔案名稱，名稱會包含三個版號，分別為version, minor和release，如libmylib.so.1.0.0 version代表原介面有移除或改變，與舊版本不相容 minor代表新增介面，舊介面沒改 release代表程式修正，介面沒改 linker name：用於連結時的名稱，不含版號的soname，如libmylib。通常會link到實際的real name。 如何編譯首先我們先把.c編譯成.o，這邊要加上-fPIC的參數 這個原因是要產生Position Independent code，確保code segment在動態連結時不用花時間重新定位，而且重新定位會造成無法和其他process共享.text區段。 事實上，如果不加-fPIC也是可以產生library，但是產生的執行檔就需要另外存有重新定位的資訊(.rel.dyn區段)，而且會有上述的問題。1$ gcc -c -fPIC hello.c world.c 接下來就是產生shared library了，解釋一下參數的意思 -shared：代表要編成shared library -Wl：是用來傳遞參數給linker，讓-soname和libmylib.so.1傳給linker處理 -soname：用來指名soname為libmylib.so.1 -o：最後library會被輸出成libmylib.so.1.0.01$ gcc -shared -Wl,-soname,libmylib.so.1 -o libmylib.so.1.0.0 hello.o world.o soname很重要，就如同前面所提，可以讓開發者和應用程式表示兼容標準，可以用objdump確認soname12$ objdump -p libmylib.so.1.0.0 | grep SONAME SONAME libmylib.so.1 完成後再用ln建立soname和linker name兩個檔案12$ ln -s libmylib.so.1.0.0 libmylib.so$ ln -s libmylib.so.1.0.0 libmylib.so.1 如何使用如果有人要使用的話，下列兩種方式都可以。不過要注意目錄下如果同時有static和shared會使用shared為主，如果要static就要加上-static編靜態函式庫12$ gcc main.c libmylib.so -o a.out$ gcc main.c -L. -lmylib -o a.out 但是shared library執行的時候還是需要有library才能執行，所以要把.so安裝到系統中，有三種方法： 把libmylib.so.1 放到系統常見的library目錄，如/lib, /usr/lib 設定/etc/ld.so.conf ，加入一個新的library搜尋目錄，並執行ldconfig更新/etc/ld.so.cache 設定LD_LIBRARY_PATH 環境變數來搜尋library，如LD_LIBRARY_PATH=. ./a.out 這邊提一下一般而言找library的順序 LD_LIBRARY_PATH或LD_AOUT_LIBRARY_PATH環境變數所指的路徑 從ld.so.cache的記錄來找shared library。 /lib,/usr/lib內的檔案 查看shared library的關係 - ldd我們要怎麼知道某個執行檔有使用到哪些library呢？這時候就要用到ldd這個指令了。 ldd其實是一個shell script，它會把檔案所用到library一一列出，包括library會用到的library。 舉例來說，如果我們不用ldd，其實是可以從ELF的Dynamic Section獲得shared library資訊12345678$ readelf -d /bin/catDynamic section at offset 0x7dd8 contains 26 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000c (INIT) 0x15e8 0x000000000000000d (FINI) 0x5a4c... 我們看到NEEDED就是需要的dynamic library，但是這個library可能也需要其他library。12345678$ readelf -d /lib/x86_64-linux-gnu/libc.so.6Dynamic section at offset 0x198ba0 contains 26 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [ld-linux-x86-64.so.2] 0x000000000000000e (SONAME) Library soname: [libc.so.6] 0x000000000000000c (INIT) 0x20050... 因此我們知道/bin/cat需要libc.so.6，而libc.so.6還需要ld-linux-x86-64.so.2。這樣尋找實在太麻煩了，其實我們可以直接用ldd1234$ ldd /bin/cat linux-vdso.so.1 (0x00007fff8613c000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f654a3bf000) /lib64/ld-linux-x86-64.so.2 (0x00007f654a967000) 看，是不是很輕鬆呢？ 靜態函式庫會有static library的概念是，如果我有很多.o檔，那每次要引用其實都不是很方便，所以最好的方法還是可以打包起來，也就是使用ar指令。 如何編譯static libary建立方式很簡單，一樣要先建立.o1$ gcc -c test1.c test2.c 接下來開始打包，參數意義如下 r：代表加入新檔案或取代現有檔案 c：.a檔不存在時不會跳錯誤訊息 u：根據timestamp保留檔案 s：建立索引，加快連結速度1$ ar rcs libtest.a test1.o test2.o 如果要顯示函式庫 libstack.a 的內容123$ ar -tv libtest.arw-r--r-- 0/0 1464 Jan 1 00:00 1970 test1.orw-r--r-- 0/0 1464 Jan 1 00:00 1970 test2.o 如果要從libtest.a中取出test1.o1ar -x libtest.a test1.o 如何使用編譯方法一樣很簡單，有兩種123gcc main.c libtest.a# 也可以使用gcc的-l，-L代表要搜尋的目錄位置，-l會捨去library的lib開頭gcc main.c -L. -ltest symbol衝突假設我們在創建library時遇到symbol衝突會發生什麼事呢？這邊我們分三種情況探討 首先先創三個檔案 hello.c1234void test()&#123; printf("hello\n");&#125; world.c1234void test()&#123; printf("world\n");&#125; main.c123456void test();int main()&#123; test(); return 0;&#125; shared library連結時，object file有衝突嘗試編譯與連結123456$ gcc -c -fPIC hello.c world.c$ gcc -shared -o libmylib.so hello.o world.oworld.o: In function `test&apos;:world.c:(.text+0x0): multiple definition of `test&apos;hello.o:hello.c:(.text+0x0): first defined herecollect2: error: ld returned 1 exit status 會發現出現錯誤，原因是動態連結跟一般編譯一樣會檢查symbol是否重複 static library打包時，object file有衝突那如果是用static library呢？12345$ gcc -c hello.c world.c$ ar crs libhello.a hello.o$ ar crs libworld.a world.o$ gcc -o main.out main.c libhello.a libworld.ahello 發現居然沒事，這個原因是因為ar只有打包功能不負責檢查。可是問題來了，到底是執行哪個呢？答案是看順序。123456$ gcc -o main.out main.c libhello.a libworld.a$ ./main.outhello$ gcc -o main.out main.c libworld.a libhello.a $ ./main.outworld 使用shared library時，不同library有衝突那如果是兩個shared library彼此間有函數衝突的現象呢？123$ gcc -fPIC -shared -o libhello.so hello.c$ gcc -fPIC -shared -o libworld.so world.c$ gcc -o main.out libhello.so libworld.so main.c 結果一樣沒有錯誤，原因是在動態連結時會使用最先看到的symbol，所以順序不同就有不同結果123456$ gcc -o main.out libhello.so libworld.so main.c $ LD_LIBRARY_PATH=. ./main.outhello$ gcc -o main.out libworld.so libhello.so main.c $ LD_LIBRARY_PATH=. ./main.outworld 這個特性也跟LD_PRELOAD有關，我們可以用LD_PRELOAD來抽換shared library就是因為連結時會先使用先看到的symbol。當然這也曾經造成了一些危害，例如goahead的CVE-2017-17562。 執行中載入library除了執行開始時載入library外，我們也可以用程式來載入12345678910// 動態載入所需的header#include &lt;dlfcn.h&gt;// 載入指定libraryvoid *dlopen(const char *filename, int flag);// 透過symbol name取得symbol在library的記憶體位址void *dlsym(void *handle, const char *symbol);// 關閉dlopen開啟的handlerint dlclose(void *handle);// 傳回錯誤訊息。char *dlerror(void); 範例：dltest.c1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;int main() &#123; void *handle; void (*f)(); char *error; /* 開啟之前所撰寫的libmylib.so 程式庫 */ handle = dlopen("./libmylib.so", RTLD_LAZY); if( !handle ) &#123; fputs( dlerror(), stderr); exit(1); &#125; /* 取得hello function 的address */ f = dlsym(handle, "hello"); if(( error=dlerror())!=NULL) &#123; fputs(error, stderr); exit(1); &#125; /* 呼叫function */ f(); /* 結束handler */ dlclose(handle); return 0;&#125; 記得編譯時要連結dl library12$ gcc dltest.c -ldl$ LD_LIBRARY_PATH=. ./a.out library公開symbols管理有時候我們並不希望所提供的library會把所有symbol都洩漏出去，這時候大部分的人都會使用static限制外部呼叫。但是當這個函式在library中其他檔案會引用到，那就沒辦法設為static了。 那該怎麼辦呢？這邊有兩個方法： 使用 version script首先我們先創兩個檔案當範例 test.c1234void test()&#123; printf("test\n");&#125; func.c123456void test();void func()&#123; printf("func\n"); test();&#125; 然後我們編成shared library，並且看看symbol123456$ gcc -fPIC -c test.c func.c$ gcc -shared -o libmylib.so test.o func.o$ nm -D libmylib.so | grep -v &apos;_&apos; # -D 代表顯示dynmaic部分，-v 代表反向選擇00000000000005e8 T func U puts00000000000005d5 T test 可以看到test還是被暴露出來了，但是明明test應該只想要在library中被使用而已。 這時候我們可以試試GNU linker的version script。libmylib.map1234&#123; global: func; local: *;&#125;; 這個意思是只要顯示func，其他function都要隱藏。然後我們link的時候加上version script試看看：1234$ gcc -shared -o libmylib.so test.o func.o -Wl,--version-script,libmylib.map$ nm -D libmylib.so | grep -v &apos;_&apos;00000000000004e8 T func U puts 成功隱藏test了！ 使用attribute語法除了使用version script以外，也可以用gcc特有的語法，__attribute__((visibility(&quot;default&quot;))) 首先我們先改寫要公開的函式，代表我們只要暴露func()給外界看到 func.c123456void test();__attribute__((visibility("default"))) void func()&#123; printf("func\n"); test();&#125; 然後在編譯成.o時要記得加上-fvisibility=hidden，把其他function都隱藏起來。12345$ gcc -c -fPIC test.c func.c -fvisibility=hidden$ gcc -shared -o libmylib.so test.o func.o$ nm -D libmylib.so | grep -v &apos;_&apos;00000000000005a8 T func U puts 達到的效果和version script一樣！ 用version script控制版本這邊我們再多談談version script其他的用法，其實他除了管理要暴露出來的symbol外，我們也可以依照版本控制library要暴露出來的function。 首先我們先出第一版程式libtest.c12345#include &lt;stdio.h&gt;void func(int num)&#123; printf("num=%d\n", num);&#125; libtest1.h1void func(int num); version1.c1234567#include &lt;stdio.h&gt;#include "libtest1.h"int main()&#123; func(1); return 0;&#125; 然後正常編譯執行12345$ gcc -fPIC -c libtest.c$ gcc -shared -o libtest.so libtest.o$ gcc -L. -ltest -o version1.out version1.c$ LD_LIBRARY_PATH=. ./version1.outnum=1 很順利正常執行，那我們假設現在要出第二個版本可以怎麼做 libtest2.c123456789101112#include &lt;stdio.h&gt;void func_1(int num)&#123; printf("num=%d\n", num);&#125;void func_2(int num1, int num2)&#123; printf("num1=%d, num2=%d\n", num1, num2);&#125;__asm__(".symver func_1,func@LIBTEST_1.0");__asm__(".symver func_2,func@@LIBTEST_2.0"); 稍微解釋一下，首先先實作兩個function，然後再用後面兩個__asm__的symver來把同樣symbol加上版號，至於第二行@@的意思代表為預設版本。 接下來的部分就一樣撰寫新的程式 libtest2.h1void func(int num1, int num2); version2.c1234567#include &lt;stdio.h&gt;#include "libtest2.h"int main()&#123; func(1,2); return 0;&#125; 然後這時候就要出動version script了 libtest2.map1234567LIBTEST_1.0 &#123; global: func; local: *;&#125;;LIBTEST_2.0 &#123; global: func;&#125;LIBTEST_1.0; 然後我們編譯並執行看看1234567$ gcc -fPIC -c libtest2.c$ gcc -shared -o libtest.so libtest2.o -Wl,--version-script,libtest2.map$ gcc -L. -ltest -o version2.out version2.c$ LD_LIBRARY_PATH=. ./version1.outnum=1$ LD_LIBRARY_PATH=. ./version2.outnum1=1, num2=2 可以看到兩者執行結果不同，為什麼會這樣呢？我們先看一下他們連結到的symbol12345678$ readelf -a version1.out | grep func000000601018 000500000007 R_X86_64_JUMP_SLO 0000000000000000 func + 0 5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND func 51: 0000000000000000 0 FUNC GLOBAL DEFAULT UND func＄ readelf -a version2.out | grep func000000601018 000100000007 R_X86_64_JUMP_SLO 0000000000000000 func@LIBTEST_2.0 + 0 1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND func@LIBTEST_2.0 (2) 46: 0000000000000000 0 FUNC GLOBAL DEFAULT UND func@@LIBTEST_2.0 可以看到version1.out是使用func，而version2.out的symbol就是func@@LIBTEST_2.0。那同樣是引用相同library，到底是怎麼知道要呼叫哪個func呢？在呼叫func的情況下，會自動找到最初的版本也就是func@LIBTEST_1.0。而之後的程式編譯時link library則會去找default的版本，也就是有兩個@的func@@LIBTEST_2.0，所以就不會有搞混的情況發生了。 這個方法在要維持兼容性的情況下非常好用，可以在不影響舊版的情況下改變函式規格。 參考 BINARY HACKS：駭客秘傳技巧一百招]]></content>
      <categories>
        <category>系統程式</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker 簡易教學]]></title>
    <url>%2F2018%2F05%2F12%2Fdocker-%E7%B0%A1%E6%98%93%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[InstallationMAC 安裝以前安裝時需要安裝docker和boot2docker，但現在只要到官網下載DOCKER COMMUNITY EDITION (CE)就可以了。 boot2docker是MAC下輕量的Linux VM，專門用來執行docker daemon 然後以前使用都會用kitematic這個GUI的操作介面，現在docker官方也已經整進去了，我們可以直接透過docker的應用程式下載kitematic(在上方工具列的選項裡) 安裝詳細流程可以參考如何在 macOS 上安裝 Docker CE，寫得非常清楚。 ubuntuUbuntu的安裝方式也跟以前不一樣了，可參考官網的作法，Get Docker CE for Ubuntu WindowsWindows的安裝教學連結在此，值得注意的是只有Windows10才有支援Hyper-V，如果是其他版本就必須要安裝使用Virtualbox的Docker Toolbox來取代了。 常用指令可以用一張圖職階概括大部分常用docker的指令，圖片來自Docker —— 從入門到實踐 附錄一：命令查詢 images 尋找images 1docker search XXX 把images抓下來 1docker pull XXX 看目前有哪些images 1docker images 刪除某images 1docker rmi XXX container 看目前有哪些container正在跑 1docker ps 看包括所有停止的container 1docker ps -a 讓某個container開始/停止 1docker start/stop XXX 刪除某container 1docker rm XXX 看某個container資訊 1docker inspect XXX RUN執行部分其實可以加上很多參數： -d: 代表以daemon執行(背景執行) -p port:port: 代表port映射，例如-p 8080:80就是把 port 8080 對應到image的 port 80 -v dir:dir: 代表映射目錄，例如-v /home/share:/var/www:rw就是把/home/share對應到image的/var/www，且權限為rw。路徑需要為絕對路徑。 --rm：當有container存在時自動移除 -i：互動模式 -t：允許TTY -w path：設定進入container的工作路徑 -e key=value：帶入環境變數 跑images 12docker run --rm -i -t -p 8080:80 nginxdocker run -i -t ubuntu /bin/bash 背景執行 1docker run -d -p 8080:80 -v shared_dir:/var/www:rw nginx COMMIT 看有甚麼改變 1docker diff XXX 提交成新的images 1docker commit -m="註解" -a="author" XXX repo_name 看歷史 1docker history XXX Dockerfile我們也可以用Dockerfile產生image，可參考使用Dockerfile建置 下面是個範例123456789101112# base imageFROM ubuntu:14.04# 執行的commandRUN apt-get updateRUN apt-get install -y nginx# 要開的port，注意在run的時候還是要加上-p才能真正讓外部連接該portEXPOSE 80# 環境變數ENV PATH $PATH:/home/bin 建立image1docker build -t repo_name:tag_name . 範例看完command可能還是不清楚怎麼用，這邊用安裝nginx的docker image來說明 取得image首先我們先搜尋nginx123456$ docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 8564 [OK]jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1331 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 547.... 我們先抓officical的images12345678$ docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxf2aa67a397c4: Pull complete3c091c23e29d: Pull complete4a99993b8636: Pull completeDigest: sha256:0fb320e2a1b1620b4905facb3447e3d84ad36da0b2c8aa8fe3a5a81d1187b884Status: Downloaded newer image for nginx:latest 現在local端就有nginx的image了123$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest ae513a47849c 11 days ago 109MB 運行container開始運行container，並且讓port 8080對應到nginx container的port 80，工作路徑為/home，然後執行bash1$ docker run --rm -i -t -p 8080:80 -w /home nginx bash 我們也可以選擇背景執行，並且把shared_dir對應到/var/www1$ docker run -d -p 8080:80 -v shared_dir:/var/www:rw nginx 一定有人會問這樣的情況下怎麼控制bash呢？我們可以用exec command1$ docker exec -i -t 78fc bash 操作運行中的container看一下當前有的container1234567891011$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe2cf9ea13bb4 nginx &quot;nginx -g &apos;daemon of…&quot; 2 minutes ago Up 2 minutes 0.0.0.0:8080-&gt;80/tcp priceless_murdock$ docker inspect e2cf9ea13bb4[ &#123; &quot;Id&quot;: &quot;e2cf9ea13bb477e49f1c0ff75a683555d1a75ef953529087375c83ee1a88b65f&quot;, &quot;Created&quot;: &quot;2018-05-12T06:17:14.979076095Z&quot;, &quot;Path&quot;: &quot;nginx&quot;, &quot;Args&quot;: [... 我們可以隨時中斷或啟動該container12$ docker stop e2cf9ea13bb4$ docker start e2cf9ea13bb4 提交改變成為新的image看看該container有什麼改變1234567891011$ docker diff e2cf9ea13bb4C /runA /run/nginx.pidC /varC /var/cache/nginxA /var/cache/nginx/client_tempA /var/cache/nginx/fastcgi_tempA /var/cache/nginx/proxy_tempA /var/cache/nginx/scgi_tempA /var/cache/nginx/uwsgi_tempA /var/www commit我們所做的改變變成新的image123456$ docker commit -m &quot;New nginx&quot; -a &quot;evshary&quot; e2cf new_nginxsha256:ed66214b3e3a510a7cc47e341f64f6596560164d6f06a22f93dca8d05ecac081$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnew_nginx latest ed66214b3e3a 17 seconds ago 109MBnginx latest ae513a47849c 11 days ago 109MB 可以從history看我們所做改變歷史12345$ docker history new_nginxIMAGE CREATED CREATED BY SIZE COMMENTed66214b3e3a About a minute ago nginx -g daemon off; 2B New nginxae513a47849c 11 days ago /bin/sh -c #(nop) CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon… 0B&lt;missing&gt; 11 days ago /bin/sh -c #(nop) STOPSIGNAL [SIGTERM] 0B 刪除container/images玩膩了，可以刪除images，記得要先刪掉container才行刪images喔123456789$ docker rm e2cf9ea13bb4$ docker rmi new_nginxUntagged: new_nginx:latestDeleted: sha256:ed66214b3e3a510a7cc47e341f64f6596560164d6f06a22f93dca8d05ecac081$ docker rmi nginxDeleted: sha256:ae513a47849c895a155ddfb868d6ba247f60240ec8495482eca74c4a2c13a881Deleted: sha256:160a8bd939a9421818f499ba4fbfaca3dd5c86ad7a6b97b6889149fd39bd91ddDeleted: sha256:f246685cc80c2faa655ba1ec9f0a35d44e52b6f83863dc16f46c5bca149bfefcDeleted: sha256:d626a8ad97a1f9c1f2c4db3814751ada64f60aed927764a3f994fcd88363b659 參考 Docker —— 從入門到實踐 Docker學習筆記]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[關於ELF的兩三事]]></title>
    <url>%2F2018%2F05%2F06%2FELF-format%2F</url>
    <content type="text"><![CDATA[簡介程式設計師很大的機率是脫離不了Linux，而如果我們要在Linux上compile，大概一定會接觸到ELF這個格式。底下來簡單介紹一下ELF的格式是什麼，我們要怎麼從它獲得資訊。 ELF全名是Executable and Linking Format，在Linux中是編譯後的binary、object檔規範，也就是說我們從source code編譯後產生的檔案格式就是ELF了。 ELF的格式可以從兩種角度來看，第一種是Link的時候，第二種是執行的時候。兩者都一樣會有ELF header，但是底下的組成概念就完全不一樣。 Link的時候： ELF header Program Header Table(Optional) Section 1 Section 2 … Section N Section Header Table 執行的時候： ELF header Program Header Table Segment 1 Segment 2 … Segment N Section Header Table(Optional) 兩者最大的差異是Link的時候是以Section為觀點，用Section Header Table來當索引，指向各個Section。執行的時候則是用Segment為觀點，一個Segment可能是多個Section所組成，然後再用Program Header Table指向各個Segment。 觀察ELF的方法那要如何觀察ELF呢？如果你嘗試用記事本打開應該只會看到一團不知所云的亂碼，所以我們底下會透過各種工具的使用教學來解釋ELF格式。 查看執行檔 - od首先我們可以試著使用od這個指令來看檔案內容。od全名是octal dump，顧名思義就是用八進制來印內容，但他並不僅僅如此而已。 od指令的格式：od -t [顯示格式] -A [偏移量使用的基數] [filename] -t：後面可接型態(d, o, x…)、一次顯示的byte數(數字)、是否顯示ASCII code(z) -A：偏移量有(d, o, x, n)，n代表不顯示偏移量 -v：不省略重複的內容 我們最常用格式： od -t x1 -A x [filename]：代表用16進制來顯示檔案，偏移量是16的倍數 od -t x1z -A x [filename]：同上，但是多加上顯示ASCII code 那我們來看看ELF檔長什麼樣子，這邊以大家最常用的ls為例12345$ od -t x1z -A x /bin/ls | less000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 &gt;.ELF............&lt;000010 02 00 3e 00 01 00 00 00 90 48 40 00 00 00 00 00 &gt;..&gt;......H@.....&lt;000020 40 00 00 00 00 00 00 00 00 a7 01 00 00 00 00 00 &gt;@...............&lt;.... 可以看到前面有個7f 45 4c 46開頭，ASCII是.ELF(.代表非可見字元，這邊是0x7f也就是\177)，這個就是傳說中的ELF magic code了。不過這邊先停一下，如果我們要繼續用hex來看其實有點累，所以先換個工具來試試吧！ 使用readelf來觀察ELF資訊readelf很明顯就是觀察ELF檔案的專門工具，使用方式如下 格式：readelf [選項] [filename] 讀取標頭選項 -h：印 ELF header -l：印 Program Header Table -S：印 Section Header Table -e：三者都印 讀取資訊選項 -s：符號表 -r：重定位資訊 特別用法： -a：所有標頭資訊全部印出 -xn：先用-S看要查看的Section數字，然後n填上該數字就可以hexdump那個section 那我們來看看ls的ELF header長什麼樣。從下面可以看到，除了剛剛看到的Magic code外，還有版本、適用哪個OS/ABI、在哪個機器平台運行、entry point adddress等等。 值得注意的是這邊有紀錄Program Header、Section Header的開始位址、大小、數量，所以我們可以用這個資訊找到Program/Section Header。123456789101112131415161718192021$ readelf -h /bin/lsELF 檔頭： 魔術位元組： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 類別: ELF64 資料: 2 的補數，小尾序(little endian) 版本: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 類型: EXEC (可執行檔案) 系統架構: Advanced Micro Devices X86-64 版本: 0x1 進入點位址： 0x404890 程式標頭起點： 64 (檔案內之位元組) 區段標頭起點： 108288 (檔案內之位元組) 旗標： 0x0 此標頭的大小： 64 (位元組) 程式標頭大小： 56 (位元組) Number of program headers: 9 區段標頭大小： 64 (位元組) 區段標頭數量： 28 字串表索引區段標頭： 27 而Program Header的部分，我們可以看到有9個Segement，以及實際的位址在哪。另外有個「區段到節區映射中」(Section to Segment mapping)，這就是多個Section如何組成一個Segment的對應。 123456789101112131415161718192021222324252627282930313233343536373839$ readelf -l /bin/lsElf 檔案類型為 EXEC (可執行檔案)進入點 0x404890共有 9 個程式標頭，開始於偏移量 64程式標頭： 類型 偏移量 虛擬位址 實體位址 檔案大小 記憶大小 旗標 對齊 PHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040 0x00000000000001f8 0x00000000000001f8 R E 8 INTERP 0x0000000000000238 0x0000000000400238 0x0000000000400238 0x000000000000001c 0x000000000000001c R 1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000019d44 0x0000000000019d44 R E 200000 LOAD 0x0000000000019df0 0x0000000000619df0 0x0000000000619df0 0x0000000000000804 0x0000000000001570 RW 200000 DYNAMIC 0x0000000000019e08 0x0000000000619e08 0x0000000000619e08 0x00000000000001f0 0x00000000000001f0 RW 8 NOTE 0x0000000000000254 0x0000000000400254 0x0000000000400254 0x0000000000000044 0x0000000000000044 R 4 GNU_EH_FRAME 0x000000000001701c 0x000000000041701c 0x000000000041701c 0x000000000000072c 0x000000000000072c R 4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 10 GNU_RELRO 0x0000000000019df0 0x0000000000619df0 0x0000000000619df0 0x0000000000000210 0x0000000000000210 R 1 區段到節區映射中: 節區段... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gn u.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_ frame_hdr .eh_frame 03 .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .jcr .dynamic .got Section Header的話會仔細列出這個ELF所包含的所有Section以及位址。 123456789101112131415161718192021222324252627282930$ readelf -S /bin/ls共有 28 個區段標頭，從偏移量 0x1a700 開始：區段標頭： [號] 名稱 類型 位址 偏移量 大小 全體大小 旗標 連結 資訊 對齊 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000400238 00000238 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 00000254 0000000000000020 0000000000000000 A 0 0 4 [ 3] .note.gnu.build-i NOTE 0000000000400274 00000274 0000000000000024 0000000000000000 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000400298 00000298 0000000000000068 0000000000000000 A 5 0 8... [24] .data PROGBITS 000000000061a3a0 0001a3a0 0000000000000254 0000000000000000 WA 0 0 32 [25] .bss NOBITS 000000000061a600 0001a5f4 0000000000000d60 0000000000000000 WA 0 0 32 [26] .gnu_debuglink PROGBITS 0000000000000000 0001a5f4 0000000000000008 0000000000000000 0 0 1 [27] .shstrtab STRTAB 0000000000000000 0001a5fc 00000000000000fe 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) objdump取得ELF內容除了看ELF內的資訊外，我們可以進一步得到更細的資訊，包括dump內容和反組譯程式，這時候就要用objdump了 objdump -s -j [section] [filename]：把特定section完整dump出來 objdump -h [filename]：看有哪些section，跟readelf功用類似 objdump -x [filename]：把所有section都顯示出來 objdump -d [filename]：反組譯程式 objdump -d -S [filename]：反組譯程式加上行數 objdump -d -l [filename]：反組譯程式加上source code 同樣以ls為例，可以看到我們把text section的內容印出來了 123456789$ objdump -s -j .text /bin/ls/bin/ls： 檔案格式 elf64-x86-64Contents of section .text: 4028a0 50b9882c 4100baa6 0e0000be 36374100 P..,A.......67A. 4028b0 bf983c41 00e896fb ffff660f 1f440000 ..&lt;A......f..D.. 4028c0 41574156 41554154 554889f5 5389fb48 AWAVAUATUH..S..H.... objcopy/strip修改ELF檔案objcopy最主要的功能就是可以把文件作轉換，一部份或全部的內容copy另一個文件中 objcopy -S -R .comment -R .note [input filename] [output filename]：把編譯出來的symbol移除不必要的section(-S代表去掉symbol, relocation的訊息) objcopy -O binary -j [section] [input filename] [output filename]：也可以把某個section拿出來 關於移除不必要的section部分，其實strip就可以做到了，只要用strip [filename]即可。 objcopy進階用法objcopy可以做到把檔案變成ELF格式，提供給我們linking，這樣我們就可以避免檔案的讀取。 這邊用個簡單的範例，假設我們想要把某個文字檔包在程式內部(其實可以用圖片比較有感覺，只是我不想寫太複雜的程式) 先創立text.txt1This is test txt. 然後把text.txt變成object file1objcopy -I binary -O elf64-x86-64 -B i386:x86-64 text.txt text.o 如果這時候show object資訊的話1234567891011121314151617$ objdump -x text.otext.o： 檔案格式 elf64-x86-64text.o系統架構：i386:x86-64， 旗標 0x00000010：HAS_SYMS起始位址 0x0000000000000000區段：索引名稱 大小 VMA LMA 檔案關閉 對齊 0 .data 00000012 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, DATASYMBOL TABLE:0000000000000000 l d .data 0000000000000000 .data0000000000000000 g .data 0000000000000000 _binary_test_txt_start0000000000000012 g .data 0000000000000000 _binary_test_txt_end0000000000000012 g *ABS* 0000000000000000 _binary_test_txt_size symsymbola把下面那些symbol放入test.c內，即可使用123456789101112#include &lt;stdlib.h&gt;extern char _binary_text_txt_start[];extern char _binary_text_txt_end[];extern char _binary_text_txt_size[];int main()&#123; char *ptr = _binary_text_txt_start; printf(&quot;text.txt=%s\r\n&quot;, ptr); return 0;&#125; 編譯並執行123$ gcc test.o test.o -o a.out% ./a.outtext.txt=This is test txt. nm觀察symbol剛剛提了那麼多都是以ELF內的各種section為主，但是我們實際開發程式其實還是比較重視symbol，那我們有簡單方式可以看symbol嗎？這時候就要用到nm了。 nm [filename]：可以顯示symbol的數值、型態、名稱 nm --size-sort -r -S [filename]：由大到小顯示symbol的數值、大小、型態、名稱 舉個例子，我們可以看到下面執行結果symbol由大到小排序123456$ nm --size-sort -r -S test00008464 00000064 T __libc_csu_init00008444 00000020 T main000084c8 00000004 T __libc_csu_fini000084d4 00000004 R _IO_stdin_used00011028 00000001 b completed.9228 關於常見型態的部分可參考下表： Section 類型(大寫代表global、小寫是local) text section T/t data section D/d Read only R/r BSS B/b 未定義(如extern) U addr2line從位址轉成symbol有時候我們執行程式會只知道位址，但是想要從位址得到到底是在程式哪行掛掉 addr2line -f -e [filename] [address]：-f代表要顯示是哪個function，-e代表address是來自該執行檔 總結本篇文章主要簡單介紹ELF的結構，然後我們可以用 od、readelf、objdump、objcopy/strip、nm, addr2line 幾個工具觀察ELF的格式。如果想要有進一步的認識，建議可以研究參考的連結。 參考 BINARY HACKS：駭客秘傳技巧一百招 陳鍾誠的網站 - 目的檔格式 (ELF) ELF 格式解析 objcopy给目标文件设计一个段]]></content>
      <categories>
        <category>系統程式</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心流與人生]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%BF%83%E6%B5%81%E8%88%87%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[人生的意義到底是什麼呢？這個問題應該每個人或多或少在成長過程都有想過吧？特別是在青春期的時候，心裡因為不知道未來的方向，而有陷入迷惘中，會覺得人生好像是沒有意義的。在我高中時期就是在這樣的狀態中，為了符合外在的要求(拿到好成績)而努力，但是卻不知道自己心裡真正是為何而努力。這樣的心情雖然隨著年齡的增長而慢慢減緩，但是若是問到自己的人生有什麼意義這回事，我想我還是回答不出來。 但是，人生的意義其實根本就只是個偽命題。我們通常期望很輕鬆地得到一個目標，然後再去努力，但是常常人生的意義是先去努力，然後才會得到。最近看了「心流：最優體驗心理學」 ，裡面提到了「最終目標只要能為一生的精神能量建立秩序，它本身是什麽並不重要。人生的意義就在於“尋求意義”：不論它的本質，不論它來自何處，只要找到一個統一的大方向，人生就會有意義。」，這時才隱隱約約明白，原來我根本不缺乏人生意義，我想要的是內心的平靜、內心的秩序，也就是作者所講的心流狀態。意義本身並不重要，每個人都可能有屬於自己的意義，但是在追求意義本身就會為自己生命賦予價值。 「心流」這個概念其實我很久以前就聽過了，一開始是從強者我朋友那裡得知，我原本以為這是一個用在學習的工具罷了，並不是很在意。最近因為有些我看的書籍有再次提到這個概念，才想說來看看當初提出這個概念的作者米哈里的原書。這本書最早是在1990出版，台灣也有出自己的翻譯本，應該是叫快樂.從心開始 ，但也已經絕版了，而最近中國才重出了這本書。的確，如果 google 心流這個詞，十之八九是講我們在面對有一定挑戰性的事情時，進入了聚精會神的狀態，忘了時間的流動，只專注在當下。進入心流會創造最佳的體驗，會讓自己想要一再體驗，這也是很多學習的書籍鼓吹的學習方式。 如果把進入心流的條件和刻意練習相比，會發現兩著有很高的相似性。兩者都一樣需要有個明確的目標、有即時的反饋、需要全神貫注地投入、需要有適當的挑戰性(跨出舒適圈)。但是在本書的介紹序也有提到，兩者的動機是完全不同的，刻意練習是為了讓自己的能力獲得提升，是一種行為，而心流則是一種體驗，讓人沈醉且上癮。儘管如此，我個人的經驗是有意識進行刻意練習時，有時候也會有種進入心流的狀態，忘記時間，想要繼續做下去。雖然本質不同，但是兩者是可以相輔相成的。 為什麼進入心流會讓我們愉悅呢？書中有提到一個概念叫做精神熵，熵在物理的意義是亂度，越高代表越混亂。如果我們的精神熵越高，就代表我們的意識失去了秩序，受到了威脅，我們必須要去防衛，自然就會感到不快樂。心流的意義我會解釋成心靈的秩序，就像磁鐵要有磁性一定要被磁化，讓內部分子的南北極都同向，對外才會產生出一股磁力。當我們進入心流狀態也就是在內心建立起了秩序，不會被外界可能讓心靈混亂的事物打擾，因此才會有忘記自我，忘記時間的感覺。 以秩序來解釋為什麼會快不快樂似乎有其道理。米哈里提到了享樂和樂趣的差別：享樂是恢復均衡的體驗，主要是維持意識的秩序，但無法創造新秩序，樂趣需要高度注意力，完成意料之外的事情。因為樂趣的高複雜度、有挑戰性，所以不斷提供大腦新鮮感，這也是樂趣可以維持比較長久的快樂。另外值得一提的是，如果我們是為了什麼目的才做某件事情，可能就不有趣，就像我們不是為了得到勝利而玩遊戲，而是享受在玩遊戲的過程。因為如果有目的的話，我們就不是專心在當下遊戲規則所帶來的秩序了。遊戲規則主導了我們的心流，讓我們內心維持了秩序，所以有些人在使用外掛後很快就會對遊戲失去興趣的原因也是在秩序已經被破壞了，規則無法再帶給我們心靈秩序了。 米哈里不只是用心流來解釋我們進入專心的狀態，書中他更是嘗試用心流來解釋人類的社會、文化、甚至是遇到困境時要怎麼克服。這也是讓我眼界大開的一部份，原來心流也是可以用來解釋更高層次的現象。社會與文化說穿了其實也就是一種規則，一種秩序，在過去社會文化上的規範會規定我們的外在行為應該要怎麼做，有很多的限制，但是大多數人在成長過程中接受了這樣的限制，然後久而久之自己也成為要求他人遵守這些規則的人。然而在現在的世界，國際間的文化交流、網際網路的發達，拓展了每個人的視野，追求個人自由的風氣中屏棄掉了傳統文化，因此人們有更多選擇。但是更多選擇不代表會更快樂，因為會陷入了不知道要選什麼才好的狀態。這就跟我們父母一輩不會有用興趣選職業這件事，而是找個穩定收入的工作或繼承家業，沒有什麼其他選擇，而我們這代則會迷惘進大學時到底要選擇什麼樣的科系，未來要找什麼工作，到底自己對什麼有興趣。這個選擇越多越不快樂的現象正呼應了人失去了秩序後會不快樂的概念。 但是我個人覺得，這不代表我們要走回頭路，的確規範可以帶給大多數人秩序，但是並沒有道理要求所有人都遵守這樣的規範，自由與民主已經深入人心，難以逆轉。我們能做的是知道這個現象，然後清楚自己的迷惘是來自心靈的失序，接著透過不斷與外界的互動來重新建立自己的秩序，最後就會形塑出屬於個人的價值觀，也就是個人的生命意義。米哈里也建議，我們可以從宗教、歷史、文學等等過去前人所建立的秩序中吸取經驗，建立起屬於自己內心不被擾亂的模式，用前人的力量賦予自己生命新的意義。 本書帶給我很多新的觀念，特別是讓我重新認識了「心流」。在閱讀時，我得承認作者的敘述、排版方式有點冗長，比較沒有架構性，不過不妨礙本書的價值。另外我會推薦大家要看一下推薦序的部分，雖然我從來沒看過那麼長的推薦序，但是卻是一個很好的總結，書中大多數的精華都有被整理出來了。我們不只是要追求在學習上全神貫注的心流，更是要追求人生的心流，真正內心的秩序必須要上從人生觀下到自己的行為都達成一致，並且能心無旁騖專注在其中。如果要用一句話解釋我從這本書得到的觀念，我會這麼說：快樂與幸福來自我們內心的和諧，建立一個可以應付外界干擾的秩序，讓自己的外在行為與內心秩序一致，那就是在人生的心流之中了。]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「請停止無效努力」讀後感]]></title>
    <url>%2F2018%2F04%2F15%2F%E3%80%8C%E8%AB%8B%E5%81%9C%E6%AD%A2%E7%84%A1%E6%95%88%E5%8A%AA%E5%8A%9B%E3%80%8D%E8%AE%80%E5%BE%8C%E6%84%9F%2F</url>
    <content type="text"><![CDATA[第一次看到這本書的原因是是跟朋友在逛書展時發現的，原本對書名並沒有什麼興趣，但是忽然瞄到作者是孫圈圈，馬上就有興致了。之前都會在她的公眾號發現不錯的文章，內容有條理，而且不會流於口號，都有如何實行的方法論。而這本書看完後的確是不負所望，內容很紮實，有把她做諮詢累積的經驗分享出來，我覺得非常適合初入職場的人閱讀。 本書大致上分為好幾個部分：挖掘天賦、如何學習、思維、溝通、職涯規劃、情緒等等，每個都有寫出作者的見解和方法論，這本書編排很好的地方是在每篇文章最後面都會有總結，以及可以怎麼做讀後練習，就像書中一開始所說，現在「道」和「器」的書太多了，但很多都沒有實作方法，所以她想要寫一篇關於「術」的文章。 簡單分享一下我在書中特別有感觸的觀念。挖掘天賦這塊作者列舉了各種職業定位並做簡單分析，並且合理推出天賦型的定位比較適合我們，然後再給出了挖掘自己天賦的方法。雖然我不認同作者說的每個人天生上就有各自的天賦，因為我覺得只要是硬體沒差很多(人的身體)，基本上差異都是後天學習造成的，但是作者在這邊有擴大天賦的定義，她認為意願也是種天賦，有些人可能因為家庭等後天學習因素而喜歡做什麼事、不喜歡做什麼事，這也算天賦的優勢。這個觀念我以前並沒有想過，不過想想也是很合理，理論上人透過一定正確的訓練應該能力不會差太多，但是如果有些人本身就不喜歡該領域，就更不可能去做正確的訓練了，因此能力上就會出現落差。 學習的部分並沒有提到什麼新東西，大概還是離不開刻意練習的概念，然而在思維和溝通的部分就有很多可以參考的點了。畢竟作者是做諮商的，所以這兩個領域都算是她的專業吧！思維的話可以分為結構化思維和創造性的思維，而這其中是有些方法論可以運用來思考的。像是結構化思維可以用常用的架構來輔助思考，或是透過歸納法從資訊找出有意義的內容等等。除了思維，定義問題也是其中一個很重要的因素，我們要清楚自己要解決什麼問題，而且不是所有問題都值得被解決。我以前常常都會想說每個遇到的事情都要全力去做，不這樣做的話就好像是沒有負責任，但是作者反駁這樣的想法，應該是要看CP值，高的才需要全力找最佳解，一般的就只要能處理掉即可。溝通部分則是描述有條理發表言論、與人找話題聊天的方法，這邊是我的弱項，應該可以再好好地吸收消化一下。 職涯規劃的部分有提到可以使用個人商業模式畫布，這個概念我在「程序員跳槽全攻略」看過，不過當初自己做職涯規劃只有幾年後要達到什麼目標，學到什麼能力之類，結果列完後還是沒有去做到，應該說連去回顧都沒有了。作者強調說我們做職涯規劃不該強調目標，而是要強調過程、實現的路徑是什麼，這樣的概念相對來說也比較踏實，不會只是空中畫大餅而已。書中最後情緒的部分有個概念讓我非常受用：面對所謂的性格缺陷，最佳策略不是對抗，而是找應對方式。我很清楚自己的弱點，包括不擅長社交、不喜歡在人多的地方、不喜歡引人注目，但是有時還是會想說要克服自己的缺陷，努力去改變。然而作者的說法是性格是我們的天性，需要花很多資源去改變，因此與其去改變，不如想想如何提高其他的能力來彌補這個缺陷。例如社交要做得好有很多因素，性格只是其中一項，我們可以強化其他因素來達到同樣結果。這個概念在前面的天賦也有提過，不要想著要彌補自己的弱點，而是將彌補劣勢的時間拿來強化自己的天賦，發揮他並且用其他能力彌補弱勢的部分。這個概念就如同巴菲特的雙目標清單系統(Two-List System)一樣，集中資源在自己的目標、強項，不會變成樣樣通樣樣鬆。 本書的內容從我的角度來看，雖然還是有些自己並不是很認同或是覺得有邏輯不清的地方，但是這本書提供給我們一個可以去嘗試的方法，利用這個方法來嘗試改變自己，而我們可以基於這些方法開始思考要怎麼建立屬於自己的方法論，而不會遇到職業、人生的問題時總是滿頭霧水，不斷窮緊張。透過不斷參考、試錯，就可以找到更適合的方法來面對自己的人生。]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「深度學習的技術」讀後感]]></title>
    <url>%2F2018%2F03%2F11%2F%E3%80%8C%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E7%9A%84%E6%8A%80%E8%A1%93%E3%80%8D%E8%AE%80%E5%BE%8C%E6%84%9F%2F</url>
    <content type="text"><![CDATA[會知道這本書是因為之前有在追蹤該作者的部落格，該部落格是分享作者看完書後的讀後心得，他看的書品質都算是很高，有時候我也都會參考他的書單、心得來決定是否要看這本書。後來作者把他看的書做一個總結，寫成一本關於學習的書，也就是這本「深度學習的技術」。原本是有點懶得買，因為並不是實體而且感覺轉帳什麼的很麻煩，不過在同事的勸誘下還是買了。從結論來說我覺得這本真的值得這個價錢，畢竟作者的論述很清晰、有條理，而且都有引用其他著名書籍內容，某種程度上也是集大成了，可以從作者的方法再進一步學習、研究出屬於自己的學習方式。 作者把整個學習過程分成五個階段：記、懂、網、拓、活。記是記憶的意思，講了幾個科學上實驗研究很有用的記憶方法，包括「提取練習效應」、「間隔效應」、「交錯效應」、「生產效應」、「變動效應」等等。但我從中學到的是記不是要強調記憶本身，而是要練習「提取記憶」這件事，所以這些方法都是訓練自己在不同情況下都能夠順利提取記憶，確保自己真的有記憶牢靠，所以也難怪背誦時只是不斷重複閱讀是效率極差，而透過各種提取，如講出來、寫出來、測驗等等記憶的效率會再高一點。這點我應該可以拿來在學習單字上試試做些驗證。 懂的部分就是要讓自己記憶力最大化，有幾個方式：相鄰可能(複利效應)、發散模式(利用散步等時間思考事情)、自然頻率(找適合人類的學習方式，如故事、思想實驗)、透徹程度(以教為學)、工作記憶(善用紙筆)。內容就不一一多提，但是我想最重要的是人類在演化上、構造上還是屬於生物，所以學習上還是有一定生理限制，這些就是讓我們可以用比較輕鬆的方式理解知識。 網則是強調知識的排列重要性，作者強調了碎片化學習不是不好，畢竟很多時候都只能利用零散的時間來學習，但是最重要的是我們需要把知識進行排列，因為往往知識的排列本身比起知識點是更為重要的。要構成知識網有兩個支柱，分別為知識排列以及刻意練習，知識排列算是我們對外顯知識(例如物理學、經濟學等理論)的人工佈線，透過佈線構成自己的知識架構，而刻意練習則是用在學習內隱知識(如開車、游泳等等難用文字描述的領域)，強化我們網狀架構的廣度、強度和密度。這邊不得不提刻意練習真的自從出版後就被各種提到，而且都是我覺得值得一看的好書，好的方法果然是會被其他好書不斷重複提起，這也驗證了重要知識是很容易在生活中重複出現的。 前面都在講怎麼學習，但是學習什麼也是很重要的。拓的部分在講知識是有品質的差別的，要如何辨別知識對自己的價值有三個方面：正確性(過濾機制)、多樣性(跨領域學習)、創造性(思想孵化器)。我認為正確性講的是人類總是有心理學上的弱點，而透過第二層思考就可以盡可能避免被錯誤的知識誤導。多樣性則提到了蒙格的多元思維模型，透過學習多個學科最重要的模型，破除學問間的壁壘，可以解決更多困難的問題。順帶一提，蒙格的窮查理的普通常識也是被各種推廣的好書，雖然內容並不是很有條理的方法論(比較多是演講形式)，但背後的思想可是備受推崇，之後可能也會想收藏一本當傳教用(誤)。最後的創造性則是強調透過寫作讓自己的思維可視化，並且促進更進一步的思考。 最後的「活」先提到了要時時注意一石多鳥，學習要用最有效率的方式學習，不論是閱讀還是做筆記都是，找到好的方法，並且使用它。而更重要的是學了知識就是要用，我很喜歡書中的這句話「知識就像是金錢一樣，不花就等於不曾有過」，作者建議使用知識的方法是開始屬於自己的個人項目，並且給了一些找到與實踐個人項目的方法和原則。我是很認同他的想法，畢竟我也常覺得看完書後好像就只是這樣，沒有真正改變了什麼。也許我也該從一個個人項目開始發揮我所學到的內容。 這本書原則上我非常地推薦，是值得一讀的好書。先不論書中方法對錯，光是作者把各個書的精華統整出自己的知識架構就已經值回票價了。當然，我不是完全認同書中的方法，但是我覺得書中的統整確確實實是改變我一些學習的方法。所以我的建議是不要完全照抄書中的方法，而是要善用作者的統整，建構出屬於自己的學習習慣，這樣才算是最大化利用這本書。]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP header 安全設定]]></title>
    <url>%2F2018%2F01%2F03%2FHTTP-header-%E5%AE%89%E5%85%A8%E8%A8%AD%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[總覽根據DEVCORE，相關HTTP header可以如下分類 防禦 XSS： Content-Security-Policy Set-Cookie: HttpOnly X-XSS-Protection X-Download-Options 防禦 Clickjacking： X-Frame-Options 強化 HTTPS 機制： Set-Cookie: Secure Strict-Transport-Security 避免瀏覽器誤判文件形態： X-Content-Type-Options 保護網站資源別被任意存取： Access-Control-Allow-Origin X-Permitted-Cross-Domain-Policies 防禦 XSSContent-Security-Policy 原理： 用來控制不要讀取外部不可信賴資源，可以防止XSS或injection 啟動方式： 1Content-Security-Policy: policy # policy代表描述你的CSP的策略 範例123456# 所有內容都來自同一個地方Content-Security-Policy: default-src &apos;self&apos;# 比較複雜的設定，不擋image來源，但是設定media和script的來源，注意後方設定會蓋掉default-src的設定Content-SecContent-Security-Policy: default-src &apos;self&apos;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com# 推薦設定：因為預設會擋html裡有js,style，但是大部分都會用到，所以要加上unsafe-inlineContent-Security-Policy: default-src &apos;self&apos; &apos;unsafe-inline&apos; 可參考 内容安全策略( CSP ): 對CSP的基本解說 Content-Security-Policy - HTTP Headers 的資安議題 (2): 對CSP非常詳細的解說，建議一定要看一下。 Set-Cookie: HttpOnly 原理： http only確保javascript無法直接存取cookie。 啟動方式： 只要在Set-Cookie的header加上HttpOnly就可以生效了。 X-XSS-Protection 原理： 這是IE引進的功能，可以檢查XSS攻擊，不過firefox不支援。基本上CSP已經提供足夠防禦，但是可以讓不支援CSP舊版瀏覽器有比較高的安全性。 啟動方式： 123X-XSS-Protection: 0 # 禁止XSS過濾X-XSS-Protection: 1 # 允許XSS過濾，遇到XSS會清除頁面X-XSS-Protection: 1; mode=block # 允許XSS過濾，遇到XSS會阻擋頁面加載 可參考： mozilla X-XSS-Protection: 詳細介紹這個header在哪些browser支援和有什麼選項 資安JAVA(十一)：X-XSS-Protection: 這邊有提到X-XSS-Protection的由來，並且提到IE8之前在這個功能上的問題 X-Download-Options 原理： 在IE8加入了這個選項，防止使用者下載檔案的時候點選直接開啟，避免執行執行了程式而且沒有在下載管理員留下紀錄的問題。 啟動方式： 1X-Download-Options: noopen 可參考 Microsoft-自訂下載體驗.aspx): 為什麼要有這個選項 X-Download-Options: noopen equivalent: 其他browser沒有想對應功能 防禦 ClickjackingX-Frame-Options 原理： 控制frame和iframe顯示頁面的規則，不讓別人可以內嵌頁面。 啟動方式： 在header加上X-Frame-Options: XXX，XXX可以是 DENY：禁止frame頁面 SAMEORIGIN：允許frame顯示同一網站頁面 ALLOW-FROM url：允許frame顯示某一網站頁面1X-Frame-Options: SAMEORIGIN 強化 HTTPS 機制Set-Cookie: Secure 原理： 強制讓cookie必須要在https的情況下才能傳輸 啟動方式： 只要在Set-Cookie的header加上Secure就可以生效了。 Strict-Transport-Security 原理： 當使用者用http連線，強制轉成https連線，這個選項只有在https連線的情況下才有用，如果是http會被忽略(因為可能有MITM) 啟動方式： 123Strict-Transport-Security: max-age=expireTime [; includeSubdomains]# max-age=expireTime: browser要記住這個網站要用https連線的時間# includeSubdomains: 哪些subdomain也都要同樣設定 可參考 Mozilla HTTP Strict Transport Security: 詳細介紹這個header在哪些browser支援和有什麼選項 避免瀏覽器誤判文件形態X-Content-Type-Options 原理： 告訴client要遵守Content-Type的MIME設定，不要自行偵測，管理者必須要確保自己的設定是沒有錯誤的。 啟動方式： 1X-Content-Type-Options：nosniff 可參考 Mozilla X-Content-Type-Options: 詳細介紹這個header在哪些browser支援和有什麼選項 保護網站資源別被任意存取Access-Control-Allow-Origin 原理： CORS是用來解決腳本的跨域資源請求問題，用來確保資源是否可以被其他網站存取，但是要注意它不能阻擋CSRF 不能阻擋CSRF的原因： CORS是阻擋js所發出的request，但是CSRF可以透過form, tag等發起請求 Acess-Control-Allow-Origin是由browser解析的，所以其實request已經發出了，只是response被browser阻擋 啟動方式： 12Access-Control-Allow-Origin: *Access-Control-Allow-Origin: &lt;origin&gt; 可參考 Mozilla Access-Control-Allow-Origin: 詳細介紹這個header的選項 跨來源資源共享（CORS）:詳細解釋CORS(Cross-Origin Resource Sharing)的功能 實作 Cross-Origin Resource Sharing (CORS) 解決 Ajax 發送跨網域存取 Request: 如何用CORS存取外部資源 简单聊一聊 CSRF 与 CORS 的关系: CORS並不能防禦CSRF，這篇有很詳細的介紹 X-Permitted-Cross-Domain-Policies 原理： 當不能把crossdomain.xml放在根目錄時需要設定該選項 crossdomain.xml: 從別的domain讀取flash時所需要的策略文件 啟動方式： 1X-Permitted-Cross-Domain-Policies: master-only # master-only代表只允許主策略文件(/crossdomain.xml) 可參考 Cross Domain Policy: 提到關於crossdomain.xml的設定 关于跨域策略文件crossdomain.xml文件: crossdomain.xml的範例 如何使用 HTTP 响应头字段来提高 Web 安全性？: X-Permitted-Cross-Domain-Policies相關解說 參考 11個網站安全防護的 http Header 設定: 其他人提到的header設定]]></content>
      <categories>
        <category>security</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用軟體工具統整]]></title>
    <url>%2F2017%2F11%2F11%2F%E5%B8%B8%E7%94%A8%E8%BB%9F%E9%AB%94%E5%B7%A5%E5%85%B7%E7%B5%B1%E6%95%B4%2F</url>
    <content type="text"><![CDATA[文件開啟docx, pttx, xlsx Office(word, excel, powerpoint, visio)：Windows和MAC上還是用就微軟的工具比較方便。 LibreOffice：Linux上的話可以用這個，但是其實我是不推薦在Linux上做類似的事。 開啟pdf Foxit：適用於Windows、Linux，可用來取代Adobe Reader來看pdf檔案。 MAC的話其實用預設的預覽程式就足夠了。 筆記下方筆記軟體都是可以跨平台的 QOwnNotes：支援Markdown、tags和資料夾的筆記軟體，我會搭配dropbox來進行同步，可參考官網 evernote：最常見的筆記軟體，但是不支援完整Markdown，我只用來記雜事用。 GitBook：之前有用這個來做筆記，但是反應速度有點慢，不推薦。 特殊文件 texmaker: 專門處理Latex的工具 Poedit: 專門處理po的工具 網路功能browser Chrome Firefox 檔案交換 Dropbox：支援跨平台 FTP client FileZilla FTP：支援跨平台。 遠端連線 TeamViewer：支援跨平台。 ssh client下面只介紹Windows的部分，因為Linux和MAC都可以用ssh或scp指令連線 putty(MTPutty) pietty：支援Big5的putty版本 winscp：如果要用ssh來取得檔案用這個很方便。 VPN FortiClient SSL VPN：我只用過這個，而且還是舊版的，我記得是每個OS都可以使用，未來可以再研究看看。 TFTP只支援Windows，如果是Linux和MAC是可以用command line下載TFTP。 Tftpd32：如果要自架TFTP Server的好工具，可參考官網 社交軟體 Skype LINE Telegram 程式文字編輯器一樣只介紹Windows，其他平台建議直接用vim notepad++：非常輕量級的文字編輯器，非常好用。 gvim：Windows上的vim，但是有時候並不是那麼好用。 git其他平台我是都用command line，但是也許可以再找找有沒有好的圖形化介面 Git / Tortoise Git：用來追蹤code必備工具 虛擬化 VirtualBox：跟其他虛擬機的差異是他是Open Source，但是穩定度比起來還是有差。 Docker：我是比較少用，但是用的對的話，其實是個好工具。 qemu：當沒有開發板的時候挺好用的 interpreter Python：可以用來執行我們寫的簡單小程式。 compiler CodeBlock：要測試code可以在上面compile看看，但是不夠輕量，有時候不如開Linux虛擬機測試比較快。 gcc：MAC和Linux。 Editor vscode：好用的編輯器，而且跨平台，支援許多套件，但是對C/C++的支援比較低。 debug工具 Wireshark：抓封包專用，三個平台都適用。 以下都是Windows上的工具，還沒找到其他平台的版本 iReasoning：可以用來做SNMP query。 HxD：看檔案的二進位。 WinMerge：比對code專用。 Colasoft Packet Builder: 修改pcap Colasoft Packet Player: 重放packet 影音播放音樂 iTunes：適用Windows和MAC，播放、整理音樂的工具。 影片 SMPlayer：適用於Windows和Linux的播放器 IINA：適用於MAC。 剪輯影片 威力導演：剪影片專用，適用於MAC 燒錄目前找到的都只適合Windows Free Make Vedio Converter：燒DVD專用。 burnaware：可以燒iso和音樂CD。 DVDFab Virtual Drive：模擬虛擬光碟機。 轉檔 格式工廠：如果要轉檔的話非常好用。 系統套件管理 Linux就隨Distro而有不同 MAC的話可用homebrew brew的使用方法如下 123456789101112# 更新listbrew update# 找套件brew search [套件名]# 檢查哪些套件過時brew outdated# 更新套件brew upgrade# 清除cachebrew cleanup# 找官網brew home 優化電腦 WiseCare 365：適合Windows Magican、AppCleaner：適合MAC 監控系統狀態 CrystalDiskInfo：監控硬碟狀態，適合Windows smartd：Linux可用這套軟體看硬碟狀態。 menumeter：看系統整體資訊的付費軟體，適用MAC。 解壓縮工具 7-zip：適合Windows The Unarchiver：解壓縮工具，適用MAC CleanArchiver：壓縮工具，適用MAC 連接手機 Android File Transfer：在MAC上如果要連android手機必備 CLI toolsMAC可以用iterm取代原來terminal Editor vim shell zsh tmux mosh：可以保持連線不要斷掉，當網路一旦恢復就會馬上連回去。 version git tig program ipython irb silversearcher-ag：找字串 cloc：算程式碼數量 ctags astyle：coding style工具 system lynis: 檢查系統安全性 使用方式lynis -c smartmontools：讀取硬碟資訊 mtr：看網路狀態，ping和traceroute的結合 tree：可以列出目錄 htop、iotop、iftop：各類的top httpie：command是http ncdu：加強版的du tldr：簡化版的man trash-cli：trash-list, trash-rm, trash-put, trash-empty, restore-trash fd：更簡單的find hacker nmap：掃描網路上的機器 hydra：暴力破解的軟體 openssl：加解密工具 sqlmap：SQL injection工具 others qpdf：對pdf檔做一些操作 gnuplot：畫圖的工具 youtube-dl：下載youtube 使用方式youtube-dl -F [URL]：看有哪些格式 youtube-dl -f 136/mp4 [URL]：選擇格式下載 ffmepg：轉換影片檔 GPG：認證工具 irssi：IRC工具]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>updating</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo教學]]></title>
    <url>%2F2017%2F09%2F09%2Fhexo%E6%95%99%E5%AD%B8%2F</url>
    <content type="text"><![CDATA[我之前一直想要自己寫blog，可以留下些記錄，但是一方面不想要自己架server，管理有點麻煩另一方面又希望可以有markdown的功能，而這是google的blogger所欠缺的後來搜尋了一下，找到了這篇使用 Hexo+Github 建立個人網誌，發現使用hexo+github對我而言根本是最佳選擇github讓我不用自己架server，hexo讓我可以快速有個漂亮的介面，而且還可以用markdown來寫blog 第一次安裝這邊一開始要先安裝好git和npm，兩者的使用就不在這邊多提了。 先在github上創立一個新的repo，像我的話就是evshary.github.io clone下來並且創立master和source兩個branch，這兩個branch分別有不同用途，master用來放顯示的網頁，source用來放產生網頁的原始檔 首先先切到source的branch，然後開始安裝hexo(當然要先裝好npm) 1234npm install hexohexo initnpm installnpm install hexo-deployer-git 修改_config.yml的deploy參數，branch改為master，這個代表的意思是我們會把產生的網頁放到master這個branch上 執行hexo g來產生顯示的網頁 當我們修改好blog，就可以把source的branch commit並且push上github 最後執行hexo d就可以上傳網頁了，這個動作代表著把master push上github 未來的使用都是在source的branch下commit並push，然後才用hexo d上傳 重裝未來要在新電腦重建環境就不用像第一次那麼麻煩了 首先在新電腦把blog的repo clone下來並切到source的branch，如下面指令 1git clone -b source git@github.com:[你的github帳號]/[repo名稱].git 重新安裝hexo，然後就可以直接開始使用了 123npm install hexonpm installnpm install hexo-deployer-git 使用 建立新文章一開始最重要的事怎麼建立新文章 1hexo n &quot;文章主題&quot; 這時候會在source/_posts/底下新增一個md檔案，打開它就可以開始寫blog了 根據markdown產生html頁面 1hexo g 產生結果會在public資料夾下 local端預覽寫完之後的當然要產生頁面來看自己寫的如何，下面這個指令可以建立測試的server 1hexo s 這時候開瀏覽器連線http://localhost:4000應該就可以連上 push到github上 1hexo d 主題使用hexo當然最重要的是漂亮的主題囉，hexo的github上已經有提供許多主題推薦，可以參考Themes不過我個人覺得iissnan/hexo-theme-next比較好看，所以就用這個了安裝方法如下： 先把喜歡的主題clone到themes資料夾下，然後把clone下來的資料夾改名，例如hexo-theme-next改成next 1git clone https://github.com/iissnan/hexo-theme-next 在_config.yml修改theme關鍵字，例如我們改成剛剛命名的next 1theme: next 套件當然hexo提供很多套件，我目前用到的是下面這兩個 google analytics可參考如何讓google analytics追踪你的Hexo Blog安裝方法其實也很簡單，這個套件是跟theme綁在一起的，我們開啟themes/[自己的主題]/_config.yml，找到下列字串1google_analytics: 在後面填上自己申請的google analytics ID就可以了。 Disqus的留言板功能可參考[Hexo] 加入 Disqus 讓 Blog多個留言功能部署在github的hexo沒有讓訪客留言的功能，所以這時候就需要第三方的整合型留言板Disqus了這個也是跟theme綁一起的，所以一樣開啟themes/[自己的主題]/_config.yml，找到1disqus_shortname: 後面填上自己在Disquz註冊的short name就可以囉！ LocalSearch的搜尋功能我們如果要blog支援搜尋功能，可參考Hexo博客添加搜索功能，下面列出應該要做的步驟 首先要安裝hexo-generator-searchdb套件 1npm install hexo-generator-searchdb --save 接著在_config.yml新增如下設定 1234# Searchsearch: path: search.xml field: post 開啟themes/[自己的主題]/_config.ymlenable local_search 123# Local searchlocal_search: enable: true 最後重新生成啟動即可 12hexo cleanhexo s -g 如果搜尋功能不斷轉圈圈通常會有一種情況搜尋功能會有問題，就是產生的search.xml有文字編碼錯誤 先檢查search.xml的語法，可使用Validate an XML file這個線上網站 網站會告訴你哪邊有錯誤的編碼，可以直接進去修改 如果使用vscode的話可以從設定啟動renderControlCharacters，就會顯示錯誤的字元了 如果有必要可以直接把該字元複製並且使用全域搜尋並修正(因為我們沒辦法打出該字元) 詳情可參考HEXO-NexT的Local Search轉圈圈問題 RSS如果要在hexo上加上RSS訂閱，需要使用hexo-generator-feed套件 先安裝hexo-generator-feed 1npm install hexo-generator-feed 在_config.yml內加上如下內容 123456789# RSSfeed: type: atom path: atom.xml limit: 10 hub: content: content_limit: content_limit_delim: &apos; &apos; 最後重新生成啟動即可 12hexo ghexo s 可參考为hexo博客添加RSS订阅功能 增加live2d 先安裝必要的npm包 12npm install hexo-helper-live2d --savenpm install live2d-widget-model-shizuku --save 設定_config.yml 1234567891011121314# live2d# https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-shizuku display: position: left 可參考用Live2D让看板喵入住你的Hexo博客吧(^o^)/~ 參考使用hexo，如果换了电脑怎么更新博客？使用hexo，如果换了电脑怎么更新博客？]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[clean code]]></title>
    <url>%2F2017%2F09%2F03%2Fclean-code%2F</url>
    <content type="text"><![CDATA[這邊記錄一下我看clean code的筆記整理不過我得承認其實書裡很多做法我是不太贊同的，例如function要壓在20行以內這種在C要這樣實踐很有難度，而且我看很多open source的project也都沒有遵循這樣的規範但是這本書還是很有參考價值的，至少會讓自己反省寫code時有沒有犯了這些問題。書中提到一個概念： 程式設計師有大半時間花在看code，因此好閱讀的code對快速寫程式是有幫助的 我想這就是我從書裡得到最大的收穫吧！ 有意義的名稱 讓程式碼的隱含性高，名稱和意圖符合 避免誤導讓變數不會相似高(autocomplete好找)像是l和1，0和O 產生有意義的區別例如a1,a2、ProductInfo,ProductData,或是table, variable等等都看不出差別 使用能念出來的名稱人類大腦有一大部分都專注在字詞的概念，字詞是可發音的，方便理解方便同事間彼此溝通 使用可被搜尋的名字使用單一字母變數或是數值常數很難被找到例如MAX_CLASSES_PER_STUDENT比7還要好找，命名變數e幾乎每段程式碼都會用到一般來說，長命名比短命名好，命名長度應該和scope作對應，範圍越大的應該要用比較容易識別的名字 避免編碼這邊的編碼是指形態或視野，作者不推薦使用匈牙利標誌法，因為那是早期編譯器不會進形型態檢查，但是現在編譯器已經會做了，所以不需要浪費時間做這件事 可是有時候在看code，有提示還是比較容易記憶的，見仁見智 成員的字首不需要在變數前加上類似m_ 類別方法命名類別：要用名詞來命名方法：用動詞命名，而且accessors要用get開頭、mutators用set、predicates要用is 使用一致性的詞彙例如取得方法不要同時有get, fetch, retrieve 將命名放在有意義的上下文例如state要配合address看才會知道是州，如果沒辦法配合上下文那就手動加上前綴，例如addrState 不要添加過多無意義資訊例如每個變數名稱都加上特定前綴，會讓IDE無法幫你找變數 函式 函式要非常簡短，盡量低於20行 函式內的縮排也不要大過一兩層 做一件的函式是無法被區分成不同段落的，如宣告區、初始區等等 降層準則：程式閱讀應該是由上而下敘事，希望每個函式後面都進接著下一層次的概念。 函式應該做一件事，他們應該把這件事做好，而且他們應該只做這件事。 函式參數最多不要超過三個，越少越好，如果需要超過三個，可以考慮使用物件代替 越多參數要測試會越困難，而且參數有傳達概念的能力，讀者必須去了解它 另外不要用輸出型參數，用回傳值 分離指令和查詢(set和get) 使用例外處理來取代回傳錯誤碼，讓使用者不需要一遇到錯誤碼就必須馬上處理錯誤 結構化程式：雖然Dijkstra提到在一個函式內只能有一個return，不要有break和continue，以及goto，但是作者認為在小函式時可以適當使用，但是不應該用goto，因為只有大函式goto才有用處 註解 適當使用註解是用來彌補我們用程式碼表達意圖的失敗 沒有提供比程式碼更多資訊或是反而誤導的註解就是壞註解，當然過多資訊也是 git已經提供修改紀錄，不該寫在註解中，包括程式碼的註解也應該拿掉 適合用註解的時機 法律型註解 資訊型的註解 對意圖的解釋 闡明 對後果的告誡 TODO 放大重要性 Javadoc 編排每個檔案應該大部分用200行，最多不超過500行 垂直距離 程式中，應該要用垂直空白區分思緒(兩個函式間)，而且如果兩個函式密且相關的話，不要放太多註解在兩者之間 變數宣告：變數的宣告應該盡可能靠近變數被使用的地方 實體變數(instance)：盡量集中在最上方或最下方，方便被查詢 相依的函式應該放在同一區塊，相依性越高，彼此的垂直距離就要越短 水平距離 通常程式設計師偏好短的程式碼，不一定要80，但不要超過120 水平空白也可以用來表示優先權，例如乘法之間不要有空白，加減法則要 水平的對齊也沒有必要，因為自動化編排程式會毀掉這樣的對齊，而且這樣會讓人忽略變數型態，只關注上下的對齊 不過像define我就覺得有必要對齊，這樣方便觀看 12int abc;float def; 不要使用一行文，包括單行while加上分號，很容易搞錯 這邊注意if如果是一行，也許加上大括號會比較好，常常會在下方加上其他敘述卻忘了加括號，這樣會有不同的行為 物件及資料結構不要幫每個private都加上get, set，應該要思考怎樣才能隱藏更多資訊例如123FuelTankCapacityInGallons()&#123; double getGallonsOfGasoline();&#125; 會差於123publice interface Vehicle&#123; double getPercentFuelRemaining();&#125; 因為使用者知道怎麼計算油量 資料與物件有反對稱性結構化的程式碼容易添加新函式，而不需變更原有的資料結構物件導向的程式碼容易添加新類別，而不用變動已有函式 錯誤處理 如前所說，作者建議用例外事件而非錯誤碼 不要使用java中的checked exception，因為如果底層函式被修改，會強制所有被呼叫的函式都要做錯誤檢查，會破壞函式封閉原則 不要回傳null，會讓使用者需要做額外判斷 傳遞null也會讓函式需要做額外判斷 邊界當使用第三方軟體時，可以考慮製作一個介面來與第三方API銜接，這樣如果有大改動時，我們只需要修改介面即可 單元測試TDD(Test-Driven Development)有三大準則 在撰寫一個單元測試前，不可以撰寫任何產品程式 只撰寫剛好無法通過的單元測試，不能編譯也算無法通過 只撰寫剛好能通過當前測試失敗的產品程式以上準則可以讓程式設計師被限制在30s的循環：測試程式和產品程式是一起被撰寫的。 一個測試一個assert，但作者認為不需要嚴格遵守，盡可能少即可一個測試一個概念 FIRST Fast：測試要夠快，能夠快速執行，讓人有意願去執行 Independent：測試程式不應該互相依賴，會讓人更難尋找錯誤 Repeatable：可以在任何環境下執行 Self-Validating：要輸出boolean告知程式成功或失敗，而非去看log主觀判斷 Timely：單元測試要再寫產品程式之前，這樣才能寫出可被測試的程式 類別 Single Responsibility Principle(SRP)：單一職責原則 一個類別或模組應該只有一個被修改的理由 保持類別的凝聚性(每個變數被多個method使用)：這樣會得到許多小class 系統軟體系統相較於實體系統來說是獨特的，如果我們持續保持適當的關注點分離，軟體系統的架構就能遞增地成長 羽化遵守四個原則： 執行完所有測試：有測試就會消除整理程式碼會破壞程式的恐慌 沒有重複的部分 表達程式設計師的本意 最小化類別和方法的數量：這條守則的優先權是最低的 平行化 物件是處理過程的抽象化，執行緒是排程的抽象化 平行化是去耦合的抽象化，讓「做什麼」和「什麼時候做」分開 另外也可以解決response time和throughput的限制 迷思X 平行化總是能改善效能X 撰寫平行化程式並不需要修改原有的設計O 平行化會帶來額外負擔O 正確的平行化是複雜的O 平行化的錯誤通常不容易重複出現 平行化防禦方法 單一職責原則(SRP)：保持平行化程式碼與其他程式有清楚劃分 限制資料視野：嚴格限制共享資料的存取次數 使用資料的副本：複製唯讀副本，減少共享資料次數 執行緒盡可能獨立運行 另外也要保持同步區塊的簡短，因為cost高 優雅的關閉平行化程式碼，注意能讓子thread可以關閉 測試 不要因為系統後來通過測試就忽略失敗，因為未來會有越來越多錯誤建立在有缺陷的基礎上 先讓非執行緒的程式碼可以運作，不要兩者同時debug 讓執行緒是可以自我調校 執行比處理器還多的執行緒，bug會越容易找到 在不同平台執行 調整程式碼，使其產生失敗 Bad Smell註解 無效、沒意義、不適當的註解 被註解掉的程式碼 開發環境 需要多個步驟建立專案或系統 需要多個步驟進行測試 函式 過多參數 輸出行參數 旗標參數 被遺棄的函式 一般狀況 同份原始碼有多種語言 明顯該有的行為沒被實現(最小驚奇原則) 在邊界上的不正確行為：不要依賴直覺，為邊界條件寫測試程式 無視安全規範：不要關閉編譯器的警告 重複的程式碼：這是最重要的規範之一 在錯誤抽象層次上的程式碼：高層次概念都要在基底類別 基底類別相依於其衍生類別 過多資訊：應該要把暴露在介面上的資訊減少 被遺棄的程式碼 垂直分隔：如前所示 不一致性：維持命名一致性 雜亂程式：保持原始檔整潔 人為耦合：不要將變數隨意宣告，然後就留在某處 特色留戀：類別的方法應該只對同一類別裡的變數和函式感興趣，不應該操作其他類的變數或函式 選擇型參數：在函式尾端加上true, false 模糊的意圖：盡可能讓程式碼有表達力 錯置的職責：像是要把常數放在讀者認為他應該要在的地方 使用具解釋性的變數：將計算過程拆解成富有意義名稱的暫存變數 函數名稱要說到做到 了解演算法：不是調整函式做到想讓其做到的事，而是確定解決方法是正確，並且讓函式明顯透露出是怎麼運作的 用多型取代if-else和switch-case 遵循標準的慣例：用團隊的慣例 用有名稱的常數取代魔術數字 要精確：不要有模擬兩可的程式碼，精確表達該函式要做什麼 封裝條件判斷：if(shouldBeDeleted(timer))取代if(timer.hasExpired() &amp;&amp; !timre.isRecurrent()) 避免否定條件判斷 函式只該做一件事 不要隨意：如果程式碼保持一致性，這樣後來修改的人就會按造前面的原則改 封裝邊界條件：如果a+1常被用到，那就用b=a+1取代，這點跟refactoring似乎不太一樣 命名 選擇有描述性的名稱 在適當的抽象層次使用適當的名稱 越大的scope就要用較長的名稱 測試 不足夠的測試程式 不要跳過簡單的測試 對程式錯誤處進行詳細測試 測試要夠快速]]></content>
      <categories>
        <category>軟體開發</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[code review]]></title>
    <url>%2F2017%2F08%2F27%2Fcode-review%2F</url>
    <content type="text"><![CDATA[前言其實我一直對code review有點好奇，到底有什麼樣的好處。所以統整了些資料，研究看看實行的好處以及如何實行code review。 重要：這篇只是我想理解code review方式而整理出來的文章，不一定真的實用，之後會隨著我經驗增加而更新內容 好處 品質提升：開發者太熟悉流程了，可能會有盲點，其他人可能可以幫忙找到邏輯問題。 更容易維護：其他人幫忙看code可以確保程式的可讀性，不會只有開發者才看得懂，開發者開發時也因為會有人來看，所以會思考我這樣是否可以讓review的人看懂邏輯。 同步文化、設計理念：確保程式有符合團隊開發的風格、coding style、API使用習慣等等，也比較不會有開發了功能跟原來架構設計理念有落差的情況。 經驗傳承和相互學習：資深員工把經驗傳給新進員工，或是大家彼此間可以學到寫程式的小技巧。 備份功能：確保至少有兩個人知道code的意思。 成本 開發時需要多花費時間在上面code review上，但長遠來說會減少maintain時間 要有正確的心態來review，不然會造成團隊氣氛不佳 心態 code和人是分開的：我們是針對code做討論，而不是質疑人的能力。 相互信任：信任團隊沒人會故意寫爛code，有問題是可能只是沒想到而已。 相互尊重： 討論過程中是相互學習的關係，而不是監視和監視的關係。 review者討論態度語氣不能太尖銳，被review者也要能接受合理的意見 相互學習：做code review不只是要維護品質，更重要的是大家可以彼此學習，學會更好的技巧。 方法前置作業 說明code review規則，以及建立正確的心態 事先訂定公司開發的文化，如coding style，命名規則 使用工具在處理機械化作業，如coding style統一，減少人為介入 開發功能前 開發時間需要預估code review的時間 先規劃如何將大功能切成小部分： 控制在reviewer 15min內可以看完的程度，這樣reviewer可以在工作一段落時稍微看一下，不佔用太多時間 如果功能出了大問題，也可以把風險控制在最小 review前 review前要先準備好環境，可以demo或讓reviewer測試 如果有使用分析工具，先使用工具產生報表 review時可以針對上面的重點討論 減少review的effort review中 讓reviewer主導review的過程，這樣才能發現盲點 code review時間不要超過半小時 利用checklist來檢查 功能需求是什麼？設計方式是否有達到目的？ 是否可以做未來擴充？ 是否足夠安全？有沒有邏輯漏洞？ Error handling和corner case是否都有處理好？ 程式是否易讀？複雜地方是否有註解？可以再精簡嗎？ 有符合團隊coding style嗎？命名好嗎？有沒有通過工具測試？ 效能是否可以再提升？ review過程不改code，用todo list先記錄 review後 要留下reviewer是誰，不是要抓戰犯，而是當開發者不在時，可以知道有誰懂這段code review後要留下紀錄提供學習使用 定期開會評估code review流程和效用 review的方式要不要調整？ 工具是否要調整？ checklist是否要更新？ 輔助工具下面工具只是先整理起來，我並沒有每個都用過，等真正用過再來寫心得吧！ 統一Glossary： 可以使用wiki等文件建立 找重複程式碼： Simian：商用需付費，可參考CI Server 13 - 找出重複的程式碼 (Simian) 判斷複雜度： SourceMonitor：免費，可參考[Tool]SourceMonitor - 程式碼掃瞄 Complexity：GNU tool，可參考Complexity：一个测量 C 代码复杂性的工具 分析綜合品質： FxCop：微軟出的，可參考[Tool]靜態程式碼分析－FxCop Adlint：Open source，但似乎很久沒更新了 SonarQube：可參考SonarQube 程式碼品質分析工具 程式法風格： StyleCop：似乎只能用在C#，可參考[如何提升系統品質-Day17]品質量測工具-StyleCop Artistic Style：可以自動統一所有程式碼的風格，甚至可以綁在git的commit hook上，確保大家不會commit風格不對的code 如何實際落實通常要在運作一段時間的團隊加入新機制並不是那麼的容易，特別是怕會影響正常業務。所以可以試試沙盒的概念，先少部分的人開始測試使用，而且也不要一下子就把所有機制加上去，以不一下子造成過多改變為主，慢慢調整最後相信可以找到適合團隊的做法。 可以調整的選項code review的基本概念是要讓其他人來看開發者的code，以客觀角度檢視，藉此提高品質和增進彼此相互學習所以只要能達到這個目標的手段其實都是可以接受的，重點是要找到適合團隊的方式這邊有幾項可以思考的方向： review的方式：網路上找到大部分的方式都是git的Pull Request功能，可以線上直接看code，不過或許直接到對方位置看也是個選項。 review的頻率：這個可以隨團隊開發內容的性質作調整 review的大小：有些review是多人一起，這個比較適合有很多新進人員，需要一起建立開發文化。不然一般是用peer review即可。 如何評估效用當然code review一定是好處大於壞處才會讓大家採用，那要怎麼評估好處部分呢？可以從下面幾個方向來想： 執行前後，bug減少的數量(這是品質部分) 執行前後，團隊多花費的時間(這是成本部分) 大家在執行後的感想？是否有所學習？(畢竟學習這種東西很難用數據衡量) 在code review中發現哪些問題？(bug減少數量如果不好統計，可以看有哪些潛在問題被發掘) code品質部分？這部分可以用工具評分或是問問開發者的感受。 參考Code Review Guidance：這篇微軟的文章非常值得一看，該講的都有講出來。[如何提升系統品質-Day30]Code Review與總結：這邊有提到許多工具，可以研究看看你今天 code review 了嗎？：這篇也很推薦，對code review的本質和方法有不錯的論述參考腾讯Bugly的回答：這邊提到code review如何實現在不同種類團隊上，偏實務方面的文章Airbnb 資深工程師分享：怎樣才是正確、有效的 code review：提到了code review的正確態度我們是怎麼做Code Review的：別人實現code review的經驗]]></content>
      <categories>
        <category>軟體開發</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[port knocking]]></title>
    <url>%2F2017%2F08%2F27%2Fport-knocking%2F</url>
    <content type="text"><![CDATA[簡介port knocking就像是敲門的暗號一樣，以特定順序碰觸port，server就會執行特定指令我們可以把這個功能用來開port，就像阿里巴巴要用咒語才可以開門一樣。詳情可參考port knocking的定義 安裝我這邊server是用Ubuntu, client是MAC環境。 server1sudo apt-get install knockd client1brew insrall knock 設定檔通常在位置在/etc/knockd.conf最初的設定檔，可參考manual這邊是客製化的設定，目的是可以開關port 22，防止有人亂連。1234567891011121314[options] UseSyslog[openSSH] sequence = 3389:udp,80:tcp,21:udp,53:tcp,23:udp seq_timeout = 5 command = /sbin/iptables -I INPUT 1 -s %IP% -p tcp --dport 22 -j ACCEPT tcpflags = syn[closeSSH] sequence = 443:tcp,80:udp seq_timeout = 5 command = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT tcpflags = syn 功能大概看名字也可以猜出來 sequence: 敲port的順序 seq_timeout: 間隔時間 command: 如果成功敲完，要執行什麼命令，這邊是用開ssh來當示範 tcpflags: 如果是TCP連線，需要有什麼flag 使用server端把/etc/default/knockd中的START_KNOCKD改成1然後啟動1sudo service knockd start 記得防火牆要先設定不讓外面的人進入1/sbin/iptables -A INPUT --dport 8888 -j DROP client端須先安裝knock1234# 開啓knock -v 192.168.0.1 3389:udp 80:tcp 21:udp 53:tcp 23:udp# 關閉knock -v 192.168.0.1 443:tcp 80:udp 注意knock不一定要完全正確例如說如果順序是7000,8000,9000那麼我們用7000-9000依序敲過去仍然是可以打開但是如果是分兩次knock就沒有用了]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dependency]]></title>
    <url>%2F2017%2F08%2F26%2Fdependency%2F</url>
    <content type="text"><![CDATA[問題通常我們都會用Makefile來看相依性，如果有改動make會自動幫我們判別但是有些情況，make可能無法判斷以下面為例，我們有四個檔案：main.c, test.c, test.h, private.h main.c123456#include "test.h"int main() &#123; test(); return 0;&#125; test.c123456789#include &lt;stdio.h&gt;#include "private.h"#include "test.h"void test()&#123; printf("test=%d\n", PRIV_VALUE); return;&#125; test.h123456#ifndef _TEST_H#define _TEST_Hvoid test();#endif private.h123456#ifndef _PRIVATE_H#define _PRIVATE_H#define PRIV_VALUE 3#endif 然後假設我們的Makefile是這樣寫123456789101112CC=gccOBJ=$(patsubst %.c,%.o,$(wildcard *.c))BIN=main.out%.o: %.c $(CC) -c $^all: $(OBJ) $(CC) $^ -o $(BIN)clean: rm *.o $(BIN) 我們試著修改private.h的MACRO值，就會發現重新make結果還是不變，需要重新make clean 解法可以使用gcc的特殊option gcc -M xxx.c: 找出所有相依檔 gcc -MM xxx.c: 同-M，但不含系統檔 1main.o: main.c test.h gcc -MP -MM xxx.c: 會加上其他header，避免某些compiler error 123test.o: test.c test.h test.h: -MF file: 輸出的dependency檔案名 -MD: 同-M -MF -MMD: 同-MM -MF -MT: 可以更改dependency檔案內的目標，可參考关于 gcc MT MF[转] 因此只要把Makefile改成這樣即可123456789101112131415CC=gccOBJ=$(patsubst %.c,%.o,$(wildcard *.c))BIN=main.outall: $(OBJ) $(CC) $^ -o $(BIN)-include $(OBJ:.o=.d)%.o: %.c $(CC) -c $&lt; $(CC) -MM $&lt; &gt; $*.dclean: rm *.o $(BIN) *.d -代表如果有錯誤不要停止執行，$(OBJ:.o=.d)代表把.o換成.d，因此會變成類似12test.o: test.c private.h test.hmain.o: main.c test.h 由於該rule底下沒有statement，所以會直接對應%.o: %.c 參考 Auto-Dependency Generation GCC 技术参考大全 附录D 命令行选项]]></content>
      <categories>
        <category>系統程式</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
      </tags>
  </entry>
</search>
