<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM CortexM3/4權限切換</title>
    <url>/2018/12/02/ARM-CortexM3-4%E6%AC%8A%E9%99%90%E5%88%87%E6%8F%9B/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>最近我在研究怎麼在ARM Cortex M3&#x2F;4上面跑一個自己寫的OS，最主要是參考jserv的<a href="https://github.com/jserv/mini-arm-os">mini-arm-os</a>和<a href="https://github.com/PikoRT/pikoRT">pikoRT</a>，相關程式碼放在<a href="https://github.com/evshary/arm-os-4fun">arm-os-4fun</a>。<br>最近發現自己遇到了些問題，想說再研究怎麼解決的過程中順便把細節紀錄下，供自己未來可以參考。</p>
<p>這邊首先要探討的是Cortex M3&#x2F;4上面有的權限模式，以及它們是怎麼進行切換等細節。<br>原本我是在qemu上面跑<a href="http://beckus.github.io/qemu_stm32/">STM32虛擬機</a>，但是後來發現好像跟真實硬體有點不一致，所以後來我都在STM32F429的硬體上面來測試了。</p>
<h2 id="Cortex-M權限設計"><a href="#Cortex-M權限設計" class="headerlink" title="Cortex M權限設計"></a>Cortex M權限設計</h2><p>首先我們先了解Cortex上面有哪些權限模式，處理器上面有兩種Operation Modes：Thread mode和Handler mode。</p>
<ul>
<li>Thread Mode：一般程式運行的狀態。</li>
<li>Handler Mode：處理exception的狀態。</li>
</ul>
<p>然而除了這個以外，還有不同的Privilege Levels，避免一般使用者可以存取敏感資源。</p>
<ul>
<li>Privileged：可以存取所有資源，在CPU reset之後就是privileged。</li>
<li>Unprivileged：通常是讓OS中userspace的程式運行用的，在幾個方面存取資源是受限的。<ul>
<li>MSR、MRS指令存取上會有限制。</li>
<li>無法存取system timer、NVIC。</li>
<li>有些memory無法存取。</li>
</ul>
</li>
</ul>
<p>Operation Modes和Privilege Levels的關係如下所示，Unprivileged不能進入Handler Mode的。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>Privileged Level</th>
<th>Unprivileged Level</th>
</tr>
</thead>
<tbody><tr>
<td>Handler Mode</td>
<td>O(state1)</td>
<td>X</td>
</tr>
<tr>
<td>Thread Mode</td>
<td>O(state2)</td>
<td>O(state3)</td>
</tr>
</tbody></table>
<ul>
<li>上面標註的state 1-3是為了方便我們後面講解而標的。</li>
</ul>
<h2 id="如何切換權限與模式"><a href="#如何切換權限與模式" class="headerlink" title="如何切換權限與模式"></a>如何切換權限與模式</h2><p>關於切換的部分可參考下圖，圖片來源<a href="https://community.arm.com/processors/b/blog/posts/a-tour-of-the-cortex-m3-core">A tour of the Cortex-M3 Core</a></p>
<p><img src="https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-21-42/6470.handler_2D00_thread.PNG" alt="模式切換"></p>
<p>下面我們先看怎麼樣從state2,state3進入state1，也就是發生exception，然後再從state1回來。</p>
<h3 id="Exception-Entry"><a href="#Exception-Entry" class="headerlink" title="Exception Entry"></a>Exception Entry</h3><p>進入exception有兩種情況：</p>
<ol>
<li>目前我們在thread mode</li>
<li>preempts：發生的exception比目前我們所在的exception權限還高</li>
</ol>
<p>發生exception時，ARM會自動把當前的register的資訊存起來，順序為xPSR, PC, LR, R12, R3, R2, R1, R0。儲存的方式就是push到當前的stack中，可能是main stack(SP&#x3D;MSP)，也可能是process stack(SP&#x3D;PSP)。</p>
<table>
<thead>
<tr>
<th>address</th>
<th>register</th>
</tr>
</thead>
<tbody><tr>
<td>SP+00</td>
<td>R0 &lt;- SP after exception</td>
</tr>
<tr>
<td>SP+0x04</td>
<td>R1</td>
</tr>
<tr>
<td>SP+0x08</td>
<td>R2</td>
</tr>
<tr>
<td>SP+0x0C</td>
<td>R3</td>
</tr>
<tr>
<td>SP+0x10</td>
<td>R12</td>
</tr>
<tr>
<td>SP+0x14</td>
<td>LR</td>
</tr>
<tr>
<td>SP+0x18</td>
<td>PC</td>
</tr>
<tr>
<td>SP+0x1C</td>
<td>xPSR</td>
</tr>
<tr>
<td>SP+0x20</td>
<td>xxx &lt;- SP before exception</td>
</tr>
</tbody></table>
<p>完成後接著會開始執行exception handler，並且把EXC_RETURN寫入LR。</p>
<h3 id="Exception-Return"><a href="#Exception-Return" class="headerlink" title="Exception Return"></a>Exception Return</h3><p>要從exception跳還必須要符合兩個條件：</p>
<ol>
<li>目前正在Handler Mode。</li>
<li>PC的值是合法的EXC_RETURN。</li>
</ol>
<p>關於EXC_RETURN的值，其實代表了ARM從handler mode回去的路徑，有三種可能：</p>
<ol>
<li>目前是nested exception，回去上層還是handler mode。</li>
<li>是由privileged thread mode呼叫的，也就是要回到state2。</li>
<li>是由unprivileged thread mode呼叫的，也就是要回到state3。</li>
</ol>
<p>因此EXC_RETURN有三個可能的值</p>
<table>
<thead>
<tr>
<th>EXC_RETURN</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0xFFFFFFF1</td>
<td>Return to Handler mode.<br>Exception return gets state from the main stack.<br>Execution uses MSP after return.</td>
</tr>
<tr>
<td>0xFFFFFFF9</td>
<td>Return to Thread mode.<br>Exception Return get state from the main stack.<br>Execution uses MSP after return.</td>
</tr>
<tr>
<td>0xFFFFFFFD</td>
<td>Return to Thread mode.<br>Exception return gets state from the process stack.<br>Execution uses PSP after return.</td>
</tr>
</tbody></table>
<h3 id="Privileged-to-Unprivileged"><a href="#Privileged-to-Unprivileged" class="headerlink" title="Privileged to Unprivileged"></a>Privileged to Unprivileged</h3><p>接著我們要來探討怎麼從Privileged進入Unprivileged，也就是state2進入state3的部分。</p>
<p>如果要進入Unprivileged，那必須使用到特殊register - control。</p>
<table>
<thead>
<tr>
<th>bit</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>CONTROL[1]</td>
<td>0：Use MSP, 1: Use PSP</td>
</tr>
<tr>
<td>CONTROL[0]</td>
<td>0：Privileged thread mode, 1：Unprivileged thread mode</td>
</tr>
</tbody></table>
<p>要特別注意操作control register一定要用MRS和MSR register</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CONTROL值搬到R0</span><br><span class="line">MRS R0, CONTROL</span><br><span class="line"># R0的值放入CONTROL</span><br><span class="line">MSR CONTROL, R0</span><br></pre></td></tr></table></figure>

<p>進入Unprivileged Thread Mode的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R0, 3</span><br><span class="line">MSR CONTROL, R0</span><br></pre></td></tr></table></figure>

<h2 id="ARM在切換上面的設計"><a href="#ARM在切換上面的設計" class="headerlink" title="ARM在切換上面的設計"></a>ARM在切換上面的設計</h2><p>ARM在處理nested exception上有自己的一套做法來加快速度，確保高優先權的exception能更快被執行到，達到更高的即時性(real-time)。</p>
<p>下面介紹兩種在Cortex M上面的機制：</p>
<ul>
<li>tail-chained：<ul>
<li>情況：如果發生exception1的時候又發生exception2，但是exception2的優先權沒有高於exception1，必須等待。</li>
<li>原本：一般來說exception1結束的時候會先pop stack，然後再push stack進入處理exception2。</li>
<li>改進：exception1到exception2中間的pop&amp;push其實是沒意義的，所以ARM Cortex M會在exception1結束後直接執行exception2，減少了中間的浪費。</li>
</ul>
</li>
<li>late-arriving<ul>
<li>情況：如果發生exception1並且執行state saving(上面說的push register)，這時候有更高優先權的exception2進來，發生preempts。</li>
<li>原本：會中斷exception1的state saving，優先讓給exception2。</li>
<li>改進：exception2其實也是需要state saving，所以繼續維持state saving，然後直接執行exception2。當exception2結束後，就又可以使用tail-chained的模式來執行exception1。</li>
</ul>
</li>
</ul>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p>關於Cortex M相關的資料非常推薦下面兩本書籍，都有中文的翻譯。JosephYiu有參與ARM Cortex M的設計，比較有權威性。</p>
<ul>
<li><a href="https://www.books.com.tw/products/CN11146482">ARM Cortex-M3權威指南</a></li>
<li><a href="https://www.tenlong.com.tw/products/9787302402923">ARM Cortex-M3與Cortex-M4權威指南, 3&#x2F;e ARM Cortex-M3与Cortex-M4权威指南</a></li>
</ul>
<p>可參考jserv老師和學生撰寫的rtenv+簡介，裡面也有提到ARM CM3權限的部分。</p>
<ul>
<li><a href="http://wiki.csie.ncku.edu.tw/embedded/rtenv">rtenv+</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>C語言的行內組譯</title>
    <url>/2018/05/20/C-Inline-Assembly/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>有時候我們會在C的程式碼內看到<code>asm&#123;...&#125;</code>的結構，這代表的是行內組譯的概念，也就是在C語言中為了效率等目的直接要求compiler加入我們所指定組合語言。</p>
<p>舉個最簡單的範例，如果我們要求加入nop的指令，那就會變成如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 一個nop指令 */</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;nop&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多行要用\n隔開 */</span></span><br><span class="line">__asm__(<span class="string">&quot;nop\n&quot;</span></span><br><span class="line">        <span class="string">&quot;nop\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不管是<code>asm</code>還是<code>__asm__</code>都是合法的，只要不要跟自己的symbol有衝突即可。</p>
<p>聰明的你可能發覺一件事，剛剛的例子只有指令而已，那如果假設我們要跟自己設定的變數互動那要怎麼辦呢？這時候就要用比較複雜的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm ( assembler template               /* 組合語言內容 */</span><br><span class="line">    : output operands                  /* 輸出的參數 */</span><br><span class="line">    : input operands                   /* 輸入的參數 */</span><br><span class="line">    : list of clobbered registers      /* 組合語言執行後會改變的項目 */</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>我們還是直接來看看程式比較有感覺</p>
<h3 id="範例一"><a href="#範例一" class="headerlink" title="範例一"></a>範例一</h3><p>我們寫一個簡單的test.c，只負責做加法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum, num1, num2;</span><br><span class="line">    num1 = <span class="number">1</span>;</span><br><span class="line">    num2 = <span class="number">2</span>;</span><br><span class="line">    sum = num1 + num2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\r\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>編譯並且看一下組語的內容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc test.c -s test.s</span><br><span class="line">$ <span class="built_in">cat</span> test.s</span><br><span class="line">        .file   <span class="string">&quot;test.c&quot;</span></span><br><span class="line">        .text</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string <span class="string">&quot;sum=%d\r\n&quot;</span></span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .<span class="built_in">type</span>   main, @<span class="keyword">function</span></span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        subq    <span class="variable">$16</span>, %rsp</span><br><span class="line">        movl    <span class="variable">$1</span>, -4(%rbp)</span><br><span class="line">        movl    <span class="variable">$2</span>, -8(%rbp)</span><br><span class="line">        movl    -4(%rbp), %edx</span><br><span class="line">        movl    -8(%rbp), %eax</span><br><span class="line">        addl    %edx, %eax</span><br><span class="line">        movl    %eax, -12(%rbp)</span><br><span class="line">        movl    -12(%rbp), %eax</span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        movl    $.LC0, %edi</span><br><span class="line">        movl    <span class="variable">$0</span>, %eax</span><br><span class="line">        call    <span class="built_in">printf</span></span><br><span class="line">        movl    <span class="variable">$0</span>, %eax</span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  <span class="string">&quot;GCC: (GNU) 8.1.0&quot;</span></span><br><span class="line">        .section        .note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br></pre></td></tr></table></figure>

<p>先不管其他細節，可以看到中間有兩行<code>addl    %edx, %eax</code>和<code>movl    %eax, -12(%rbp)</code>，對應的也就是<code>sum = num1 + num2;</code>，那我們來改寫一下吧！</p>
<p>test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum, num1, num2;</span><br><span class="line">    num1 = <span class="number">1</span>;</span><br><span class="line">    num2 = <span class="number">2</span>;</span><br><span class="line">    sum = num1 + num2;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;addl    %%edx, %%eax\n&quot;</span></span><br><span class="line">        :<span class="string">&quot;=a&quot;</span>(sum)</span><br><span class="line">        :<span class="string">&quot;a&quot;</span>(num1), <span class="string">&quot;d&quot;</span>(num2)</span><br><span class="line">       );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\r\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>編譯並執行後就會發現結果是一樣的。不過到這邊我想大部分的人心中一定充滿了三個小朋友，所以還是在稍微解釋一下。</p>
<p>如前面所提，我們最主要執行的是<code>addl    %%edx, %%eax\n</code>，這邊跟前面不一樣的是%另有用途(後面會提)，所以要表示暫存器%eax時，我們要用%%來取代%字元。<br>然後第二行的<code>&quot;=a&quot;(sum)</code>中，<code>=</code>代表執行結束後我們要把某個值填到某個變數內(這邊指的就是括號中的sum)，可是某個值又是怎麼決定的呢？這個就是a的概念，也就是「規範條件」，要求編譯器只能對應到符合條件的register。</p>
<p>如果以x86的架構為例(這邊要注意每個CPU架構的規範條件都不同)：</p>
<table>
<thead>
<tr>
<th>規範條件</th>
<th>Register(s)</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>%eax, %ax, %al</td>
</tr>
<tr>
<td>b</td>
<td>%ebx, %bx, %bl</td>
</tr>
<tr>
<td>c</td>
<td>%ecx, %cx, %cl</td>
</tr>
<tr>
<td>d</td>
<td>%edx, %dx, %dl</td>
</tr>
<tr>
<td>S</td>
<td>%esi, %si</td>
</tr>
<tr>
<td>D</td>
<td>%edi, %di</td>
</tr>
<tr>
<td>f</td>
<td>fp</td>
</tr>
</tbody></table>
<p>由此可知就是要把%eax的結果填入sum中。同理，第三行的input部分<code>&quot;a&quot;(num1), &quot;d&quot;(num2)</code>分別也代表在執行組合語言前為num1和num2選擇register(這邊的例子是num1填入%eax、num2填入%edx)。</p>
<p>回頭看一下如果編成組合語言會是什麼樣子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        movl    $1, -4(%rbp)</span><br><span class="line">        movl    $2, -8(%rbp)</span><br><span class="line">        movl    -4(%rbp), %eax</span><br><span class="line">        movl    -8(%rbp), %edx</span><br><span class="line">#APP</span><br><span class="line"># 8 &quot;test.c&quot; 1</span><br><span class="line">        addl    %edx, %eax</span><br><span class="line"></span><br><span class="line"># 0 &quot;&quot; 2</span><br><span class="line">#NO_APP</span><br><span class="line">        movl    %eax, -12(%rbp)</span><br><span class="line">        movl    -12(%rbp), %eax</span><br><span class="line">        movl    %eax, %esi</span><br><span class="line">        movl    $.LC0, %edi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    printf</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>在#APP和#NO_APP間就是我們的組語部分，看起來蠻符合我們的預期。</p>
<h3 id="範例二"><a href="#範例二" class="headerlink" title="範例二"></a>範例二</h3><p>可是我們難道都一定要自行決定register嗎？我們想要交由compiler決定。這時候其實可以用比較寬鬆的限制條件。一樣是x86的架構才能用：</p>
<table>
<thead>
<tr>
<th>規範條件</th>
<th>Register(s)</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>%eax, %ebx, %ecx, %edx, %esi, %edi</td>
</tr>
<tr>
<td>q</td>
<td>%eax, %ebx, %ecx, %edx</td>
</tr>
<tr>
<td>0,1,2..</td>
<td>%0, %1, %2…(代表第幾個參數)</td>
</tr>
</tbody></table>
<p>那就修改程式吧！</p>
<p>test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;addl    %2, %0\n&quot;</span></span><br><span class="line">        :<span class="string">&quot;=r&quot;</span>(sum)</span><br><span class="line">        :<span class="string">&quot;0&quot;</span>(num1), <span class="string">&quot;r&quot;</span>(num2)</span><br><span class="line">       );</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在這裡，我們input使用sum和num2使用<code>r</code>，代表交由compiler決定要用哪個register。但是num1為什麼是0呢？這個意思是我們要num1的值所放入的register要跟sum同樣。<br>0,1,2分別代表我們所決定的register順序，也就是%0&#x3D;&gt;之後要輸出到sum的register，%1&#x3D;&gt;num1放入的register，%2&#x3D;&gt;num2放入的register。</p>
<p>當然最後執行結果也會和範例一一樣。</p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="http://www.books.com.tw/products/0010587783">BINARY HACKS：駭客秘傳技巧一百招</a></li>
<li><a href="http://sp1.wikidot.com/gnuinlineassembly">在 C 語言當中內嵌 GNU 的組合語言</a></li>
<li><a href="http://wen00072.github.io/blog/2015/12/10/about-inline-asm/">關於GNU Inline Assembly</a></li>
<li><a href="http://www.ethernut.de/en/documents/arm-inline-asm.html">ARM GCC Inline Assembler Cookbook</a></li>
<li><a href="https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC-Inline-Assembly-HOWTO</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>程式語言</tag>
        <tag>C</tag>
        <tag>GNU tool</tag>
      </tags>
  </entry>
  <entry>
    <title>關於ELF的兩三事</title>
    <url>/2018/05/06/ELF-format/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>程式設計師很大的機率是脫離不了Linux，而如果我們要在Linux上compile，大概一定會接觸到ELF這個格式。底下來簡單介紹一下ELF的格式是什麼，我們要怎麼從它獲得資訊。</p>
<p>ELF全名是Executable and Linking Format，在Linux中是編譯後的binary、object檔規範，也就是說我們從source code編譯後產生的檔案格式就是ELF了。</p>
<p>ELF的格式可以從兩種角度來看，第一種是Link的時候，第二種是執行的時候。兩者都一樣會有ELF header，但是底下的組成概念就完全不一樣。</p>
<p>Link的時候：</p>
<table>
<thead>
<tr>
<th>ELF header</th>
</tr>
</thead>
<tbody><tr>
<td>Program Header Table(Optional)</td>
</tr>
<tr>
<td>Section 1</td>
</tr>
<tr>
<td>Section 2</td>
</tr>
<tr>
<td>…</td>
</tr>
<tr>
<td>Section N</td>
</tr>
<tr>
<td>Section Header Table</td>
</tr>
</tbody></table>
<p>執行的時候：</p>
<table>
<thead>
<tr>
<th>ELF header</th>
</tr>
</thead>
<tbody><tr>
<td>Program Header Table</td>
</tr>
<tr>
<td>Segment 1</td>
</tr>
<tr>
<td>Segment 2</td>
</tr>
<tr>
<td>…</td>
</tr>
<tr>
<td>Segment N</td>
</tr>
<tr>
<td>Section Header Table(Optional)</td>
</tr>
</tbody></table>
<p>兩者最大的差異是Link的時候是以Section為觀點，用Section Header Table來當索引，指向各個Section。執行的時候則是用Segment為觀點，一個Segment可能是多個Section所組成，然後再用Program Header Table指向各個Segment。</p>
<h2 id="觀察ELF的方法"><a href="#觀察ELF的方法" class="headerlink" title="觀察ELF的方法"></a>觀察ELF的方法</h2><p>那要如何觀察ELF呢？如果你嘗試用記事本打開應該只會看到一團不知所云的亂碼，所以我們底下會透過各種工具的使用教學來解釋ELF格式。</p>
<h3 id="查看執行檔-od"><a href="#查看執行檔-od" class="headerlink" title="查看執行檔 - od"></a>查看執行檔 - od</h3><p>首先我們可以試著使用od這個指令來看檔案內容。od全名是octal dump，顧名思義就是用八進制來印內容，但他並不僅僅如此而已。</p>
<p>od指令的格式：<code>od -t [顯示格式] -A [偏移量使用的基數] [filename]</code></p>
<ul>
<li>-t：後面可接型態(d, o, x…)、一次顯示的byte數(數字)、是否顯示ASCII code(z)</li>
<li>-A：偏移量有(d, o, x, n)，n代表不顯示偏移量</li>
<li>-v：不省略重複的內容</li>
</ul>
<p>我們最常用格式：</p>
<ul>
<li><code>od -t x1 -A x [filename]</code>：代表用16進制來顯示檔案，偏移量是16的倍數</li>
<li><code>od -t x1z -A x [filename]</code>：同上，但是多加上顯示ASCII code</li>
</ul>
<p>那我們來看看ELF檔長什麼樣子，這邊以大家最常用的ls為例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">od</span> -t x1z -A x /bin/ls | less</span><br><span class="line">000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  &gt;.ELF............&lt;</span><br><span class="line">000010 02 00 3e 00 01 00 00 00 90 48 40 00 00 00 00 00  &gt;..&gt;......H@.....&lt;</span><br><span class="line">000020 40 00 00 00 00 00 00 00 00 a7 01 00 00 00 00 00  &gt;@...............&lt;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>可以看到前面有個<code>7f 45 4c 46</code>開頭，ASCII是<code>.ELF</code>(.代表非可見字元，這邊是0x7f也就是\177)，這個就是傳說中的ELF magic code了。不過這邊先停一下，如果我們要繼續用hex來看其實有點累，所以先換個工具來試試吧！</p>
<h3 id="使用readelf來觀察ELF資訊"><a href="#使用readelf來觀察ELF資訊" class="headerlink" title="使用readelf來觀察ELF資訊"></a>使用readelf來觀察ELF資訊</h3><p>readelf很明顯就是觀察ELF檔案的專門工具，使用方式如下</p>
<ul>
<li>格式：<code>readelf [選項] [filename]</code></li>
<li>讀取標頭選項<ul>
<li>-h：印 ELF header</li>
<li>-l：印 Program Header Table</li>
<li>-S：印 Section Header Table</li>
<li>-e：三者都印</li>
</ul>
</li>
<li>讀取資訊選項<ul>
<li>-s：符號表</li>
<li>-r：重定位資訊</li>
</ul>
</li>
<li>特別用法：<ul>
<li>-a：所有標頭資訊全部印出</li>
<li>-xn：先用-S看要查看的Section數字，然後n填上該數字就可以hexdump那個section</li>
</ul>
</li>
</ul>
<p>那我們來看看ls的ELF header長什麼樣。從下面可以看到，除了剛剛看到的Magic code外，還有版本、適用哪個OS&#x2F;ABI、在哪個機器平台運行、entry point adddress等等。</p>
<p>值得注意的是這邊有紀錄Program Header、Section Header的開始位址、大小、數量，所以我們可以用這個資訊找到Program&#x2F;Section Header。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -h /bin/ls</span><br><span class="line">ELF 檔頭：</span><br><span class="line">  魔術位元組：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  類別:                              ELF64</span><br><span class="line">  資料:                              2 的補數，小尾序(little endian)</span><br><span class="line">  版本:                              1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  類型:                              EXEC (可執行檔案)</span><br><span class="line">  系統架構:                          Advanced Micro Devices X86-64</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  進入點位址：               0x404890</span><br><span class="line">  程式標頭起點：          64 (檔案內之位元組)</span><br><span class="line">  區段標頭起點：          108288 (檔案內之位元組)</span><br><span class="line">  旗標：             0x0</span><br><span class="line">  此標頭的大小：       64 (位元組)</span><br><span class="line">  程式標頭大小：       56 (位元組)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  區段標頭大小：         64 (位元組)</span><br><span class="line">  區段標頭數量：         28</span><br><span class="line">  字串表索引區段標頭： 27</span><br></pre></td></tr></table></figure>

<p>而Program Header的部分，我們可以看到有9個Segement，以及實際的位址在哪。另外有個「區段到節區映射中」(Section to Segment mapping)，這就是多個Section如何組成一個Segment的對應。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -l /bin/ls</span><br><span class="line">Elf 檔案類型為 EXEC (可執行檔案)</span><br><span class="line">進入點 0x404890</span><br><span class="line">共有 9 個程式標頭，開始於偏移量 64</span><br><span class="line"></span><br><span class="line">程式標頭：</span><br><span class="line">  類型           偏移量             虛擬位址           實體位址</span><br><span class="line">                 檔案大小          記憶大小              旗標   對齊</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040</span><br><span class="line">                 0x00000000000001f8 0x00000000000001f8  R E    8</span><br><span class="line">  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238</span><br><span class="line">                 0x000000000000001c 0x000000000000001c  R      1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000019d44 0x0000000000019d44  R E    200000</span><br><span class="line">  LOAD           0x0000000000019df0 0x0000000000619df0 0x0000000000619df0</span><br><span class="line">                 0x0000000000000804 0x0000000000001570  RW     200000</span><br><span class="line">  DYNAMIC        0x0000000000019e08 0x0000000000619e08 0x0000000000619e08</span><br><span class="line">                 0x00000000000001f0 0x00000000000001f0  RW     8</span><br><span class="line">  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      4</span><br><span class="line">  GNU_EH_FRAME   0x000000000001701c 0x000000000041701c 0x000000000041701c</span><br><span class="line">                 0x000000000000072c 0x000000000000072c  R      4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     10</span><br><span class="line">  GNU_RELRO      0x0000000000019df0 0x0000000000619df0 0x0000000000619df0</span><br><span class="line">                 0x0000000000000210 0x0000000000000210  R      1</span><br><span class="line"></span><br><span class="line"> 區段到節區映射中:</span><br><span class="line">  節區段...</span><br><span class="line">   00</span><br><span class="line">   01     .interp</span><br><span class="line">   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gn                                   u.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_                                   frame_hdr .eh_frame</span><br><span class="line">   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss</span><br><span class="line">   04     .dynamic</span><br><span class="line">   05     .note.ABI-tag .note.gnu.build-id</span><br><span class="line">   06     .eh_frame_hdr</span><br><span class="line">   07</span><br><span class="line">   08     .init_array .fini_array .jcr .dynamic .got</span><br></pre></td></tr></table></figure>

<p>Section Header的話會仔細列出這個ELF所包含的所有Section以及位址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -S /bin/ls</span><br><span class="line"></span><br><span class="line">共有 28 個區段標頭，從偏移量 0x1a700 開始：</span><br><span class="line"></span><br><span class="line">區段標頭：</span><br><span class="line">  [號] 名稱              類型             位址              偏移量</span><br><span class="line">       大小              全體大小         旗標   連結  資訊  對齊</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000400238  00000238</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             0000000000400254  00000254</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             0000000000400274  00000274</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298</span><br><span class="line">       0000000000000068  0000000000000000   A       5     0     8</span><br><span class="line">...</span><br><span class="line">  [24] .data             PROGBITS         000000000061a3a0  0001a3a0</span><br><span class="line">       0000000000000254  0000000000000000  WA       0     0     32</span><br><span class="line">  [25] .bss              NOBITS           000000000061a600  0001a5f4</span><br><span class="line">       0000000000000d60  0000000000000000  WA       0     0     32</span><br><span class="line">  [26] .gnu_debuglink    PROGBITS         0000000000000000  0001a5f4</span><br><span class="line">       0000000000000008  0000000000000000           0     0     1</span><br><span class="line">  [27] .shstrtab         STRTAB           0000000000000000  0001a5fc</span><br><span class="line">       00000000000000fe  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (<span class="built_in">link</span> order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure>

<h3 id="objdump取得ELF內容"><a href="#objdump取得ELF內容" class="headerlink" title="objdump取得ELF內容"></a>objdump取得ELF內容</h3><p>除了看ELF內的資訊外，我們可以進一步得到更細的資訊，包括dump內容和反組譯程式，這時候就要用objdump了</p>
<ul>
<li><code>objdump -s -j [section] [filename]</code>：把特定section完整dump出來</li>
<li><code>objdump -h [filename]</code>：看有哪些section，跟readelf功用類似</li>
<li><code>objdump -x [filename]</code>：把所有section都顯示出來</li>
<li><code>objdump -d [filename]</code>：反組譯程式</li>
<li><code>objdump -d -S [filename]</code>：反組譯程式加上行數</li>
<li><code>objdump -d -l [filename]</code>：反組譯程式加上source code</li>
</ul>
<p>同樣以ls為例，可以看到我們把text section的內容印出來了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -s -j .text /bin/ls</span><br><span class="line"></span><br><span class="line">/bin/ls：     檔案格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 4028a0 50b9882c 4100baa6 0e0000be 36374100  P..,A.......67A.</span><br><span class="line"> 4028b0 bf983c41 00e896fb ffff660f 1f440000  ..&lt;A......f..D..</span><br><span class="line"> 4028c0 41574156 41554154 554889f5 5389fb48  AWAVAUATUH..S..H</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h3 id="objcopy-strip修改ELF檔案"><a href="#objcopy-strip修改ELF檔案" class="headerlink" title="objcopy&#x2F;strip修改ELF檔案"></a>objcopy&#x2F;strip修改ELF檔案</h3><p>objcopy最主要的功能就是可以把文件作轉換，一部份或全部的內容copy另一個文件中</p>
<ul>
<li><code>objcopy -S -R .comment -R .note [input filename] [output filename]</code>：把編譯出來的symbol移除不必要的section(-S代表去掉symbol, relocation的訊息)</li>
<li><code>objcopy -O binary -j [section] [input filename] [output filename]</code>：也可以把某個section拿出來</li>
</ul>
<p>關於移除不必要的section部分，其實strip就可以做到了，只要用<code>strip [filename]</code>即可。</p>
<h4 id="objcopy進階用法"><a href="#objcopy進階用法" class="headerlink" title="objcopy進階用法"></a>objcopy進階用法</h4><p>objcopy可以做到把檔案變成ELF格式，提供給我們linking，這樣我們就可以避免檔案的讀取。</p>
<p>這邊用個簡單的範例，假設我們想要把某個文字檔包在程式內部(其實可以用圖片比較有感覺，只是我不想寫太複雜的程式)</p>
<p>先創立text.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is test txt.</span><br></pre></td></tr></table></figure>

<p>然後把text.txt變成object file</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objcopy -I binary -O elf64-x86-64 -B i386:x86-64 text.txt text.o</span><br></pre></td></tr></table></figure>

<p>如果這時候show object資訊的話</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -x text.o</span><br><span class="line"></span><br><span class="line">text.o：     檔案格式 elf64-x86-64</span><br><span class="line">text.o</span><br><span class="line">系統架構：i386:x86-64， 旗標 0x00000010：</span><br><span class="line">HAS_SYMS</span><br><span class="line">起始位址 0x0000000000000000</span><br><span class="line"></span><br><span class="line">區段：</span><br><span class="line">索引名稱          大小      VMA               LMA               檔案關閉 對齊</span><br><span class="line">  0 .data         00000012  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    d  .data  0000000000000000 .data</span><br><span class="line">0000000000000000 g       .data  0000000000000000 _binary_test_txt_start</span><br><span class="line">0000000000000012 g       .data  0000000000000000 _binary_test_txt_end</span><br><span class="line">0000000000000012 g       *ABS*  0000000000000000 _binary_test_txt_size</span><br></pre></td></tr></table></figure>

<p>symsymbola把下面那些symbol放入test.c內，即可使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _binary_text_txt_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _binary_text_txt_end[];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _binary_text_txt_size[];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr = _binary_text_txt_start;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;text.txt=%s\r\n&quot;</span>, ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>編譯並執行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc test.o test.o -o a.out</span><br><span class="line">% ./a.out</span><br><span class="line">text.txt=This is <span class="built_in">test</span> txt.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="nm觀察symbol"><a href="#nm觀察symbol" class="headerlink" title="nm觀察symbol"></a>nm觀察symbol</h3><p>剛剛提了那麼多都是以ELF內的各種section為主，但是我們實際開發程式其實還是比較重視symbol，那我們有簡單方式可以看symbol嗎？這時候就要用到nm了。</p>
<ul>
<li><code>nm [filename]</code>：可以顯示symbol的數值、型態、名稱</li>
<li><code>nm --size-sort -r -S [filename]</code>：由大到小顯示symbol的數值、大小、型態、名稱</li>
</ul>
<p>舉個例子，我們可以看到下面執行結果symbol由大到小排序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nm --size-sort -r -S <span class="built_in">test</span></span><br><span class="line">00008464 00000064 T __libc_csu_init</span><br><span class="line">00008444 00000020 T main</span><br><span class="line">000084c8 00000004 T __libc_csu_fini</span><br><span class="line">000084d4 00000004 R _IO_stdin_used</span><br><span class="line">00011028 00000001 b completed.9228</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>關於常見型態的部分可參考下表：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>類型(大寫代表global、小寫是local)</th>
</tr>
</thead>
<tbody><tr>
<td>text section</td>
<td>T&#x2F;t</td>
</tr>
<tr>
<td>data section</td>
<td>D&#x2F;d</td>
</tr>
<tr>
<td>Read only</td>
<td>R&#x2F;r</td>
</tr>
<tr>
<td>BSS</td>
<td>B&#x2F;b</td>
</tr>
<tr>
<td>未定義(如extern)</td>
<td>U</td>
</tr>
</tbody></table>
<h2 id="addr2line從位址轉成symbol"><a href="#addr2line從位址轉成symbol" class="headerlink" title="addr2line從位址轉成symbol"></a>addr2line從位址轉成symbol</h2><p>有時候我們執行程式會只知道位址，但是想要從位址得到到底是在程式哪行掛掉</p>
<ul>
<li><code>addr2line -f -e [filename] [address]</code>：-f代表要顯示是哪個function，-e代表address是來自該執行檔</li>
</ul>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>本篇文章主要簡單介紹ELF的結構，然後我們可以用 od、readelf、objdump、objcopy&#x2F;strip、nm, addr2line 幾個工具觀察ELF的格式。如果想要有進一步的認識，建議可以研究參考的連結。</p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="http://www.books.com.tw/products/0010587783">BINARY HACKS：駭客秘傳技巧一百招</a></li>
<li><a href="http://ccckmit.wikidot.com/lk:elf">陳鍾誠的網站 - 目的檔格式 (ELF)</a></li>
<li><a href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf">ELF 格式解析</a></li>
<li><a href="https://blog.csdn.net/xzongyuan/article/details/21082959">objcopy给目标文件设计一个段</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
        <tag>系統程式</tag>
      </tags>
  </entry>
  <entry>
    <title>GnuPG教學</title>
    <url>/2018/10/14/GnuPG%E6%95%99%E5%AD%B8/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>GPG全名為Gnu Privacy Guard(GnuPG) ，最初的目的是為了加密通訊的加密軟體，是為了替代PGP並符合GPL而產生的。目前很多自由軟體社群要驗證身份也都會需要用到這套工具。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><ul>
<li>指令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install gnupg</span><br><span class="line"><span class="comment"># MAX</span></span><br><span class="line">brew install gnupg</span><br></pre></td></tr></table></figure>

<ul>
<li>GUI<ul>
<li>其實現在GUI介面都做得很好看了，而且也很容易上手，建議可以用GUI的tools。</li>
<li>MAC的GUI tools可從<a href="https://gpgtools.org/gpgsuite.html">gpgtools.org</a>安裝</li>
</ul>
</li>
</ul>
<h3 id="建立key"><a href="#建立key" class="headerlink" title="建立key"></a>建立key</h3><ol>
<li><p>先產生key</p>
<ul>
<li>可選擇”RSA &amp; RSA”，key長度為4096</li>
<li>真實姓名就填自己的英文名字，備註可填中文</li>
<li>產生的key會放在<code>~/.gnupg</code>這個目錄下</li>
<li>記得要輸入密碼，防止別人入侵系統時可以直接拿到私鑰</li>
<li>最後會產生出user ID的hash(UID)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --full-generate-key</span><br><span class="line"><span class="comment"># 如果gen key發生問題，可用如下指令後再一次</span></span><br><span class="line">gpgconf --<span class="built_in">kill</span> gpg-agent</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下來就是產生撤銷憑證，未來忘記密碼可以用來撤銷，因此要小心保管</p>
<ul>
<li>注意如果key有填utf-8，這步在MAC可能會出問題，不過如果是用GUI卻沒問題，原因並不清楚。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg -o revocation.crt --gen-revoke [UID]</span><br><span class="line"><span class="comment"># 也可以直接放到.gnupg內</span></span><br><span class="line">gpg --gen-revoke [UID] &gt; ~/.gnupg/revocation-[UID].crt</span><br></pre></td></tr></table></figure>
</li>
<li><p>釋出公鑰，這個公鑰可以傳給朋友，或是上傳到server</p>
<ul>
<li>-a：代表匯出明碼</li>
<li>-o：代表輸出檔名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg -ao mypublic.asc --<span class="built_in">export</span> [UID]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是要把朋友的公鑰放入已知道人的清單</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --import friends.asc</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以用fingerprint顯示自已的公鑰後，弄到pdf上印出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg -v --fingerprint [UID]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="管理key"><a href="#管理key" class="headerlink" title="管理key"></a>管理key</h3><h4 id="查看、編輯與刪除key"><a href="#查看、編輯與刪除key" class="headerlink" title="查看、編輯與刪除key"></a>查看、編輯與刪除key</h4><ol>
<li><p>查看目前的鑰匙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有公鑰</span></span><br><span class="line">gpg --list-keys</span><br><span class="line"><span class="comment"># 同時看簽名</span></span><br><span class="line">gpg --list-sigs</span><br><span class="line"><span class="comment"># 列出所有私鑰</span></span><br><span class="line">gpg --list-secret-keys</span><br></pre></td></tr></table></figure>
</li>
<li><p>編輯key(對key簽名也是用同樣的方法)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --edit-key [UID]</span><br></pre></td></tr></table></figure>
</li>
<li><p>刪除已存入key的方式，如果有私鑰要先刪除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先刪除私鑰</span></span><br><span class="line">gpg --delete-secret-key [UID]</span><br><span class="line"><span class="comment"># 刪除公鑰</span></span><br><span class="line">gpg --delete-key [UID]</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="搜尋"><a href="#搜尋" class="headerlink" title="搜尋"></a>搜尋</h4><ol>
<li><p>首先先搜尋對象的public key</p>
<ul>
<li>這裡指定的key server是用MIT的，可以找其他也有公信力的Server，可參考<a href="https://en.wikipedia.org/wiki/Key_server_(cryptographic)">wiki</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --keyserver hkp://pgp.mit.edu --search-keys <span class="string">&#x27;Linus Torvalds&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>得到對方的public key後，將其存入<code>~/.gnupg/pubring.gpg</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --keyserver hkp://pgp.mit.edu --recv-keys 79BE3E4300411886</span><br></pre></td></tr></table></figure>
</li>
<li><p>可查看與更新朋友的public key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --list-keys</span><br><span class="line">gpg --refresh-keys</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="import-export"><a href="#import-export" class="headerlink" title="import&#x2F;export"></a>import&#x2F;export</h4><ol>
<li><p>除了搜尋以外，也可以用import&#x2F;export的方式管理朋友的公鑰</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --import public_keys_list.txt</span><br><span class="line">gpg --<span class="built_in">export</span> -ao public_keys_list.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>import&#x2F;export自己的金鑰</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># export 公鑰</span></span><br><span class="line">gpg --armor --output public-key.asc --<span class="built_in">export</span> [UID]</span><br><span class="line"><span class="comment"># export 私鑰</span></span><br><span class="line">gpg --armor --output private-key.asc --export-secret-keys [UID]</span><br><span class="line"><span class="comment"># import</span></span><br><span class="line">gpg --import [金鑰]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="用key傳送接收信件"><a href="#用key傳送接收信件" class="headerlink" title="用key傳送接收信件"></a>用key傳送接收信件</h3><ol>
<li><p>假設我們要傳送secret.tgz給朋友，可以先進行加密</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg -ear 朋友 &lt; secret.tgz &gt; secret.tgz.asc</span><br></pre></td></tr></table></figure>
</li>
<li><p>朋友收到secret.tgz.asc後可用如下指令變回secret.tgz</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg -d &lt; secret.tgz.asc &gt; secret.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果要確認發信人身份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先對檔案簽名</span></span><br><span class="line">gpg --clearsign file.txt</span><br><span class="line"><span class="comment"># 驗證檔案身份</span></span><br><span class="line">gpg --verify &lt; file.txt.asc</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://newtoypia.blogspot.com/2013/12/gnupg-pgp.html">使用 GnuPG 建立你的 PGP 金鑰， 讓別人能夠私密寄信給你</a></li>
<li><a href="https://wiki.debian.org/Keysigning">Debian關於Keysigning的教學</a></li>
<li><a href="https://wiki.archlinux.org/index.php/GnuPG_(%E6%AD%A3%E9%AB%94%E4%B8%AD%E6%96%87)">GnuPG (正體中文)-GnuPG</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html">GPG入门教程-阮一峰</a></li>
<li><a href="http://egret-bunjinw.blogspot.com/2013/08/gpg.html">gpg 數位簽章</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP header 安全設定</title>
    <url>/2018/01/03/HTTP-header-%E5%AE%89%E5%85%A8%E8%A8%AD%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="總覽"><a href="#總覽" class="headerlink" title="總覽"></a>總覽</h2><p>根據<a href="https://devco.re/blog/2014/03/10/security-issues-of-http-headers-1/">DEVCORE</a>，相關HTTP header可以如下分類</p>
<ul>
<li>防禦 XSS：<ul>
<li>Content-Security-Policy</li>
<li>Set-Cookie: HttpOnly</li>
<li>X-XSS-Protection</li>
<li>X-Download-Options</li>
</ul>
</li>
<li>防禦 Clickjacking：<ul>
<li>X-Frame-Options</li>
</ul>
</li>
<li>強化 HTTPS 機制：<ul>
<li>Set-Cookie: Secure</li>
<li>Strict-Transport-Security</li>
</ul>
</li>
<li>避免瀏覽器誤判文件形態：<ul>
<li>X-Content-Type-Options</li>
</ul>
</li>
<li>保護網站資源別被任意存取：<ul>
<li>Access-Control-Allow-Origin</li>
<li>X-Permitted-Cross-Domain-Policies</li>
</ul>
</li>
</ul>
<h2 id="防禦-XSS"><a href="#防禦-XSS" class="headerlink" title="防禦 XSS"></a>防禦 XSS</h2><h3 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content-Security-Policy"></a>Content-Security-Policy</h3><ul>
<li><p>原理：</p>
<ul>
<li>用來控制不要讀取外部不可信賴資源，可以防止XSS或injection</li>
</ul>
</li>
<li><p>啟動方式：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: policy # policy代表描述你的CSP的策略</span><br></pre></td></tr></table></figure>

<ul>
<li>範例</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 所有內容都來自同一個地方</span><br><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;</span><br><span class="line"># 比較複雜的設定，不擋image來源，但是設定media和script的來源，注意後方設定會蓋掉default-src的設定</span><br><span class="line">Content-SecContent-Security-Policy: default-src &#x27;self&#x27;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</span><br><span class="line"># 推薦設定：因為預設會擋html裡有js,style，但是大部分都會用到，所以要加上unsafe-inline</span><br><span class="line">Content-Security-Policy: default-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可參考</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/Using_Content_Security_Policy">内容安全策略( CSP )</a>: 對CSP的基本解說</li>
<li><a href="https://devco.re/blog/2014/04/08/security-issues-of-http-headers-2-content-security-policy/">Content-Security-Policy - HTTP Headers 的資安議題 (2)</a>: 對CSP非常詳細的解說，建議一定要看一下。</li>
</ul>
</li>
</ul>
<h3 id="Set-Cookie-HttpOnly"><a href="#Set-Cookie-HttpOnly" class="headerlink" title="Set-Cookie: HttpOnly"></a>Set-Cookie: HttpOnly</h3><ul>
<li>原理：<ul>
<li>http only確保javascript無法直接存取cookie。</li>
</ul>
</li>
<li>啟動方式：<ul>
<li>只要在Set-Cookie的header加上HttpOnly就可以生效了。</li>
</ul>
</li>
</ul>
<h3 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h3><ul>
<li><p>原理：</p>
<ul>
<li>這是IE引進的功能，可以檢查XSS攻擊，不過firefox不支援。基本上CSP已經提供足夠防禦，但是可以讓不支援CSP舊版瀏覽器有比較高的安全性。</li>
</ul>
</li>
<li><p>啟動方式：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-XSS-Protection: 0   # 禁止XSS過濾</span><br><span class="line">X-XSS-Protection: 1   # 允許XSS過濾，遇到XSS會清除頁面</span><br><span class="line">X-XSS-Protection: 1; mode=block  # 允許XSS過濾，遇到XSS會阻擋頁面加載</span><br></pre></td></tr></table></figure>
</li>
<li><p>可參考：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-XSS-Protection">mozilla X-XSS-Protection</a>: 詳細介紹這個header在哪些browser支援和有什麼選項</li>
<li><a href="http://likewaylai.blogspot.tw/2012/03/javax-xss-protection.html">資安JAVA(十一)：X-XSS-Protection</a>: 這邊有提到X-XSS-Protection的由來，並且提到IE8之前在這個功能上的問題</li>
</ul>
</li>
</ul>
<h3 id="X-Download-Options"><a href="#X-Download-Options" class="headerlink" title="X-Download-Options"></a>X-Download-Options</h3><ul>
<li><p>原理：</p>
<ul>
<li>在IE8加入了這個選項，防止使用者下載檔案的時候點選直接開啟，避免執行執行了程式而且沒有在下載管理員留下紀錄的問題。</li>
</ul>
</li>
<li><p>啟動方式：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Download-Options: noopen</span><br></pre></td></tr></table></figure>
</li>
<li><p>可參考</p>
<ul>
<li><a href="https://msdn.microsoft.com/zh-tw/library/jj542450(v=vs.85).aspx">Microsoft-自訂下載體驗</a>: 為什麼要有這個選項</li>
<li><a href="https://stackoverflow.com/questions/15299325/x-download-options-noopen-equivalent">X-Download-Options: noopen equivalent</a>: 其他browser沒有想對應功能</li>
</ul>
</li>
</ul>
<h2 id="防禦-Clickjacking"><a href="#防禦-Clickjacking" class="headerlink" title="防禦 Clickjacking"></a>防禦 Clickjacking</h2><h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><ul>
<li><p>原理：</p>
<ul>
<li>控制frame和iframe顯示頁面的規則，不讓別人可以內嵌頁面。</li>
</ul>
</li>
<li><p>啟動方式：</p>
<ul>
<li>在header加上X-Frame-Options: XXX，XXX可以是<ul>
<li>DENY：禁止frame頁面</li>
<li>SAMEORIGIN：允許frame顯示同一網站頁面</li>
<li>ALLOW-FROM url：允許frame顯示某一網站頁面</li>
</ul>
</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Frame-Options: SAMEORIGIN</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="強化-HTTPS-機制"><a href="#強化-HTTPS-機制" class="headerlink" title="強化 HTTPS 機制"></a>強化 HTTPS 機制</h2><h3 id="Set-Cookie-Secure"><a href="#Set-Cookie-Secure" class="headerlink" title="Set-Cookie: Secure"></a>Set-Cookie: Secure</h3><ul>
<li>原理：<ul>
<li>強制讓cookie必須要在https的情況下才能傳輸</li>
</ul>
</li>
<li>啟動方式：<ul>
<li>只要在Set-Cookie的header加上Secure就可以生效了。</li>
</ul>
</li>
</ul>
<h3 id="Strict-Transport-Security"><a href="#Strict-Transport-Security" class="headerlink" title="Strict-Transport-Security"></a>Strict-Transport-Security</h3><ul>
<li><p>原理：</p>
<ul>
<li>當使用者用http連線，強制轉成https連線，這個選項只有在https連線的情況下才有用，如果是http會被忽略(因為可能有MITM)</li>
</ul>
</li>
<li><p>啟動方式：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Strict-Transport-Security: max-age=expireTime [; includeSubdomains]</span><br><span class="line"># max-age=expireTime: browser要記住這個網站要用https連線的時間</span><br><span class="line"># includeSubdomains: 哪些subdomain也都要同樣設定</span><br></pre></td></tr></table></figure>
</li>
<li><p>可參考</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security">Mozilla HTTP Strict Transport Security</a>: 詳細介紹這個header在哪些browser支援和有什麼選項</li>
</ul>
</li>
</ul>
<h2 id="避免瀏覽器誤判文件形態"><a href="#避免瀏覽器誤判文件形態" class="headerlink" title="避免瀏覽器誤判文件形態"></a>避免瀏覽器誤判文件形態</h2><h3 id="X-Content-Type-Options"><a href="#X-Content-Type-Options" class="headerlink" title="X-Content-Type-Options"></a>X-Content-Type-Options</h3><ul>
<li><p>原理：</p>
<ul>
<li>告訴client要遵守Content-Type的MIME設定，不要自行偵測，管理者必須要確保自己的設定是沒有錯誤的。</li>
</ul>
</li>
<li><p>啟動方式：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Content-Type-Options：nosniff</span><br></pre></td></tr></table></figure>
</li>
<li><p>可參考</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options">Mozilla X-Content-Type-Options</a>: 詳細介紹這個header在哪些browser支援和有什麼選項</li>
</ul>
</li>
</ul>
<h2 id="保護網站資源別被任意存取"><a href="#保護網站資源別被任意存取" class="headerlink" title="保護網站資源別被任意存取"></a>保護網站資源別被任意存取</h2><h3 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h3><ul>
<li><p>原理：</p>
<ul>
<li>CORS是用來解決腳本的跨域資源請求問題，用來確保資源是否可以被其他網站存取，但是要注意它不能阻擋CSRF</li>
<li>不能阻擋CSRF的原因：<ul>
<li>CORS是阻擋js所發出的request，但是CSRF可以透過form, tag等發起請求</li>
<li>Acess-Control-Allow-Origin是由browser解析的，所以其實request已經發出了，只是response被browser阻擋</li>
</ul>
</li>
</ul>
</li>
<li><p>啟動方式：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Origin: &lt;origin&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可參考</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin">Mozilla Access-Control-Allow-Origin</a>: 詳細介紹這個header的選項</li>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS">跨來源資源共享（CORS）</a>:詳細解釋CORS(Cross-Origin Resource Sharing)的功能</li>
<li><a href="https://blog.toright.com/posts/3205/%E5%AF%A6%E4%BD%9C-cross-origin-resource-sharing-cros-%E8%A7%A3%E6%B1%BA-ajax-%E7%99%BC%E9%80%81%E8%B7%A8%E7%B6%B2%E5%9F%9F%E5%AD%98%E5%8F%96-request.html">實作 Cross-Origin Resource Sharing (CORS) 解決 Ajax 發送跨網域存取 Request</a>: 如何用CORS存取外部資源</li>
<li><a href="https://b1ngz.github.io/csrf-and-cors/">简单聊一聊 CSRF 与 CORS 的关系:</a> CORS並不能防禦CSRF，這篇有很詳細的介紹</li>
</ul>
</li>
</ul>
<h3 id="X-Permitted-Cross-Domain-Policies"><a href="#X-Permitted-Cross-Domain-Policies" class="headerlink" title="X-Permitted-Cross-Domain-Policies"></a>X-Permitted-Cross-Domain-Policies</h3><ul>
<li><p>原理：</p>
<ul>
<li>當不能把crossdomain.xml放在根目錄時需要設定該選項</li>
<li>crossdomain.xml: 從別的domain讀取flash時所需要的策略文件</li>
</ul>
</li>
<li><p>啟動方式：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Permitted-Cross-Domain-Policies: master-only # master-only代表只允許主策略文件(/crossdomain.xml)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可參考</p>
<ul>
<li><a href="http://blog.xuite.net/fireworkgoldfish/CodeIndex/27179479-Cross+Domain+Policy">Cross Domain Policy</a>: 提到關於crossdomain.xml的設定</li>
<li><a href="http://blog.csdn.net/summerhust/article/details/7721627">关于跨域策略文件crossdomain.xml文件</a>: crossdomain.xml的範例</li>
<li><a href="https://toutiao.io/posts/218856/app_preview">如何使用 HTTP 响应头字段来提高 Web 安全性？</a>: X-Permitted-Cross-Domain-Policies相關解說</li>
</ul>
</li>
</ul>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="http://www.qa-knowhow.com/?p=1467">11個網站安全防護的 http Header 設定</a>: 其他人提到的header設定</li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>IPython Notebook - Jupyter教學</title>
    <url>/2018/12/02/IPython-Notebook-Jupyter%E6%95%99%E5%AD%B8/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p><a href="https://ipython.org/notebook.html">Jupyter Notebook</a>，過去被稱為ipython notebook，是ipython內的強大工具。</p>
<p>Jupyter最常用在學習資料處理上面，因為輸入指令後就可以產生相對應的圖形結果，做到資料視覺化的功能。而且更重要的是我們可以將自己的結果輸出成html或上傳Github，分享給其他人進行討論。</p>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p>如果有安裝python-pip了，可以直接用如下指令安裝。要是遇到權限問題可以再加上sudo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install <span class="string">&quot;ipython[notebook]&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>創造一個資料夾，然後在裡面開啟jupyter notebook</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ipython_notebook &amp;&amp; <span class="built_in">cd</span> ipython_notebook</span><br><span class="line">jupyter notebook</span><br><span class="line"><span class="comment"># 原本是可以用ipython notebook，但是未來可能會被捨棄</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果要在別的port開啟</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --port 8080</span><br></pre></td></tr></table></figure>

<p>接下來在web上應該可以直接連線Jupyter。</p>
<p>選擇New-&gt;python3後就可以在web新創一個notebook，值得注意的是這個notebook的副檔名是<code>.ipynb</code>，存放位置就是在我們當前的目錄，也就是<code>ipython_notebook</code></p>
<h3 id="登入機制"><a href="#登入機制" class="headerlink" title="登入機制"></a>登入機制</h3><p>jupyter notebook其實是有登出機制的，在右上角logout後，就要用密碼或token才能登入。</p>
<p>這時候其實可以直接重啟server，或是輸入<code>jupyter notebook list</code>來查看token，就可以再次登入了。</p>
<h3 id="編輯方式"><a href="#編輯方式" class="headerlink" title="編輯方式"></a>編輯方式</h3><p>在Jupyter中，進入notebook後會看到一個可以輸入值的空間，這個叫做cell。cell上面輸入python語法後，按下shift+enter就會產生執行結果。而我們可以增加或減少這些cell。</p>
<p>特別注意原本cell是藍色的，代表在command mode，但是如果點選cell後就會變成綠色，代表進入edit mode。從edit mode跳回command mode只要按下ESC即可。</p>
<p>另外可以注意每個cell可以選擇不同屬性，最常用的還是Code和Markdown。Code就是python的部分，而Markdown則是可以寫上相關的文字敘述。</p>
<h3 id="常用快捷鍵"><a href="#常用快捷鍵" class="headerlink" title="常用快捷鍵"></a>常用快捷鍵</h3><p>主要可以點選Help-&gt;Keyboard Shortcuts來看目前快速鍵怎麼使用(或是按ESC+h更快)</p>
<p>常用快速鍵如下所示：</p>
<ul>
<li><code>c</code>：複製當前的cell</li>
<li><code>x</code>：剪下當前的cell</li>
<li><code>v</code>：貼上剪貼簿的cell</li>
<li><code>dd</code>：刪除當前cell</li>
<li><code>a</code>：在上方插入新的cell</li>
<li><code>b</code>：在下方插入新的cell</li>
<li><code>shift+enter</code>：執行當前cell並跳到下一個cell</li>
<li><code>ctrl+enter</code>：執行當前cell</li>
<li><code>shift+tab</code>：可以顯示當前函式的使用方法</li>
</ul>
<h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>我們除了可以把當前notebook下載成html外，也可以push到Github上並且利用<a href="https://nbviewer.jupyter.org/">nbviewer</a>這個網站來分享。</p>
<p>舉個例子，<a href="https://github.com/jupyter/jupyter/wiki/A-gallery-of-interesting-Jupyter-Notebooks">A gallery of interesting Jupyter Notebooks</a>就收集了不少有趣的Juypter Notebook範例。</p>
<p>只要有ipynb上傳到Github，我們就可以看到輸出結果，就像<a href="https://github.com/lrhgit/uqsa_tutorials/blob/master/preliminaries.ipynb">這個GitHub</a>的結果可以被<a href="http://nbviewer.jupyter.org/github/lrhgit/uqsa_tutorials/blob/master/preliminaries.ipynb">nbviewer</a>顯示出來。</p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://ericjhang.github.io/archives/e300480b.html">ipython notebook安裝教學</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10192614">[Day02]Jupyter Notebook操作介紹！</a></li>
<li><a href="https://medium.com/@yehjames/%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90-%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92-%E7%AC%AC1-2%E8%AC%9B-jupyter-notebook%E4%BB%8B%E7%B4%B9-705f023e3720">[資料分析&amp;機器學習] 第1.2講：Jupyter Notebook介紹</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux和程式的互動</title>
    <url>/2018/06/12/Linux%E5%92%8C%E7%A8%8B%E5%BC%8F%E7%9A%84%E4%BA%92%E5%8B%95/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>這篇我們想要來探討 Linux 是怎麼和程式互動的，這邊包括兩個部分：Linux 如何執行程式以及程式如何讓 Linux 做系統操作。</p>
<h2 id="程式如何執行main"><a href="#程式如何執行main" class="headerlink" title="程式如何執行main"></a>程式如何執行main</h2><p>一般要呼叫程式來執行的，我們知道的是只要在 shell 下類似<code>./a.out</code>的指令，程式就會執行我們程式中的 main，但是這其中的原理是什麼呢？讓我們看看到執行 main 前做了哪些事。</p>
<p>下面例子我們以Kernel v4.17為例</p>
<ol>
<li><p>首先 shell 會 fork 一個 process，然後再呼叫 exec 系列函數把該 process 置換成指定的程式</p>
</li>
<li><p>execve 會呼叫 do_execve ，然後再呼叫 do_execveat_common，可參考<a href="https://elixir.bootlin.com/linux/v4.17/source/fs/exec.c#L1856">fs&#x2F;exec.c的1856行</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_execve</span><span class="params">(<span class="keyword">struct</span> filename *filename,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *__argv,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *__envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_arg_ptr</span> <span class="title">argv</span> =</span> &#123; .ptr.native = __argv &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_arg_ptr</span> <span class="title">envp</span> =</span> &#123; .ptr.native = __envp &#125;;</span><br><span class="line">  <span class="keyword">return</span> do_execveat_common(AT_FDCWD, filename, argv, envp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接著do_execveat_common會讀取struct linux_binprm，並且根據檔案格式尋找適合的binary header</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_execveat_common</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> filename *filename,</span></span><br><span class="line"><span class="params">                              <span class="keyword">struct</span> user_arg_ptr argv,</span></span><br><span class="line"><span class="params">                              <span class="keyword">struct</span> user_arg_ptr envp,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 重要的structure，保留執行檔的相關訊息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> *<span class="title">bprm</span>;</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 打開要執行的ELF檔</span></span><br><span class="line">    file = do_open_execat(fd, filename, flags);</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 生成mm_struct，供執行檔使用</span></span><br><span class="line">    retval = bprm_mm_init(bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> out_unmark;</span><br><span class="line">    <span class="comment">// 計算帶入的參數</span></span><br><span class="line">    bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class="line">    <span class="keyword">if</span> ((retval = bprm-&gt;argc) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 讀取 header</span></span><br><span class="line">    retval = prepare_binprm(bprm);</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 裡面會呼叫 search_binary_handler，根據檔案格式呼叫適合的binary_handler</span></span><br><span class="line">    retval = exec_binprm(bprm);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ELF的binary handler位在<a href="https://elixir.bootlin.com/linux/v4.17/source/fs/binfmt_elf.c#L690">fs&#x2F;binfmt_elf.c的690行</a>，做了header確認後會load program header和設定並執行elf_interpreter</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_elf_binary</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 讀取program header</span></span><br><span class="line">    elf_phdata = load_elf_phdrs(&amp;loc-&gt;elf_ex, bprm-&gt;file);</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 讀取elf_interpreter</span></span><br><span class="line">    retval = kernel_read(bprm-&gt;file, elf_interpreter,</span><br><span class="line">                    elf_ppnt-&gt;p_filesz, &amp;pos);</span><br><span class="line">    <span class="comment">// 把當前程式資訊清除並換上新的程式</span></span><br><span class="line">    retval = flush_old_exec(bprm);</span><br><span class="line">...</span><br><span class="line">    current-&gt;mm-&gt;end_code = end_code;</span><br><span class="line">    current-&gt;mm-&gt;start_code = start_code;</span><br><span class="line">    current-&gt;mm-&gt;start_data = start_data;</span><br><span class="line">    current-&gt;mm-&gt;end_data = end_data;</span><br><span class="line">    current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 執行elf_interpreter</span></span><br><span class="line">    start_thread(regs, elf_entry, bprm-&gt;p);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>經過Context Switch後，應該會從elf_interpreter執行，通常應該會是&#x2F;lib&#x2F;ld-x.x.so。ld-x.x.so的進入點是_start，最後會連結到<a href="https://code.woboq.org/userspace/glibc/elf/rtld.c.html">glibc&#x2F;elf&#x2F;rtld.c</a>的_dl_start，針對環境變數做處理。</p>
<ul>
<li>我們常見的LD_PRELOAD也是在這邊進行處理的</li>
</ul>
</li>
<li><p>當上述工作都做完後，就會進入 ELF binary 的<code>_start</code>，其中會呼叫 glibc 的<a href="https://code.woboq.org/userspace/glibc/csu/libc-start.c.html">__libc_start_main</a>進行初始設定，最後就會呼叫main()</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br></pre></td></tr></table></figure>

<h2 id="使用-system-call"><a href="#使用-system-call" class="headerlink" title="使用 system call"></a>使用 system call</h2><p>通常AP在Linux要跟kernel層互動大概只能透過system call，然而system call的使用大多數已經被包裝起來，所以幾乎不會看到，這邊我們來探討一下要怎麼在Linux直接呼叫system call。以下範例皆來自<a href="http://www.books.com.tw/products/0010587783">BINARY HACKS：駭客秘傳技巧一百招</a></p>
<h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>最簡單的呼叫system call方法是syscall。</p>
<p>syscall.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = syscall(__NR_getpid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret=%d pid=%d\n&quot;</span>, ret, getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make syscall</span><br><span class="line">$ ./syscall</span><br><span class="line">ret=18 pid=18</span><br></pre></td></tr></table></figure>

<p>看起來是很順利取得PID。我們可以把__NR_getpid換成其他的system call數字，也可以達到同樣效果。</p>
<h3 id="int-0x80"><a href="#int-0x80" class="headerlink" title="int 0x80"></a>int 0x80</h3><p>當然我們也可以用<code>int 0x80</code>來做到同樣的事情，但是要注意的是這樣的效率不會比較好，可參考<a href="https://stackoverflow.com/questions/12806584/what-is-better-int-0x80-or-syscall">What is better “int 0x80” or “syscall”?</a></p>
<p>另外這個做法在x64的架構是無法被使用的，可參考<a href="https://stackoverflow.com/questions/46087730/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a></p>
<p>syscall2.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span>:<span class="string">&quot;=a&quot;</span>(ret):<span class="string">&quot;0&quot;</span>(__NR_getpid))</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret=%d pid=%d\n&quot;</span>, ret, getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sysenter"><a href="#sysenter" class="headerlink" title="sysenter"></a>sysenter</h3><p>這部分也是只能在x86的平台上使用，會出現這個機制的理由是int 0x80的效率實在太差了。這邊的使用方式有點複雜，就不列出來了。</p>
<h3 id="比較"><a href="#比較" class="headerlink" title="比較"></a>比較</h3><p>這三種方式的比較簡單統整一下</p>
<p>syscall：現在主流，能在x64運行<br>int 0x80：只能在x86，效率差，已被捨棄<br>sysenter：只能在x86，用來替代int 0x80</p>
<p>詳情可以參考<a href="https://www.jianshu.com/p/f4c04cf8e406">Linux系统调用机制int 0x80、sysenter&#x2F;sysexit、syscall&#x2F;sysret的原理与代码分析</a>，寫得非常詳細。</p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="http://www.books.com.tw/products/0010587783">BINARY HACKS：駭客秘傳技巧一百招</a></li>
<li><a href="https://blog.csdn.net/eleven_xiy/article/details/77876702">Linux系统ELF程序的执行过程</a></li>
<li><a href="https://blog.csdn.net/conansonic/article/details/54236335">_dl_start源码分析</a></li>
<li><a href="https://www.jianshu.com/p/f4c04cf8e406">Linux系统调用机制int 0x80、sysenter&#x2F;sysexit、syscall&#x2F;sysret的原理与代码分析</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>clean code</title>
    <url>/2017/09/03/clean-code/</url>
    <content><![CDATA[<p>這邊記錄一下我看clean code的筆記整理。不過我得承認其實書裡很多做法我是不太贊同的，例如function要壓在20行以內這種。在C要這樣實踐很有難度，而且我看很多open source的project也都沒有遵循這樣的規範。但是這本書還是很有參考價值的，至少會讓自己反省寫code時有沒有犯了這些問題。</p>
<p>書中提到一個概念：</p>
<blockquote>
<p>程式設計師有大半時間花在看code，因此好閱讀的code對快速寫程式是有幫助的</p>
</blockquote>
<p>我想這就是我從書裡得到最大的收穫吧！</p>
<h2 id="有意義的名稱"><a href="#有意義的名稱" class="headerlink" title="有意義的名稱"></a>有意義的名稱</h2><ul>
<li><p>讓程式碼的隱含性高，名稱和意圖符合</p>
</li>
<li><p>避免誤導<br>讓變數不會相似高(autocomplete好找)<br>像是l和1，0和O</p>
</li>
<li><p>產生有意義的區別<br>例如a1,a2、ProductInfo,ProductData,或是table, variable等等都看不出差別</p>
</li>
<li><p>使用能念出來的名稱<br>人類大腦有一大部分都專注在字詞的概念，字詞是可發音的，方便理解<br>方便同事間彼此溝通</p>
</li>
<li><p>使用可被搜尋的名字<br>使用單一字母變數或是數值常數很難被找到<br>例如<code>MAX_CLASSES_PER_STUDENT</code>比<code>7</code>還要好找，命名變數e幾乎每段程式碼都會用到<br>一般來說，長命名比短命名好，命名長度應該和scope作對應，範圍越大的應該要用比較容易識別的名字</p>
</li>
<li><p>避免編碼<br>這邊的編碼是指形態或視野，作者不推薦使用匈牙利標誌法，因為那是早期編譯器不會進形型態檢查，但是現在編譯器已經會做了，所以不需要浪費時間做這件事</p>
<blockquote>
<p>可是有時候在看code，有提示還是比較容易記憶的，見仁見智</p>
</blockquote>
</li>
<li><p>成員的字首<br>不需要在變數前加上類似m_</p>
</li>
<li><p>類別方法命名<br>類別：要用名詞來命名<br>方法：用動詞命名，而且accessors要用get開頭、mutators用set、predicates要用is</p>
</li>
<li><p>使用一致性的詞彙<br>例如取得方法不要同時有get, fetch, retrieve</p>
</li>
<li><p>將命名放在有意義的上下文<br>例如state要配合address看才會知道是州，如果沒辦法配合上下文那就手動加上前綴，例如addrState</p>
</li>
<li><p>不要添加過多無意義資訊<br>例如每個變數名稱都加上特定前綴，會讓IDE無法幫你找變數</p>
</li>
</ul>
<h2 id="函式"><a href="#函式" class="headerlink" title="函式"></a>函式</h2><ul>
<li>函式要非常簡短，盡量低於20行</li>
<li>函式內的縮排也不要大過一兩層</li>
<li>做一件的函式是無法被區分成不同段落的，如宣告區、初始區等等</li>
<li>降層準則：程式閱讀應該是由上而下敘事，希望每個函式後面都進接著下一層次的概念。</li>
<li>函式應該做一件事，他們應該把這件事做好，而且他們應該只做這件事。</li>
<li>函式參數最多不要超過三個，越少越好，如果需要超過三個，可以考慮使用物件代替</li>
<li>越多參數要測試會越困難，而且參數有傳達概念的能力，讀者必須去了解它</li>
<li>另外不要用輸出型參數，用回傳值</li>
<li>分離指令和查詢(set和get)</li>
<li>使用例外處理來取代回傳錯誤碼，讓使用者不需要一遇到錯誤碼就必須馬上處理錯誤</li>
<li>結構化程式：雖然Dijkstra提到在一個函式內只能有一個return，不要有break和continue，以及goto，但是作者認為在小函式時可以適當使用，但是不應該用goto，因為只有大函式goto才有用處</li>
</ul>
<h2 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h2><ul>
<li>適當使用註解是用來彌補我們用程式碼表達意圖的失敗</li>
<li>沒有提供比程式碼更多資訊或是反而誤導的註解就是壞註解，當然過多資訊也是</li>
<li>git已經提供修改紀錄，不該寫在註解中，包括程式碼的註解也應該拿掉</li>
</ul>
<h3 id="適合用註解的時機"><a href="#適合用註解的時機" class="headerlink" title="適合用註解的時機"></a>適合用註解的時機</h3><ul>
<li>法律型註解</li>
<li>資訊型的註解</li>
<li>對意圖的解釋</li>
<li>闡明</li>
<li>對後果的告誡</li>
<li>TODO</li>
<li>放大重要性</li>
<li>Javadoc</li>
</ul>
<h2 id="編排"><a href="#編排" class="headerlink" title="編排"></a>編排</h2><p>每個檔案應該大部分用200行，最多不超過500行</p>
<h3 id="垂直距離"><a href="#垂直距離" class="headerlink" title="垂直距離"></a>垂直距離</h3><ul>
<li>程式中，應該要用垂直空白區分思緒(兩個函式間)，而且如果兩個函式密且相關的話，不要放太多註解在兩者之間</li>
<li>變數宣告：變數的宣告應該盡可能靠近變數被使用的地方</li>
<li>實體變數(instance)：盡量集中在最上方或最下方，方便被查詢</li>
<li>相依的函式應該放在同一區塊，相依性越高，彼此的垂直距離就要越短</li>
</ul>
<h3 id="水平距離"><a href="#水平距離" class="headerlink" title="水平距離"></a>水平距離</h3><ul>
<li><p>通常程式設計師偏好短的程式碼，不一定要80，但不要超過120</p>
</li>
<li><p>水平空白也可以用來表示優先權，例如乘法之間不要有空白，加減法則要</p>
</li>
<li><p>水平的對齊也沒有必要，因為自動化編排程式會毀掉這樣的對齊，而且這樣會讓人忽略變數型態，只關注上下的對齊</p>
<blockquote>
<p>不過像define我就覺得有必要對齊，這樣方便觀看</p>
</blockquote>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>    abc;</span><br><span class="line"><span class="type">float</span>  def;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要使用一行文，包括單行while加上分號，很容易搞錯</p>
<blockquote>
<p>這邊注意if如果是一行，也許加上大括號會比較好，常常會在下方加上其他敘述卻忘了加括號，這樣會有不同的行為</p>
</blockquote>
</li>
</ul>
<h2 id="物件及資料結構"><a href="#物件及資料結構" class="headerlink" title="物件及資料結構"></a>物件及資料結構</h2><p>不要幫每個private都加上get, set，應該要思考怎樣才能隱藏更多資訊<br>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FuelTankCapacityInGallons()&#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getGallonsOfGasoline</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>會差於</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publice <span class="keyword">interface</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getPercentFuelRemaining</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因為使用者知道怎麼計算油量</p>
<h3 id="資料與物件有反對稱性"><a href="#資料與物件有反對稱性" class="headerlink" title="資料與物件有反對稱性"></a>資料與物件有反對稱性</h3><p>結構化的程式碼容易添加新函式，而不需變更原有的資料結構<br>物件導向的程式碼容易添加新類別，而不用變動已有函式</p>
<h2 id="錯誤處理"><a href="#錯誤處理" class="headerlink" title="錯誤處理"></a>錯誤處理</h2><ul>
<li>如前所說，作者建議用例外事件而非錯誤碼</li>
<li>不要使用java中的checked exception，因為如果底層函式被修改，會強制所有被呼叫的函式都要做錯誤檢查，會破壞函式封閉原則</li>
<li>不要回傳null，會讓使用者需要做額外判斷</li>
<li>傳遞null也會讓函式需要做額外判斷</li>
</ul>
<h2 id="邊界"><a href="#邊界" class="headerlink" title="邊界"></a>邊界</h2><p>當使用第三方軟體時，可以考慮製作一個介面來與第三方API銜接，這樣如果有大改動時，我們只需要修改介面即可</p>
<h2 id="單元測試"><a href="#單元測試" class="headerlink" title="單元測試"></a>單元測試</h2><p>TDD(Test-Driven Development)有三大準則</p>
<ol>
<li>在撰寫一個單元測試前，不可以撰寫任何產品程式</li>
<li>只撰寫剛好無法通過的單元測試，不能編譯也算無法通過</li>
<li>只撰寫剛好能通過當前測試失敗的產品程式<br>以上準則可以讓程式設計師被限制在30s的循環：測試程式和產品程式是一起被撰寫的。</li>
</ol>
<p>一個測試一個assert，但作者認為不需要嚴格遵守，盡可能少即可<br>一個測試一個概念</p>
<p>FIRST</p>
<ul>
<li>Fast：測試要夠快，能夠快速執行，讓人有意願去執行</li>
<li>Independent：測試程式不應該互相依賴，會讓人更難尋找錯誤</li>
<li>Repeatable：可以在任何環境下執行</li>
<li>Self-Validating：要輸出boolean告知程式成功或失敗，而非去看log主觀判斷</li>
<li>Timely：單元測試要再寫產品程式之前，這樣才能寫出可被測試的程式</li>
</ul>
<h2 id="類別"><a href="#類別" class="headerlink" title="類別"></a>類別</h2><ul>
<li>Single Responsibility Principle(SRP)：單一職責原則</li>
<li>一個類別或模組應該只有一個被修改的理由</li>
<li>保持類別的凝聚性(每個變數被多個method使用)：這樣會得到許多小class</li>
</ul>
<h2 id="系統"><a href="#系統" class="headerlink" title="系統"></a>系統</h2><p>軟體系統相較於實體系統來說是獨特的，如果我們持續保持適當的關注點分離，軟體系統的架構就能遞增地成長</p>
<h2 id="羽化"><a href="#羽化" class="headerlink" title="羽化"></a>羽化</h2><p>遵守四個原則：</p>
<ol>
<li>執行完所有測試：有測試就會消除整理程式碼會破壞程式的恐慌</li>
<li>沒有重複的部分</li>
<li>表達程式設計師的本意</li>
<li>最小化類別和方法的數量：這條守則的優先權是最低的</li>
</ol>
<h2 id="平行化"><a href="#平行化" class="headerlink" title="平行化"></a>平行化</h2><ul>
<li>物件是處理過程的抽象化，執行緒是排程的抽象化</li>
<li>平行化是去耦合的抽象化，讓「做什麼」和「什麼時候做」分開</li>
<li>另外也可以解決response time和throughput的限制</li>
</ul>
<h3 id="迷思"><a href="#迷思" class="headerlink" title="迷思"></a>迷思</h3><p>X 平行化總是能改善效能<br>X 撰寫平行化程式並不需要修改原有的設計<br>O 平行化會帶來額外負擔<br>O 正確的平行化是複雜的<br>O 平行化的錯誤通常不容易重複出現</p>
<h3 id="平行化防禦方法"><a href="#平行化防禦方法" class="headerlink" title="平行化防禦方法"></a>平行化防禦方法</h3><ul>
<li>單一職責原則(SRP)：保持平行化程式碼與其他程式有清楚劃分</li>
<li>限制資料視野：嚴格限制共享資料的存取次數</li>
<li>使用資料的副本：複製唯讀副本，減少共享資料次數</li>
<li>執行緒盡可能獨立運行</li>
<li>另外也要保持同步區塊的簡短，因為cost高</li>
<li>優雅的關閉平行化程式碼，注意能讓子thread可以關閉</li>
</ul>
<h3 id="平行化-測試"><a href="#平行化-測試" class="headerlink" title="平行化 - 測試"></a>平行化 - 測試</h3><ul>
<li>不要因為系統後來通過測試就忽略失敗，因為未來會有越來越多錯誤建立在有缺陷的基礎上</li>
<li>先讓非執行緒的程式碼可以運作，不要兩者同時debug</li>
<li>讓執行緒是可以自我調校</li>
<li>執行比處理器還多的執行緒，bug會越容易找到</li>
<li>在不同平台執行</li>
<li>調整程式碼，使其產生失敗</li>
</ul>
<h2 id="Bad-Smell"><a href="#Bad-Smell" class="headerlink" title="Bad Smell"></a>Bad Smell</h2><h3 id="Bad-Smell-註解"><a href="#Bad-Smell-註解" class="headerlink" title="Bad Smell - 註解"></a>Bad Smell - 註解</h3><ul>
<li>無效、沒意義、不適當的註解</li>
<li>被註解掉的程式碼</li>
</ul>
<h3 id="開發環境"><a href="#開發環境" class="headerlink" title="開發環境"></a>開發環境</h3><ul>
<li>需要多個步驟建立專案或系統</li>
<li>需要多個步驟進行測試</li>
</ul>
<h3 id="Bad-Smell-函式"><a href="#Bad-Smell-函式" class="headerlink" title="Bad Smell - 函式"></a>Bad Smell - 函式</h3><ul>
<li>過多參數</li>
<li>輸出行參數</li>
<li>旗標參數</li>
<li>被遺棄的函式</li>
</ul>
<h3 id="一般狀況"><a href="#一般狀況" class="headerlink" title="一般狀況"></a>一般狀況</h3><ul>
<li>同份原始碼有多種語言</li>
<li>明顯該有的行為沒被實現(最小驚奇原則)</li>
<li>在邊界上的不正確行為：不要依賴直覺，為邊界條件寫測試程式</li>
<li>無視安全規範：不要關閉編譯器的警告</li>
<li>重複的程式碼：這是最重要的規範之一</li>
<li>在錯誤抽象層次上的程式碼：高層次概念都要在基底類別</li>
<li>基底類別相依於其衍生類別</li>
<li>過多資訊：應該要把暴露在介面上的資訊減少</li>
<li>被遺棄的程式碼</li>
<li>垂直分隔：如前所示</li>
<li>不一致性：維持命名一致性</li>
<li>雜亂程式：保持原始檔整潔</li>
<li>人為耦合：不要將變數隨意宣告，然後就留在某處</li>
<li>特色留戀：類別的方法應該只對同一類別裡的變數和函式感興趣，不應該操作其他類的變數或函式</li>
<li>選擇型參數：在函式尾端加上true, false</li>
<li>模糊的意圖：盡可能讓程式碼有表達力</li>
<li>錯置的職責：像是要把常數放在讀者認為他應該要在的地方</li>
<li>使用具解釋性的變數：將計算過程拆解成富有意義名稱的暫存變數</li>
<li>函數名稱要說到做到</li>
<li>了解演算法：不是調整函式做到想讓其做到的事，而是確定解決方法是正確，並且讓函式明顯透露出是怎麼運作的</li>
<li>用多型取代if-else和switch-case</li>
<li>遵循標準的慣例：用團隊的慣例</li>
<li>用有名稱的常數取代魔術數字</li>
<li>要精確：不要有模擬兩可的程式碼，精確表達該函式要做什麼</li>
<li>封裝條件判斷：<code>if(shouldBeDeleted(timer))</code>取代<code>if(timer.hasExpired() &amp;&amp; !timre.isRecurrent())</code></li>
<li>避免否定條件判斷</li>
<li>函式只該做一件事</li>
<li>不要隨意：如果程式碼保持一致性，這樣後來修改的人就會按造前面的原則改</li>
<li>封裝邊界條件：如果a+1常被用到，那就用b&#x3D;a+1取代，這點跟refactoring似乎不太一樣</li>
</ul>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul>
<li>選擇有描述性的名稱</li>
<li>在適當的抽象層次使用適當的名稱</li>
<li>越大的scope就要用較長的名稱</li>
</ul>
<h3 id="Bad-Smell-測試"><a href="#Bad-Smell-測試" class="headerlink" title="Bad Smell - 測試"></a>Bad Smell - 測試</h3><ul>
<li>不足夠的測試程式</li>
<li>不要跳過簡單的測試</li>
<li>對程式錯誤處進行詳細測試</li>
<li>測試要夠快速</li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>軟體開發</tag>
      </tags>
  </entry>
  <entry>
    <title>code review</title>
    <url>/2017/08/27/code-review/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其實我一直對code review有點好奇，到底有什麼樣的好處。<br>所以統整了些資料，研究看看實行的好處以及如何實行code review。</p>
<p><strong>重要</strong>：這篇只是我想理解code review方式而整理出來的文章，不一定真的實用，之後會隨著我經驗增加而更新內容</p>
<h2 id="好處"><a href="#好處" class="headerlink" title="好處"></a>好處</h2><ol>
<li>品質提升：開發者太熟悉流程了，可能會有盲點，其他人可能可以幫忙找到邏輯問題。</li>
<li>更容易維護：其他人幫忙看code可以確保程式的可讀性，不會只有開發者才看得懂，開發者開發時也因為會有人來看，所以會思考我這樣是否可以讓review的人看懂邏輯。</li>
<li>同步文化、設計理念：確保程式有符合團隊開發的風格、coding style、API使用習慣等等，也比較不會有開發了功能跟原來架構設計理念有落差的情況。</li>
<li>經驗傳承和相互學習：資深員工把經驗傳給新進員工，或是大家彼此間可以學到寫程式的小技巧。</li>
<li>備份功能：確保至少有兩個人知道code的意思。</li>
</ol>
<h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul>
<li>開發時需要多花費時間在上面code review上，但長遠來說會減少maintain時間</li>
<li>要有正確的心態來review，不然會造成團隊氣氛不佳</li>
</ul>
<h2 id="心態"><a href="#心態" class="headerlink" title="心態"></a>心態</h2><ul>
<li>code和人是分開的：我們是針對code做討論，而不是質疑人的能力。</li>
<li>相互信任：信任團隊沒人會故意寫爛code，有問題是可能只是沒想到而已。</li>
<li>相互尊重：<ul>
<li>討論過程中是相互學習的關係，而不是監視和監視的關係。</li>
<li>review者討論態度語氣不能太尖銳，被review者也要能接受合理的意見</li>
</ul>
</li>
<li>相互學習：做code review不只是要維護品質，更重要的是大家可以彼此學習，學會更好的技巧。</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h3><ul>
<li>說明code review規則，以及建立正確的心態</li>
<li>事先訂定公司開發的文化，如coding style，命名規則</li>
<li>使用工具在處理機械化作業，如coding style統一，減少人為介入</li>
</ul>
<h3 id="開發功能前"><a href="#開發功能前" class="headerlink" title="開發功能前"></a>開發功能前</h3><ul>
<li>開發時間需要預估code review的時間</li>
<li>先規劃如何將大功能切成小部分：<ul>
<li>控制在reviewer 15min內可以看完的程度，這樣reviewer可以在工作一段落時稍微看一下，不佔用太多時間</li>
<li>如果功能出了大問題，也可以把風險控制在最小</li>
</ul>
</li>
</ul>
<h3 id="review前"><a href="#review前" class="headerlink" title="review前"></a>review前</h3><ul>
<li>review前要先準備好環境，可以demo或讓reviewer測試</li>
<li>如果有使用分析工具，先使用工具產生報表<ul>
<li>review時可以針對上面的重點討論</li>
<li>減少review的effort</li>
</ul>
</li>
</ul>
<h3 id="review中"><a href="#review中" class="headerlink" title="review中"></a>review中</h3><ul>
<li>讓reviewer主導review的過程，這樣才能發現盲點</li>
<li>code review時間不要超過半小時</li>
<li>利用checklist來檢查<ul>
<li>功能需求是什麼？設計方式是否有達到目的？</li>
<li>是否可以做未來擴充？</li>
<li>是否足夠安全？有沒有邏輯漏洞？</li>
<li>Error handling和corner case是否都有處理好？</li>
<li>程式是否易讀？複雜地方是否有註解？可以再精簡嗎？</li>
<li>有符合團隊coding style嗎？命名好嗎？有沒有通過工具測試？</li>
<li>效能是否可以再提升？</li>
</ul>
</li>
<li>review過程不改code，用todo list先記錄</li>
</ul>
<h3 id="review後"><a href="#review後" class="headerlink" title="review後"></a>review後</h3><ul>
<li>要留下reviewer是誰，不是要抓戰犯，而是當開發者不在時，可以知道有誰懂這段code</li>
<li>review後要留下紀錄提供學習使用</li>
<li>定期開會評估code review流程和效用<ul>
<li>review的方式要不要調整？</li>
<li>工具是否要調整？</li>
<li>checklist是否要更新？</li>
</ul>
</li>
</ul>
<h2 id="輔助工具"><a href="#輔助工具" class="headerlink" title="輔助工具"></a>輔助工具</h2><p>下面工具只是先整理起來，我並沒有每個都用過，等真正用過再來寫心得吧！</p>
<ul>
<li>統一Glossary：<ul>
<li>可以使用wiki等文件建立</li>
</ul>
</li>
<li>找重複程式碼：<ul>
<li>Simian：商用需付費，可參考<a href="http://ithelp.ithome.com.tw/articles/10106013">CI Server 13 - 找出重複的程式碼 (Simian)</a></li>
</ul>
</li>
<li>判斷複雜度：<ul>
<li>SourceMonitor：免費，可參考<a href="https://dotblogs.com.tw/hatelove/archive/2010/02/10/sourcemonitor.aspx">[Tool]SourceMonitor - 程式碼掃瞄</a></li>
<li>Complexity：GNU tool，可參考<a href="http://hao.jobbole.com/complexity/">Complexity：一个测量 C 代码复杂性的工具</a></li>
</ul>
</li>
<li>分析綜合品質：<ul>
<li>FxCop：微軟出的，可參考<a href="https://dotblogs.com.tw/hatelove/2011/12/18/introducing-fxcop-and-vs2010-static-code-analysis-tool">[Tool]靜態程式碼分析－FxCop</a></li>
<li>Adlint：Open source，但似乎很久沒更新了</li>
<li>SonarQube：可參考<a href="https://poychang.github.io/sonarqube-csharp/">SonarQube 程式碼品質分析工具</a></li>
</ul>
</li>
<li>程式法風格：<ul>
<li>StyleCop：似乎只能用在C#，可參考<a href="http://ithelp.ithome.com.tw/articles/10079546">[如何提升系統品質-Day17]品質量測工具-StyleCop</a></li>
<li>Artistic Style：可以自動統一所有程式碼的風格，甚至可以綁在git的commit hook上，確保大家不會commit風格不對的code</li>
</ul>
</li>
</ul>
<h2 id="如何實際落實"><a href="#如何實際落實" class="headerlink" title="如何實際落實"></a>如何實際落實</h2><p>通常要在運作一段時間的團隊加入新機制並不是那麼的容易，特別是怕會影響正常業務。<br>所以可以試試沙盒的概念，先少部分的人開始測試使用，<br>而且也不要一下子就把所有機制加上去，以不一下子造成過多改變為主，慢慢調整<br>最後相信可以找到適合團隊的做法。</p>
<h3 id="可以調整的選項"><a href="#可以調整的選項" class="headerlink" title="可以調整的選項"></a>可以調整的選項</h3><p>code review的基本概念是要讓其他人來看開發者的code，以客觀角度檢視，藉此提高品質和增進彼此相互學習<br>所以只要能達到這個目標的手段其實都是可以接受的，重點是要找到適合團隊的方式<br>這邊有幾項可以思考的方向：</p>
<ul>
<li>review的方式：網路上找到大部分的方式都是git的Pull Request功能，可以線上直接看code，不過或許直接到對方位置看也是個選項。</li>
<li>review的頻率：這個可以隨團隊開發內容的性質作調整</li>
<li>review的大小：有些review是多人一起，這個比較適合有很多新進人員，需要一起建立開發文化。不然一般是用peer review即可。</li>
</ul>
<h2 id="如何評估效用"><a href="#如何評估效用" class="headerlink" title="如何評估效用"></a>如何評估效用</h2><p>當然code review一定是好處大於壞處才會讓大家採用，那要怎麼評估好處部分呢？<br>可以從下面幾個方向來想：</p>
<ol>
<li>執行前後，bug減少的數量(這是品質部分)</li>
<li>執行前後，團隊多花費的時間(這是成本部分)</li>
<li>大家在執行後的感想？是否有所學習？(畢竟學習這種東西很難用數據衡量)</li>
<li>在code review中發現哪些問題？(bug減少數量如果不好統計，可以看有哪些潛在問題被發掘)</li>
<li>code品質部分？這部分可以用工具評分或是問問開發者的感受。</li>
</ol>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://msdn.microsoft.com/zh-tw/communitydocs/visual-studio/ta14052601">Code Review Guidance</a>：這篇微軟的文章非常值得一看，該講的都有講出來。</li>
<li><a href="http://ithelp.ithome.com.tw/articles/10081797">[如何提升系統品質-Day30]Code Review與總結</a>：這邊有提到許多工具，可以研究看看</li>
<li><a href="https://blog.mz026.rocks/20170812/did-you-code-review-today">你今天 code review 了嗎？</a>：這篇也很推薦，對code review的本質和方法有不錯的論述</li>
<li><a href="https://www.zhihu.com/question/41089988">參考腾讯Bugly的回答</a>：這邊提到code review如何實現在不同種類團隊上，偏實務方面的文章</li>
<li><a href="https://buzzorange.com/techorange/2016/08/16/airbnb-code-review/">Airbnb 資深工程師分享：怎樣才是正確、有效的 code review</a>：提到了code review的正確態度</li>
<li><a href="https://read01.com/JmzyoG.html#.WaJAatOg_OQ">我們是怎麼做Code Review的</a>：別人實現code review的經驗</li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>軟體開發</tag>
      </tags>
  </entry>
  <entry>
    <title>dd - 資料處理的好工具</title>
    <url>/2018/11/25/dd-%E8%B3%87%E6%96%99%E8%99%95%E7%90%86%E7%9A%84%E5%A5%BD%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>dd全名叫做data duplicator，這個工具最主要的功能是對資料作複製、修改、備份，是一個很方便的小工具。通常Linux中預設都會有，不需要額外安裝。</p>
<h2 id="使用教學"><a href="#使用教學" class="headerlink" title="使用教學"></a>使用教學</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul>
<li>輸入輸出參數<ul>
<li>if&#x3D;FILE：輸入名稱</li>
<li>of&#x3D;FILE：輸出名稱</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=[input_file] of=[output_file]</span><br></pre></td></tr></table></figure>

<h3 id="轉換"><a href="#轉換" class="headerlink" title="轉換"></a>轉換</h3><ul>
<li>做相對應的轉換<code>conv=CONVS</code><ul>
<li>lcase：大寫字母換小寫</li>
<li>ucase：小寫字母換大寫</li>
<li>nocreat：不要建立輸出檔案</li>
<li>notrunc：input小於output時，仍維持output大小</li>
<li>fdatasync：讓資料同步寫入硬碟</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 轉為小寫</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=[input_file] of=[output_file] conv=lcase</span><br></pre></td></tr></table></figure>

<h3 id="區塊"><a href="#區塊" class="headerlink" title="區塊"></a>區塊</h3><ul>
<li>bs&#x3D;[bytes]：等同於同時設定ibs和obs，一次讀或寫的block size。<ul>
<li>ibs&#x3D;[bytes]：指定每次讀取的block size(default 512 bytes)</li>
<li>obs&#x3D;[bytes]：指定每次寫入的block size(default 512 bytes)</li>
</ul>
</li>
<li>count&#x3D;[number]：只處理前[number]輸入區塊，block size要參考ibs。</li>
<li>seek&#x3D;[number]：輸出檔案跳過前[number]個區塊，block size要參考obs。</li>
<li>skip&#x3D;[number]：輸入檔案跳過前[number]個區塊，block size要參考ibs。</li>
</ul>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><ul>
<li><p>大小寫轉換</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 換大寫</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=[input] of=[output] conv=ucase</span><br><span class="line"><span class="comment"># 換小寫</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=[input] of=[output] conv=lcase</span><br></pre></td></tr></table></figure>
</li>
<li><p>產生一個特定大小的檔案</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 內容為空的1KB檔案</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=[output] bs=1024 count=1</span><br><span class="line"><span class="comment"># 內容為亂數的1MB檔案</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=[output] bs=1m count=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>把特定檔案的開頭512 byte清空</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=[output] bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>
</li>
<li><p>備份硬碟</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=[來源] of=[目標]</span><br><span class="line"><span class="comment"># 例如從/dev/sda備份到/dev/sdb</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=/dev/sdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>備份光碟，可參考<a href="https://www.thomas-krenn.com/en/wiki/Create_an_ISO_Image_from_a_source_CD_or_DVD_under_Linux">Create an ISO Image from a source CD or DVD under Linux</a></p>
<ol>
<li><p>先觀察&#x2F;dev&#x2F;cdrom</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">isoinfo -d -i /dev/cdrom | grep -i -E <span class="string">&#x27;block size|volume size&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然後應該會出現類似如下內容</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Logical block size is: 2048</span><br><span class="line">Volume size is: 327867</span><br></pre></td></tr></table></figure>
</li>
<li><p>接著參考上面的數字使用dd指令(bs大部分都是2048，而count其實有加沒加都沒差)</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/cdrom of=test.iso bs=&lt;block size from above&gt; count=&lt;volume size from above&gt;</span><br><span class="line"><span class="comment"># 以上述例子</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/cdrom of=outputCD.iso bs=2048 count=327867</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>拆分&amp;合併檔案，可參考<a href="https://www.linuxquestions.org/linux/answers/applications_gui_multimedia/splitting_and_merging_files_using_dd">Splitting and Merging files using dd</a></p>
<ul>
<li>拆分檔案，例如把檔案切成好幾個1G</li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=[大檔案] of=[part1] bs=1m count=1024</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=[大檔案] of=[part2] bs=1m count=1024</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<ul>
<li>合併檔案，例如好幾個1G合併起來</li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=[part1] of=大檔案 bs=1m count=1024</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=[part2] of=大檔案 bs=1m count=1024 seek=1024</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://blog.gtwang.org/linux/dd-command-examples/">dd 指令教學與實用範例，備份與回復資料的小工具</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>dependency</title>
    <url>/2017/08/26/dependency/</url>
    <content><![CDATA[<h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>通常我們都會用Makefile來看相依性，如果有改動make會自動幫我們判別<br>但是有些情況，make可能無法判斷<br>以下面為例，我們有四個檔案：main.c, test.c, test.h, private.h</p>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;private.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test=%d\n&quot;</span>, PRIV_VALUE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>private.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _PRIVATE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PRIVATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIV_VALUE 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然後假設我們的Makefile是這樣寫</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">BIN=main.out</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OBJ)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$(BIN)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o <span class="variable">$(BIN)</span></span><br></pre></td></tr></table></figure>

<p>我們試著修改private.h的MACRO值，就會發現重新make結果還是不變，需要重新make clean</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>可以使用gcc的特殊option</p>
<ul>
<li><p>gcc -M xxx.c: 找出所有相依檔</p>
</li>
<li><p>gcc -MM xxx.c: 同-M，但不含系統檔</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.c test.h</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>gcc -MP -MM xxx.c: 會加上其他header，避免某些compiler error</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test.o: test.c test.h</span></span><br><span class="line"></span><br><span class="line"><span class="section">test.h:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>-MF file: 輸出的dependency檔案名</p>
</li>
<li><p>-MD: 同-M -MF</p>
</li>
<li><p>-MMD: 同-MM -MF</p>
</li>
<li><p>-MT: 可以更改dependency檔案內的目標，可參考<a href="http://blog.sina.com.cn/s/blog_717794b70101gjca.html">关于 gcc MT MF[转]</a></p>
</li>
</ul>
<p>因此只要把Makefile改成這樣即可</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">OBJ=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line">BIN=main.out</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OBJ)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$(BIN)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> $(OBJ:.o=.d)</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span></span><br><span class="line">    <span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt; <span class="variable">$*</span>.d</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o <span class="variable">$(BIN)</span> *.d</span><br></pre></td></tr></table></figure>

<p><code>-</code>代表如果有錯誤不要停止執行，<code>$(OBJ:.o=.d)</code>代表把.o換成.d，因此會變成類似</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test.o: test.c private.h test.h</span></span><br><span class="line"><span class="section">main.o: main.c test.h</span></span><br></pre></td></tr></table></figure>

<p>由於該rule底下沒有statement，所以會直接對應<code>%.o: %.c</code></p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/">Auto-Dependency Generation</a></li>
<li><a href="http://www.ncpress.com.cn/zhuanti/0613_1360GCC/d-015.htm">GCC 技术参考大全 附录D 命令行选项</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
        <tag>系統程式</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 簡易教學</title>
    <url>/2018/05/12/docker-%E7%B0%A1%E6%98%93%E6%95%99%E5%AD%B8/</url>
    <content><![CDATA[<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><ul>
<li>安裝<br>以前安裝時需要安裝docker和boot2docker，但現在只要到官網下載DOCKER COMMUNITY EDITION (CE)就可以了。</li>
</ul>
<blockquote>
<p>boot2docker是MAC下輕量的Linux VM，專門用來執行docker daemon</p>
</blockquote>
<p>然後以前使用都會用<a href="https://kitematic.com/">kitematic</a>這個GUI的操作介面，現在docker官方也已經整進去了，我們可以直接透過docker的應用程式下載kitematic(在上方工具列的選項裡)</p>
<p>安裝詳細流程可以參考<a href="http://blog.itist.tw/2017/06/how-to-install-docker-ce-with-mac-os-and-os-x.html">如何在 macOS 上安裝 Docker CE</a>，寫得非常清楚。</p>
<h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><p>Ubuntu的安裝方式也跟以前不一樣了，可參考官網的作法，<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-using-the-repository">Get Docker CE for Ubuntu</a></p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows的安裝教學連結<a href="https://docs.docker.com/docker-for-windows/install/#about-windows-containers">在此</a>，值得注意的是只有Windows10才有支援Hyper-V，如果是其他版本就必須要安裝使用Virtualbox的Docker Toolbox來取代了。</p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>可以用一張圖職階概括大部分常用docker的指令，圖片來自<a href="https://philipzheng.gitbooks.io/docker_practice/content/appendix_command/">Docker —— 從入門到實踐  附錄一：命令查詢</a></p>
<p><img src="https://philipzheng.gitbook.io/~gitbook/image?url=https://1144739760-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%252F-LvLdlWILWa_WXgBI_eY%252F-LvLdmMmmDnQXr_Axo0l%252F-LvLdnbuSZ5KOT0JxN9C%252Fcmd_logic.png?generation=1575559314851294&alt=media&width=400&dpr=2&quality=100&sign=3b7e6085&sv=1" alt="docker cmd"></p>
<h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><ul>
<li><p>尋找images</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search XXX</span><br></pre></td></tr></table></figure>
</li>
<li><p>把images抓下來</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull XXX</span><br></pre></td></tr></table></figure>
</li>
<li><p>看目前有哪些images</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
</li>
<li><p>刪除某images</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi XXX</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><ul>
<li><p>看目前有哪些container正在跑</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
</li>
<li><p>看包括所有停止的container</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>讓某個container開始&#x2F;停止</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start/stop XXX</span><br></pre></td></tr></table></figure>
</li>
<li><p>刪除某container</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> XXX</span><br></pre></td></tr></table></figure>
</li>
<li><p>看某個container資訊</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect XXX</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>執行部分其實可以加上很多參數：</p>
<ul>
<li><p><code>-d</code>: 代表以daemon執行(背景執行)</p>
</li>
<li><p><code>-p port:port</code>: 代表port映射，例如<code>-p 8080:80</code>就是把 port 8080 對應到image的 port 80</p>
</li>
<li><p><code>-v dir:dir</code>: 代表映射目錄，例如<code>-v /home/share:/var/www:rw</code>就是把&#x2F;home&#x2F;share對應到image的&#x2F;var&#x2F;www，且權限為rw。路徑需要為絕對路徑。</p>
</li>
<li><p><code>--rm</code>：當有container存在時自動移除</p>
</li>
<li><p><code>-i</code>：互動模式</p>
</li>
<li><p><code>-t</code>：允許TTY</p>
</li>
<li><p><code>-w path</code>：設定進入container的工作路徑</p>
</li>
<li><p><code>-e key=value</code>：帶入環境變數</p>
</li>
<li><p>跑images</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -i -t -p 8080:80 nginx</span><br><span class="line">docker run -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>背景執行</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:80 -v shared_dir:/var/www:rw nginx</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT"></a>COMMIT</h3><ul>
<li><p>看有甚麼改變</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker diff XXX</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交成新的images</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;註解&quot;</span> -a=<span class="string">&quot;author&quot;</span> XXX repo_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>看歷史</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">history</span> XXX</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>我們也可以用Dockerfile產生image，可參考<a href="https://peihsinsu.gitbooks.io/docker-note-book/content/docker-build.html">使用Dockerfile建置</a></p>
<p>下面是個範例</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># base image</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行的command</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要開的port，注意在run的時候還是要加上-p才能真正讓外部連接該port</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 環境變數</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:/home/bin</span><br></pre></td></tr></table></figure>

<p>建立image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t repo_name:tag_name .</span><br></pre></td></tr></table></figure>

<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>看完command可能還是不清楚怎麼用，這邊用安裝nginx的docker image來說明</p>
<h3 id="取得image"><a href="#取得image" class="headerlink" title="取得image"></a>取得image</h3><p>首先我們先搜尋nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker search nginx</span><br><span class="line">NAME                                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                                                  Official build of Nginx.                        8564                [OK]</span><br><span class="line">jwilder/nginx-proxy                                    Automated Nginx reverse proxy <span class="keyword">for</span> docker con…   1331                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm                                Container running Nginx + PHP-FPM capable of…   547</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>我們先抓officical的images</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">f2aa67a397c4: Pull complete</span><br><span class="line">3c091c23e29d: Pull complete</span><br><span class="line">4a99993b8636: Pull complete</span><br><span class="line">Digest: sha256:0fb320e2a1b1620b4905facb3447e3d84ad36da0b2c8aa8fe3a5a81d1187b884</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nginx:latest</span><br></pre></td></tr></table></figure>

<p>現在local端就有nginx的image了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              ae513a47849c        11 days ago         109MB</span><br></pre></td></tr></table></figure>

<h3 id="運行container"><a href="#運行container" class="headerlink" title="運行container"></a>運行container</h3><p>開始運行container，並且讓port 8080對應到nginx container的port 80，工作路徑為&#x2F;home，然後執行bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -i -t -p 8080:80 -w /home nginx bash</span><br></pre></td></tr></table></figure>

<p>我們也可以選擇背景執行，並且把shared_dir對應到&#x2F;var&#x2F;www</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:80 -v shared_dir:/var/www:rw nginx</span><br></pre></td></tr></table></figure>

<p>一定有人會問這樣的情況下怎麼控制bash呢？我們可以用exec command</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i -t 78fc bash</span><br></pre></td></tr></table></figure>

<h3 id="操作運行中的container"><a href="#操作運行中的container" class="headerlink" title="操作運行中的container"></a>操作運行中的container</h3><p>看一下當前有的container</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">e2cf9ea13bb4        nginx               <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   2 minutes ago       Up 2 minutes        0.0.0.0:8080-&gt;80/tcp   priceless_murdock</span><br><span class="line">$ docker inspect e2cf9ea13bb4</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;e2cf9ea13bb477e49f1c0ff75a683555d1a75ef953529087375c83ee1a88b65f&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2018-05-12T06:17:14.979076095Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我們可以隨時中斷或啟動該container</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop e2cf9ea13bb4</span><br><span class="line">docker start e2cf9ea13bb4</span><br></pre></td></tr></table></figure>

<h3 id="提交改變成為新的image"><a href="#提交改變成為新的image" class="headerlink" title="提交改變成為新的image"></a>提交改變成為新的image</h3><p>看看該container有什麼改變</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker diff e2cf9ea13bb4</span><br><span class="line">C /run</span><br><span class="line">A /run/nginx.pid</span><br><span class="line">C /var</span><br><span class="line">C /var/cache/nginx</span><br><span class="line">A /var/cache/nginx/client_temp</span><br><span class="line">A /var/cache/nginx/fastcgi_temp</span><br><span class="line">A /var/cache/nginx/proxy_temp</span><br><span class="line">A /var/cache/nginx/scgi_temp</span><br><span class="line">A /var/cache/nginx/uwsgi_temp</span><br><span class="line">A /var/www</span><br></pre></td></tr></table></figure>

<p>commit我們所做的改變變成新的image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker commit -m <span class="string">&quot;New nginx&quot;</span> -a <span class="string">&quot;evshary&quot;</span> e2cf new_nginx</span><br><span class="line">sha256:ed66214b3e3a510a7cc47e341f64f6596560164d6f06a22f93dca8d05ecac081</span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">new_nginx           latest              ed66214b3e3a        17 seconds ago      109MB</span><br><span class="line">nginx               latest              ae513a47849c        11 days ago         109MB</span><br></pre></td></tr></table></figure>

<p>可以從history看我們所做改變歷史</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> new_nginx</span><br><span class="line">IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT</span><br><span class="line">ed66214b3e3a        About a minute ago   nginx -g daemon off;                            2B                  New nginx</span><br><span class="line">ae513a47849c        11 days ago          /bin/sh -c <span class="comment">#(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B</span></span><br><span class="line">&lt;missing&gt;           11 days ago          /bin/sh -c <span class="comment">#(nop)  STOPSIGNAL [SIGTERM]         0B</span></span><br></pre></td></tr></table></figure>

<h3 id="刪除container-images"><a href="#刪除container-images" class="headerlink" title="刪除container&#x2F;images"></a>刪除container&#x2F;images</h3><p>玩膩了，可以刪除images，記得要先刪掉container才行刪images喔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">rm</span> e2cf9ea13bb4</span><br><span class="line">$ docker rmi new_nginx</span><br><span class="line">Untagged: new_nginx:latest</span><br><span class="line">Deleted: sha256:ed66214b3e3a510a7cc47e341f64f6596560164d6f06a22f93dca8d05ecac081</span><br><span class="line">$ docker rmi nginx</span><br><span class="line">Deleted: sha256:ae513a47849c895a155ddfb868d6ba247f60240ec8495482eca74c4a2c13a881</span><br><span class="line">Deleted: sha256:160a8bd939a9421818f499ba4fbfaca3dd5c86ad7a6b97b6889149fd39bd91dd</span><br><span class="line">Deleted: sha256:f246685cc80c2faa655ba1ec9f0a35d44e52b6f83863dc16f46c5bca149bfefc</span><br><span class="line">Deleted: sha256:d626a8ad97a1f9c1f2c4db3814751ada64f60aed927764a3f994fcd88363b659</span><br></pre></td></tr></table></figure>

<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://philipzheng.gitbooks.io/docker_practice/content/">Docker —— 從入門到實踐</a></li>
<li><a href="https://peihsinsu.gitbooks.io/docker-note-book/content/">Docker學習筆記</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg影音處理工具</title>
    <url>/2018/12/01/ffmpeg%E5%BD%B1%E9%9F%B3%E8%99%95%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>有時候需要對影片、音樂做各種處理，例如轉檔、切割等等，這時候可以使用很強大的影音處理神器ffmpeg來做這些操作。</p>
<p>這邊不會細談調整編碼等細節，只是記錄日常常用到的操作指令而已。</p>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="轉檔"><a href="#轉檔" class="headerlink" title="轉檔"></a>轉檔</h3><p>-f代表format</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i [要轉的檔案] -f [目標格式] [輸出檔名]</span><br></pre></td></tr></table></figure>

<p>有哪些格式可選可用如下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -formats</span><br></pre></td></tr></table></figure>

<h3 id="裁減影片"><a href="#裁減影片" class="headerlink" title="裁減影片"></a>裁減影片</h3><p>-ss代表從何時開始，-t代表維持時間，-to代表停止的時間</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 從5秒開始後的30秒</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -ss 00:00:05 -t 00:00:30 [輸出檔名]</span><br><span class="line"><span class="comment"># 從5秒到25秒</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -ss 00:00:05 -to 00:00:25 [輸出檔名]</span><br></pre></td></tr></table></figure>

<h3 id="顛倒影像"><a href="#顛倒影像" class="headerlink" title="顛倒影像"></a>顛倒影像</h3><p>-vf代表vedio filter，可以讓影片經過處理，轉換影片角度有下面三種常用</p>
<ul>
<li>hflip：水平翻轉</li>
<li>vflip：垂直翻轉</li>
<li>transpose&#x3D;1：順時針轉90度</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 水平翻轉</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -vf hflip [輸出檔名]</span><br><span class="line"><span class="comment"># 垂直翻轉</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -vf vflip [輸出檔名]</span><br><span class="line"><span class="comment"># 順時針轉90度</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -vf transpose=1 [輸出檔名]</span><br><span class="line"><span class="comment"># 逆時針轉90度</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -vf transpose=2 [輸出檔名]</span><br></pre></td></tr></table></figure>

<h3 id="影片截圖"><a href="#影片截圖" class="headerlink" title="影片截圖"></a>影片截圖</h3><p>-an代表不需要聲音，-vframes代表要抓幾張圖，-r代表每秒抓幾張圖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i [要轉的檔案] -an -ss [抓取時間] -vframes [幾張圖] -r [幾張圖] [輸出圖檔]</span><br><span class="line"><span class="comment"># 在開始的時間抓一張圖</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -an -ss 00:00:00 -vframes 1 cover.jpg</span><br><span class="line"><span class="comment"># 從頭開始，每10秒抓一張圖</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -an -ss 00:00:00 -vframes 1 -r 0.1 tmp-%d.jpg</span><br></pre></td></tr></table></figure>

<h3 id="調整音量大小"><a href="#調整音量大小" class="headerlink" title="調整音量大小"></a>調整音量大小</h3><p>-vol代表聲音大小，256是正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i [要轉的檔案] -n [聲音大小] [輸出檔名]</span><br></pre></td></tr></table></figure>

<h3 id="播放影音"><a href="#播放影音" class="headerlink" title="播放影音"></a>播放影音</h3><p>在ffmpeg內有一個tool是ffplay，可以簡單用來播放影音</p>
<p>雖然沒有進度條，但是如果按著右鍵左右移動也會有進度條的效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffplay [影片名稱]</span><br></pre></td></tr></table></figure>

<ul>
<li>如果只想要播放音樂</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffplay -vn [影片名稱]</span><br></pre></td></tr></table></figure>

<ul>
<li>如果只想要播放影片</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffplay -an [影片名稱]</span><br></pre></td></tr></table></figure>

<ul>
<li>重複循環，0代表無限次</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffplay -loop [次數] [影片名稱]</span><br></pre></td></tr></table></figure>

<h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><ul>
<li><p>影片轉音樂</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i [要轉的檔案] -f mp3 [輸出檔名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>轉換成mp4</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i [要轉的檔案] -f mp4 [輸出檔名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>裁減影片</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i [要轉的檔案] -ss [開始時間] -to [結束時間] [輸出檔名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>抓截圖</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i [要轉的檔案] -an -ss 00:00:00 -vframes 1 cover.jpg</span><br></pre></td></tr></table></figure>
</li>
<li><p>聲音調整</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 調大聲音</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -vol 300 [輸出檔名]</span><br><span class="line"><span class="comment"># 調小聲音</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -vol 200 [輸出檔名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>手機拍攝如果是反的情況</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 順時針</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -vf transpose=1 [輸出檔名]</span><br><span class="line"><span class="comment"># 逆時針</span></span><br><span class="line">ffmpeg -i [要轉的檔案] -vf transpose=2 [輸出檔名]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://medium.com/@NorthBei/ffmepg-%E9%96%8B%E6%BA%90%E4%B8%94%E5%8A%9F%E8%83%BD%E5%BC%B7%E5%A4%A7%E7%9A%84%E5%BD%B1%E9%9F%B3%E8%99%95%E7%90%86%E6%A1%86%E6%9E%B6-568f19388103">FFmepg — 開源且功能強大的影音處理框架</a> - 針對ffmepg的架構進行介紹</li>
<li><a href="https://www.mobile01.com/topicdetail.php?f=510&t=4487488">FFmpeg 常用選項功能說明</a></li>
<li><a href="https://hk.saowen.com/a/ef089cf4a8cf6dab94c276a8ee0fb38c13e25d9549c8d3cc89f0c4a9e7bf0b9b">ffplay常用命令</a></li>
<li><a href="http://wilsbur.pixnet.net/blog/post/146836324-ffmpeg%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%B4%B9">ffmpeg常用指令介紹</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc常用擴充功能</title>
    <url>/2018/06/09/gcc%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>GNU gcc其實在編譯時也可以帶許多特殊功能，讓程式更佳的彈性，並帶來優化或更好debug的效益。這邊我們主要介紹兩個功能，內建函式和屬性<code>__attribute__</code>。</p>
<h2 id="內建函式"><a href="#內建函式" class="headerlink" title="內建函式"></a>內建函式</h2><p>要特別注意的是，這些內建函數是跟CPU架構息息相關，所以並不是每個平台都可以順利使用。另外就是編譯的時候不能帶上<code>-fno-builtin</code>選項，通常<code>-fno-builtin</code>是為了幫助我們確保程式的結果是如同我們所想像的樣子呈現，而不會被一些最佳化改變樣子，方便設定breakpoint和debug。</p>
<h3 id="找呼叫者"><a href="#找呼叫者" class="headerlink" title="找呼叫者"></a>找呼叫者</h3><p>首先我們先來談談找呼叫者這件事，我想大家應該都有經驗曾經發現程式死在某一行，但是卻不知道是誰呼叫的，這時候只能痛苦地去從stack反推return address。但是其實gcc內是有特殊內建函式可以幫助我們的，這邊介紹下面兩個好用函式。</p>
<ul>
<li><code>void *builtin_return_address(unsigned int LEVEL)</code>：找到函式的return address是什麼，參數的LEVEL代表要往上找幾層，填0的話代表呼叫當前函式者的下一個執行指令。</li>
<li><code>void *builtin_frame_address(unsigned int LEVEL)</code>：找到函式的frame pointer，參數的LEVEL代表要往上找幾層，填0的話代表呼叫當前函式者的frame pointer。</li>
</ul>
<p>要注意的是LEVEL不能填變數，也就是編譯時必須確定該數字。</p>
<h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><p>我們還是透過一個簡單的例子來說明一下</p>
<p>test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret_addr, *frame_addr;</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">1</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">2</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">3</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret_addr, *frame_addr;</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">1</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">2</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test2\n&quot;</span>);</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret_addr, *frame_addr;</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">1</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1\n&quot;</span>);</span><br><span class="line">    test2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret_addr, *frame_addr;</span><br><span class="line">    ret_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    frame_addr = __builtin_frame_address(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret_addr=0x%x frame_addr=0x%x\n&quot;</span>, ret_addr, frame_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好，那我們來編譯並執行看看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br><span class="line">$ ./test</span><br><span class="line">0: ret_addr=0x4007c8 frame_addr=0x2bba8ba0</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">0: ret_addr=0x4007bc frame_addr=0x2bba8b80</span><br><span class="line">1: ret_addr=0x4007c8 frame_addr=0x2bba8ba0</span><br><span class="line">test1</span><br><span class="line">0: ret_addr=0x40076d frame_addr=0x2bba8b60</span><br><span class="line">1: ret_addr=0x4007bc frame_addr=0x2bba8b80</span><br><span class="line">2: ret_addr=0x4007c8 frame_addr=0x2bba8ba0</span><br><span class="line">test2</span><br><span class="line">0: ret_addr=0x4006e1 frame_addr=0x2bba8b40</span><br><span class="line">1: ret_addr=0x40076d frame_addr=0x2bba8b60</span><br><span class="line">2: ret_addr=0x4007bc frame_addr=0x2bba8b80</span><br><span class="line">3: ret_addr=0x4007c8 frame_addr=0x2bba8ba0</span><br><span class="line">test3</span><br></pre></td></tr></table></figure>

<p>可以看到每層function所對應的return address和frame address都被列出來，但是要怎麼驗證是否真的是這樣呢？我們把程式逆向一下看位置。這邊我們鎖定test1()的return address，也就是0x4007bc，應該是test()函式的呼叫test1()的下一行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -d <span class="built_in">test</span></span><br><span class="line">...</span><br><span class="line">0000000000400770 &lt;<span class="built_in">test</span>&gt;:</span><br><span class="line">  400770:       55                      push   %rbp</span><br><span class="line">  400771:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">...</span><br><span class="line">  4007b2:       e8 59 <span class="built_in">fc</span> ff ff          callq  400410 &lt;puts@plt&gt;</span><br><span class="line">  4007b7:       e8 28 ff ff ff          callq  4006e4 &lt;test1&gt;</span><br><span class="line">  4007bc:       90                      nop</span><br><span class="line">  4007bd:       c9                      leaveq</span><br><span class="line">  4007be:       c3                      retq</span><br><span class="line"></span><br><span class="line">00000000004007bf &lt;main&gt;:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>的確，下一行nop的位置就是就是4007bc，符合我們的想法。</p>
<h3 id="其他有用的builtin函式"><a href="#其他有用的builtin函式" class="headerlink" title="其他有用的builtin函式"></a>其他有用的builtin函式</h3><p>除了上面的例子，其實還有其他有用的builtin函式，這邊就只是列出來提供參考：</p>
<ul>
<li><code>int __builtin_types_compatible_p(TYPE1, TYPE2)</code>：檢查TYPE1和TYPE2是否是相同type，相同回傳1，否則為0。注意這邊const和非const會視為同種類型。</li>
<li><code>TYPE __builtin_choose_expr(CONST_EXP, EXP1, EXP2)</code>：同<code>CONST_EXP?EXP1:EXP2</code>的概念，但是這個寫法會在編譯時就決定結果。常用方式是在寫macro時可以搭配<code>__builtin_types_compatible_p</code>當作CONST_EXP，選擇要呼叫什麼函式。</li>
<li><code>int __builtin_constant_p(EXP)</code>：判斷EXP是否是常數。</li>
<li><code>long __builtin_expect(long EXP, long C)</code>：預先知道EXP的值很大機率會是C，藉此做最佳化，kernel的likely和unlikely也是靠這個實現的。</li>
<li><code>void __builtin_prefetch(const void *ADDR, int RW, int LOCALITY)</code>：把ADDR預先載入快取使用。<ul>
<li>RW：1代表會寫入資料，0代表只會讀取</li>
<li>LOCALITY：範圍是0~3，0代表用了馬上就不用(不用關心time locality)、3代表之後還會常用到</li>
</ul>
</li>
<li><code>int __builtin_ffs (int X)</code>：回傳X中從最小位數開始計算第一個1的位置，例如<code>__builtin_ffs(0xc)=3</code>，當X是0時，回傳0。</li>
<li><code>int __builtin_popcount (unsigned int X)</code>：在X中1的個數</li>
<li><code>int __builtin_ctz (unsigned int X)</code>：X末尾的0個數，X&#x3D;0時undefined。</li>
<li><code>int __builtin_clz (unsigned int X)</code>：X前面的0個數，X&#x3D;0時undefined。</li>
<li><code>int __builtin_parity (unsigned int x)</code>：Ｘ值的parity。</li>
</ul>
<h2 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a><code>__attribute__</code></h2><h3 id="weak-alias"><a href="#weak-alias" class="headerlink" title="weak &amp; alias"></a>weak &amp; alias</h3><h4 id="測試是否支援某function"><a href="#測試是否支援某function" class="headerlink" title="測試是否支援某function"></a>測試是否支援某function</h4><p>通常會使用<code>__attribute__(weak)</code>是為了避免有函式衝突的狀況，我們看個例子</p>
<p>a.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">printf_test</span><span class="params">(<span class="type">void</span>)</span> __<span class="title function_">attribute__</span><span class="params">((weak))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is main function\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(printf_test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Here is printf_test result: \n&quot;</span>);</span><br><span class="line">        printf_test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;We don&#x27;t support printf_test\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make a</span><br><span class="line">$ ./a</span><br><span class="line">This is main <span class="keyword">function</span></span><br><span class="line">We don<span class="string">&#x27;t support printf_test</span></span><br></pre></td></tr></table></figure>

<p>雖然我們沒有printf_test，但是直接編譯是會通過的，因為printf_test被視為weak，假設在連結時找不到，是會被填0的。</p>
<p>那如果有printf_test的情況呢？我們加上b.c重新編譯看看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is b function.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc a.c b.c</span><br><span class="line">$ ./a.out</span><br><span class="line">This is main <span class="keyword">function</span></span><br><span class="line">Here is printf_test result:</span><br><span class="line">This is b <span class="keyword">function</span>.</span><br></pre></td></tr></table></figure>

<p>看起來就會執行printf_test了。這樣的功能對我們要動態看有無支援函式幫助很大。</p>
<h4 id="為函式加上default值"><a href="#為函式加上default值" class="headerlink" title="為函式加上default值"></a>為函式加上default值</h4><p>這邊我們會用到alias的attribute，alias的話通常會跟weak一起使用，最常被用到的是幫不確定有無支援的函式加上default值。</p>
<p>a.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_default</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not support this function.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_foo</span><span class="params">(<span class="type">void</span>)</span> __<span class="title function_">attribute__</span><span class="params">((weak, alias(<span class="string">&quot;print_default&quot;</span>)))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_bar</span><span class="params">(<span class="type">void</span>)</span> __<span class="title function_">attribute__</span><span class="params">((weak, alias(<span class="string">&quot;print_default&quot;</span>)))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is main function\n&quot;</span>);</span><br><span class="line">    print_foo();</span><br><span class="line">    print_bar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo function.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc a.c b.c</span><br><span class="line">$ ./a.out</span><br><span class="line">This is main <span class="keyword">function</span></span><br><span class="line">foo <span class="keyword">function</span>.</span><br><span class="line">Not support this <span class="keyword">function</span>.</span><br></pre></td></tr></table></figure>

<p>可以看到因為print_bar並沒有被宣告，所以最後會執行alias的print_default。</p>
<h3 id="在main前後執行程式"><a href="#在main前後執行程式" class="headerlink" title="在main前後執行程式"></a>在main前後執行程式</h3><p>有時候會想要在main的執行前後可以做些事，這時候就會用到下面兩個attribute</p>
<ul>
<li>constructor：main前做事</li>
<li>destructor：main之後做事</li>
</ul>
<p>讓我們看個範例</p>
<p>test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="type">void</span> <span class="title function_">before</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before main\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor))</span><br><span class="line"><span class="type">void</span> <span class="title function_">after</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after main\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is main function\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br><span class="line">$ ./test</span><br><span class="line">before main</span><br><span class="line">This is main <span class="keyword">function</span></span><br><span class="line">after main</span><br></pre></td></tr></table></figure>

<p>結果的確如我們所料。另外這邊有點要注意，跟前面不一樣的是，<code>__attribute__((constructor))</code>和<code>__attribute__((destructor))</code>必須放在函式前面，不然會有<code>error: attributes should be specified before the declarator in a function definition</code>的錯誤。</p>
<h3 id="其他attribute"><a href="#其他attribute" class="headerlink" title="其他attribute"></a>其他attribute</h3><p>剩下還有一些有機會會用到的attribute，這邊就不多談，只列出來參考。</p>
<ul>
<li><code>__attribute__((section(&quot;section_name&quot;)))</code>：代表要把這個symbol放到<code>section_name</code>中</li>
<li><code>__attribute__((used))</code>：不管有沒有被引用，這個symbol都不會被優化掉</li>
<li><code>__attribute__((unused))</code>：沒有被引用到的時候也不會跳出警告</li>
<li><code>__attribute__((deprecated))</code>：用到的時候會跳出警告，用來警示使用者這個函式將要廢棄</li>
<li><code>__attribute__((stdcall))</code>：從右到左把參數放入stack，由callee(被呼叫者)把stack恢復正常</li>
<li><code>__attribute__((cdecl))</code>：C語言預設的作法，從右到左把參數放入stack，由caller把stack恢復正常</li>
<li><code>__attribute__((fastcall))</code>：頭兩個參數是用register來存放，剩下一樣放入stack</li>
</ul>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="http://www.books.com.tw/products/0010587783">BINARY HACKS：駭客秘傳技巧一百招</a></li>
<li><a href="https://blog.csdn.net/jasonchen_gbd/article/details/44948523">gcc的__builtin_函数介绍</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">6.57 Other Built-in Functions Provided by GCC</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_a9303fd90101d5su.html"><code>__attribute__</code>之weak,alias属性</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
        <tag>系統程式</tag>
      </tags>
  </entry>
  <entry>
    <title>gnuplot：報告必備的繪圖工具</title>
    <url>/2018/12/02/gnuplot%EF%BC%9A%E5%A0%B1%E5%91%8A%E5%BF%85%E5%82%99%E7%9A%84%E7%B9%AA%E5%9C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>當我們要製作報告或論文的圖表時，除了excel以外，其實也可以使用gnuplot這套工具。<a href="http://www.gnuplot.info/">gnuplot</a>非常的強大，除了可以畫各種圖表以外，還可以跨不同平台使用。</p>
<p>我們這邊簡單紀錄一些常用圖表怎麼繪畫。</p>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p>如果我們要正常顯示圖表的話需要有x11，這部分可以安裝APPLE的<a href="https://www.xquartz.org/">XQuartz</a>即可，這樣啟動gnuplot的時候就會自動啟動XQuartz了，可參考<a href="https://apple.stackexchange.com/questions/103814/cant-plot-with-gnuplot-on-my-mac">Can’t plot with gnuplot on my Mac</a></p>
<p>接下來安裝gnuplot的時候要特別注意，如果沒有加上<code>--with-x11</code>的話，可能會造成<code>Terminal type set to &#39;unknown&#39;</code>的warning，可參考<a href="https://stackoverflow.com/questions/24721305/cant-find-x11-terminal-in-gnuplot-octave-on-mac-os">Can’t find x11 terminal in gnuplot Octave on Mac OS</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install gnuplot --with-x11</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 啟動</span></span><br><span class="line">gnuplot</span><br><span class="line"><span class="comment"># 畫出sin(x)的圖</span></span><br><span class="line">plot sin(x)</span><br><span class="line"><span class="comment"># 設定範圍，x軸是-10到10，y軸是0到2的cos(x)</span></span><br><span class="line">plot [x=-10:10] [0:2] cos(x)</span><br><span class="line"><span class="comment"># 清空之前的設定</span></span><br><span class="line">reset</span><br><span class="line"><span class="comment"># 結束</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h3 id="讀取檔案"><a href="#讀取檔案" class="headerlink" title="讀取檔案"></a>讀取檔案</h3><p>我們可以把多筆資料先存成檔案，然後再讓gnuplot來讀</p>
<p>我們先存資料到data.txt，中間用空格隔開</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 5</span><br><span class="line">2 10</span><br><span class="line">3 15</span><br><span class="line">4 10</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure>

<p>執行gnuplot就會看到有許多一點一點資料散佈在plot上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gnuplot</span><br><span class="line">plot <span class="string">&quot;data.txt&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果要開啟多個檔案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plot <span class="string">&quot;data1.txt&quot;</span>, <span class="string">&quot;data2.txt&quot;</span>, <span class="string">&quot;data3.txt&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="存成程式"><a href="#存成程式" class="headerlink" title="存成程式"></a>存成程式</h3><p>每次都要自己一個個輸入指令說實在太麻煩了，我們可以存成.plt檔，以下面為例存成plot.plt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plot <span class="string">&quot;data.txt&quot;</span></span><br></pre></td></tr></table></figure>

<p>進入gnuplot後輸入如下指令即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">load <span class="string">&quot;plot.plt&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="圖表上的文字"><a href="#圖表上的文字" class="headerlink" title="圖表上的文字"></a>圖表上的文字</h3><p>圖表上面總是要有些文字說明，可參考如下設定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 設定標題</span></span><br><span class="line"><span class="built_in">set</span> title <span class="string">&quot;pic_title&quot;</span></span><br><span class="line"><span class="comment"># x軸說明</span></span><br><span class="line"><span class="built_in">set</span> xlabel <span class="string">&quot;x(unit)&quot;</span></span><br><span class="line"><span class="comment"># y軸說明</span></span><br><span class="line"><span class="built_in">set</span> ylabel <span class="string">&quot;y(unit)&quot;</span></span><br><span class="line"><span class="comment"># 設定線條說明外框</span></span><br><span class="line"><span class="built_in">set</span> key box</span><br><span class="line"><span class="comment"># 不要線條說明</span></span><br><span class="line"><span class="built_in">set</span> nokey</span><br><span class="line"><span class="comment"># 如果要修改線條說明</span></span><br><span class="line">plot <span class="string">&quot;data1.txt&quot;</span> title <span class="string">&quot;title 1&quot;</span>, <span class="string">&quot;data2.txt&quot;</span> title <span class="string">&quot;title 2&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="圖表的顯示"><a href="#圖表的顯示" class="headerlink" title="圖表的顯示"></a>圖表的顯示</h3><p>也許我們會想改變圖表上面的顯示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加格線</span></span><br><span class="line"><span class="built_in">set</span> grid</span><br><span class="line"><span class="comment"># 數據連成一條線</span></span><br><span class="line"><span class="built_in">set</span> style data lines</span><br><span class="line"><span class="comment"># x軸的範圍</span></span><br><span class="line"><span class="built_in">set</span> xrange [-10:10]</span><br><span class="line"><span class="comment"># y軸的範圍</span></span><br><span class="line"><span class="built_in">set</span> yrange [-10:10]</span><br><span class="line"><span class="comment"># X軸的單位</span></span><br><span class="line"><span class="built_in">set</span> xtics x: 每次x軸都增加x</span><br></pre></td></tr></table></figure>

<p>plot上其實也可以做一些操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用data.txt，並且畫成線，linestyle為1，linewidth也為1</span></span><br><span class="line">plot <span class="string">&quot;data.txt&quot;</span> with lines linestyle 1 linewidth 1</span><br><span class="line"><span class="comment"># 使用data.txt，pointtype為1，pointsize也為1</span></span><br><span class="line">plot <span class="string">&quot;data.txt&quot;</span> with point pointtype 1 pointsize 1</span><br><span class="line"><span class="comment"># 如果線和點都要的話</span></span><br><span class="line">plot <span class="string">&quot;data.txt&quot;</span> with linespoints</span><br><span class="line"><span class="comment"># 如果要變成長條圖的話</span></span><br><span class="line">plot <span class="string">&quot;data.txt&quot;</span> with boxes</span><br></pre></td></tr></table></figure>

<h3 id="儲存成圖片"><a href="#儲存成圖片" class="headerlink" title="儲存成圖片"></a>儲存成圖片</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要存成png檔案</span></span><br><span class="line"><span class="built_in">set</span> terminal png</span><br><span class="line"><span class="comment"># 可以加上size資訊</span></span><br><span class="line"><span class="built_in">set</span> terminal png size 1200,800</span><br><span class="line"><span class="comment"># 輸出圖片，這個指令會等待後續的plot</span></span><br><span class="line"><span class="built_in">set</span> output <span class="string">&quot;output.png&quot;</span></span><br><span class="line"><span class="comment"># 輸出圖片</span></span><br><span class="line">plot .....</span><br><span class="line"><span class="comment"># 記得要再改回x11</span></span><br><span class="line"><span class="built_in">set</span> terminal x11</span><br></pre></td></tr></table></figure>

<h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><ul>
<li>折線圖<ul>
<li>先產生出data.txt</li>
<li>使用在gnuplot中load如下plt檔</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reset</span><br><span class="line"><span class="built_in">set</span> title <span class="string">&quot;pic_title&quot;</span></span><br><span class="line"><span class="built_in">set</span> xlabel <span class="string">&quot;x(unit)&quot;</span></span><br><span class="line"><span class="built_in">set</span> ylabel <span class="string">&quot;y(unit)&quot;</span></span><br><span class="line"><span class="built_in">set</span> terminal png</span><br><span class="line"><span class="built_in">set</span> output <span class="string">&quot;output.png&quot;</span></span><br><span class="line">plot <span class="string">&quot;data.txt&quot;</span> with linespoints title <span class="string">&quot;title 1&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>長條圖<ul>
<li>先產生出data.txt</li>
<li>使用在gnuplot中load如下plt檔</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reset</span><br><span class="line"><span class="built_in">set</span> title <span class="string">&quot;pic_title&quot;</span></span><br><span class="line"><span class="built_in">set</span> xlabel <span class="string">&quot;x(unit)&quot;</span></span><br><span class="line"><span class="built_in">set</span> ylabel <span class="string">&quot;y(unit)&quot;</span></span><br><span class="line"><span class="built_in">set</span> terminal png</span><br><span class="line"><span class="built_in">set</span> output <span class="string">&quot;output.png&quot;</span></span><br><span class="line"><span class="comment"># 設定長條圖的size</span></span><br><span class="line"><span class="built_in">set</span> boxwidth 0.3</span><br><span class="line">plot <span class="string">&quot;data.txt&quot;</span> with boxes title <span class="string">&quot;title 1&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="http://applezulab.netdpi.net/08-useful-tools/gnuplot_basic">實驗基本數據製圖指令 gnuplot</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10158860">Gnuplot 簡單數據繪圖</a></li>
<li><a href="https://hackmd.io/s/Skwp-alOg">gnuplot 語法解說和示範</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 教學</title>
    <url>/2017/09/09/hexo%E6%95%99%E5%AD%B8/</url>
    <content><![CDATA[<p>我之前一直想要自己寫 blog，可以留下些記錄，但是一方面不想要自己架 server，管理有點麻煩。另一方面又希望可以有 markdown 的功能，而這是 Google 的 blogger 所欠缺的，後來發現可以使用 hexo+Github 架設自己的 blog，對我而言是最佳選擇。Github 讓我不用自己架 server，hexo 讓我可以快速有個漂亮的介面，而且還可以用 markdown 來寫 blog。</p>
<h2 id="第一次安裝"><a href="#第一次安裝" class="headerlink" title="第一次安裝"></a>第一次安裝</h2><p>這邊一開始要先安裝好 git 和 npm，兩者的使用就不在這邊多提了。</p>
<ol>
<li><p>先在 GitHub 上創立一個新的 repo，像我的話就是 <code>evshary.github.io</code></p>
</li>
<li><p>clone 下來並且創立 main 和 source 兩個 branch，這兩個 branch 分別有不同用途，main 用來放顯示的網頁，source 用來放產生網頁的原始檔</p>
</li>
<li><p>首先先切到 source 的 branch，然後開始安裝 hexo (當然要先裝好 npm)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安裝 hexo command line tool</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="comment"># 安裝 deployer</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>_config.yml</code> 的 deploy 參數，branch 改為 main，這個代表的意思是我們會把產生的網頁放到 main 這個 branch 上</p>
</li>
<li><p>執行 <code>hexo g</code> 來產生顯示的網頁</p>
</li>
<li><p>當我們修改好 blog，就可以把 source 的 branch commit 並且 push 上 GitHub</p>
</li>
<li><p>最後執行 <code>hexo d</code> 就可以上傳網頁了，這個動作代表著把 main push 上 GitHub</p>
</li>
<li><p>未來的使用都是在 source 的 branch 下 commit 並 push，然後才用<code>hexo d</code> 上傳</p>
</li>
</ol>
<p>備註：<code>hexo d</code>的上傳可以用 GitHub Action 取代，只要 source branch 有更新，就會自動在 main branch 產生 blog 結果。相關設定可以參考<a href="https://github.com/evshary/evshary.github.io/blob/source/.github/workflows/deploy.yaml">這邊的範例</a></p>
<h2 id="重裝"><a href="#重裝" class="headerlink" title="重裝"></a>重裝</h2><p>未來要在新電腦重建環境就不用像第一次那麼麻煩了</p>
<ol>
<li><p>首先在新電腦把 blog 的 repo clone 下來並切到 source 的 branch，如下面指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b <span class="built_in">source</span> git@github.com:[你的github帳號]/[repo名稱].git</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新安裝相依套件，然後就可以直接開始使用了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>建立新文章<br>一開始最重要的事怎麼建立新文章</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;文章主題&quot;</span></span><br></pre></td></tr></table></figure>

<p>這時候會在<code>source/_posts/</code>底下新增一個md檔案，打開它就可以開始寫blog了</p>
</li>
<li><p>根據 markdown 產生 html 頁面</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>產生結果會在 <code>public</code> 資料夾下</p>
</li>
<li><p>local 端預覽<br>寫完之後的當然要產生頁面來看自己寫的如何，下面這個指令可以建立測試的 server</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>這時候開瀏覽器連線 <code>http://localhost:4000</code> 應該就可以連上</p>
</li>
<li><p>push 到 GitHub 上</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h2><p>使用 hexo 當然最重要的是漂亮的主題囉，hexo 的 GitHub 上已經有提供許多主題推薦，可以參考 <a href="https://github.com/hexojs/hexo/wiki/Themes">Themes</a>。不過我個人覺得 <a href="https://github.com/theme-next/hexo-theme-next">theme-next&#x2F;hexo-theme-next</a> 比較好看，所以就用這個了。</p>
<p><a href="https://theme-next.js.org/docs/getting-started/installation">官網推薦的安裝方法有兩種</a> ，一個是用 npm，另一個是直接 clone repo，為了方便未來升級管理，這邊使用 npm 的方式</p>
<ol>
<li><p>用 npm 下載 hexo-theme-next，套件會出現在 node_modules 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>設定檔的部份會先找當前目錄下的 <code>_config.next.yml</code>，所以我們先複製一份設定檔出來</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>接著在 hexo 的設定檔 <code>_config.yml</code> 修改 theme 關鍵字，也就是剛剛命名的 next，這樣就順利完成了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="設定檔"><a href="#設定檔" class="headerlink" title="設定檔"></a>設定檔</h2><p>主要會修改到的設定檔有兩個：</p>
<ul>
<li>hexo: 位於 <code>_config.yml</code><ul>
<li><a href="https://hexo.io/docs/configuration">hexo 官方設定教學</a></li>
</ul>
</li>
<li>hexo-theme-next: <code>_config.next.yml</code><ul>
<li><a href="https://theme-next.js.org/docs/getting-started/configuration.html">hexo-theme-next 官方教學</a></li>
</ul>
</li>
</ul>
<h2 id="套件"><a href="#套件" class="headerlink" title="套件"></a>套件</h2><p>當然 hexo 提供很多套件，我目前用到的是下面這兩個</p>
<h3 id="google-analytics"><a href="#google-analytics" class="headerlink" title="google analytics"></a>google analytics</h3><p>可參考 <a href="https://blog.marsen.me/2016/08/25/add_google_analytics_to_hexo_blog_1/">如何讓google analytics追踪你的Hexo Blog</a><br>使用方法很簡單，這個功能在 theme 中已經內建，只要開啟即可</p>
<ol>
<li><p>先打開 <code>_config.next.yml</code></p>
</li>
<li><p>找到下列字串</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line">  <span class="attr">tracking_id:</span></span><br></pre></td></tr></table></figure>

<p>在 tracking_id 後面填上自己申請的 google analytics ID 就可以了。</p>
</li>
</ol>
<h3 id="Disqus的留言板功能"><a href="#Disqus的留言板功能" class="headerlink" title="Disqus的留言板功能"></a>Disqus的留言板功能</h3><p>可參考 <a href="https://blog.ivanwei.co/2016/01/03/2016-01-03-add-disqus-to-blog-by-hexo/">[Hexo] 加入 Disqus 讓 Blog多個留言功能</a><br>部署在 GitHub 的 hexo 沒有讓訪客留言的功能，所以這時候就需要第三方的整合型留言板 Disqus 了<br>這個也是跟 theme 綁一起的</p>
<ol>
<li><p>開啟 <code>_config.next.yml</code></p>
</li>
<li><p>找到下列字串</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">evshary</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>確認 enable 為 true，然後在 shortname 填上自己在Disquz註冊的short name就可以囉！</p>
</li>
</ol>
<h3 id="LocalSearch-的搜尋功能"><a href="#LocalSearch-的搜尋功能" class="headerlink" title="LocalSearch 的搜尋功能"></a>LocalSearch 的搜尋功能</h3><p>我們如果要 blog 支援搜尋功能，可參考 <a href="https://www.itfanr.cc/2017/10/27/add-search-function-to-hexo-blog/">Hexo博客添加搜索功能</a> ，下面列出應該要做的步驟</p>
<ol>
<li><p>首先要安裝 <code>hexo-generator-searchdb</code> 套件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>接著在 <code>_config.yml</code> 新增如下設定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>開啟<code>_config.next.yml</code>，修改 enable 設定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最後重新生成啟動即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s -g</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="如果搜尋功能不斷轉圈圈"><a href="#如果搜尋功能不斷轉圈圈" class="headerlink" title="如果搜尋功能不斷轉圈圈"></a>如果搜尋功能不斷轉圈圈</h4><p>通常會有一種情況搜尋功能會有問題，就是產生的search.xml有文字編碼錯誤</p>
<ol>
<li>先檢查 search.xml 的語法，可使用 <a href="https://www.xmlvalidation.com/">Validate an XML file</a> 這個線上網站</li>
<li>網站會告訴你哪邊有錯誤的編碼，可以直接進去修改</li>
<li>如果使用 vscode 的話可以從設定啟動 renderControlCharacters，就會顯示錯誤的字元了</li>
<li>如果有必要可以直接把該字元複製並且使用全域搜尋並修正(因為我們沒辦法打出該字元)</li>
</ol>
<p>詳情可參考 <a href="https://guahsu.io/2017/12/Hexo-Next-LocalSearch-cant-work/">HEXO-NexT的Local Search轉圈圈問題</a></p>
<h3 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h3><p>如果要在 hexo 上加上 RSS 訂閱，需要使用 hexo-generator-feed 套件</p>
<ol>
<li><p>先安裝 hexo-generator-feed</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>_config.yml</code> 內加上如下內容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RSS</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最後重新生成啟動即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可參考 <a href="https://segmentfault.com/a/1190000012647294">为hexo博客添加RSS订阅功能</a></p>
<h2 id="增加-live2d"><a href="#增加-live2d" class="headerlink" title="增加 live2d"></a>增加 live2d</h2><ol>
<li><p>先安裝必要的 npm 包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br><span class="line">npm install live2d-widget-model-shizuku --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>設定 <code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># live2d</span></span><br><span class="line"><span class="comment"># https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-shizuku</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最後重新生成啟動即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可參考 <a href="https://bearbeargo.com/posts/how-to-play-with-live2d-on-hexo/">用Live2D让看板喵入住你的Hexo博客吧(^o^)&#x2F;~</a></p>
<p>不過這邊提一下，<a href="https://github.com/EYHN/hexo-helper-live2d">EYHN&#x2F;hexo-helper-live2d</a> 已經沒有再更新了，如果上到 GitHub，可能會有些套件安全疑慮，以後可能需要找些替代套件了。</p>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>linker script 簡單教學</title>
    <url>/2018/06/02/linker-script-%E7%B0%A1%E5%96%AE%E6%95%99%E5%AD%B8/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>最近由於工作常常會用到，所以打算來談談如何來撰寫 linker script，也可以當作未來自己參考用途。</p>
<p>linker的作用就是把輸入檔(object file)的 section 整理到輸出檔的 section。除此之外也會定下每個object file 中尚未確定的符號位址，所以如果有 object file 用到不存在的symbol，就會出現常看到的 <code>undefined reference error</code>。</p>
<p>而 linker script 就是提供給 linker 參考的文件，它告訴 linker 我想要怎麼擺放這些 section，甚至也可以定義程式的起始點在哪邊。</p>
<h2 id="簡單範例"><a href="#簡單範例" class="headerlink" title="簡單範例"></a>簡單範例</h2><p>最簡單的 linker script 是用<code>SECTIONS</code>指令去定義 section 的分佈。</p>
<p>test.ld</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">. = 0x10000;</span><br><span class="line">.text : &#123; *(.text) &#125;</span><br><span class="line">. = 0x8000000;</span><br><span class="line">.data : &#123; *(.data) &#125;</span><br><span class="line">.bss : &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例，<code>.</code>被稱作 location counter，代表的是指向現在的位址，我們可以讀取或是移動它 (我覺得可以想像成我們在打電腦文件時的游標，代表現在要處理這個位置)。</p>
<p>這段 script 主要做的事是，先把 location counter 移到 0x10000，在這裡寫入所有輸入檔的<code>.text section</code>後，再來移到0x8000000放所有輸入檔的<code>.data section</code>跟<code>.bss section</code>。</p>
<p>當然，最重要的還是去嘗試，所以讓我們來試試看，結果是不是真的像我們所想的。</p>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_bss;</span><br><span class="line"><span class="type">int</span> global_data = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    global_bss = <span class="number">0</span>;</span><br><span class="line">    test();</span><br><span class="line">    global_data++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// do nothing.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嘗試編譯並看結果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -c main.c test.c</span><br><span class="line">$ ld -T test.ld main.o test.o</span><br><span class="line">$ objdump -h a.out</span><br><span class="line"></span><br><span class="line">a.out:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000046  0000000000010000  0000000000010000  00010000  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .eh_frame     00000058  0000000000010048  0000000000010048  00010048  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .data         00000004  0000000008000000  0000000008000000  00200000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  3 .bss          00000004  0000000008000004  0000000008000004  00200004  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  4 .comment      00000011  0000000000000000  0000000000000000  00200004  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure>

<p>我們可以看到在VMA和LMA的地方，text是從0x10000開始，data和bss則是從0x8000000開始放，跟我們所安排的結果一樣。</p>
<p>這邊說明一下，一定會有人覺得奇怪，為什麼編譯出來的檔案無法執行，這個是因為我們並沒有符合 Linux 可執行的格式來 link，如果你想要知道一般我們下 gcc 是使用什麼 linker script 的話，可以使用如下方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -Wl,-verbose main.c test.c</span><br></pre></td></tr></table></figure>

<p>這樣就可以看到所使用的 linker script 了。</p>
<h2 id="常用的功能"><a href="#常用的功能" class="headerlink" title="常用的功能"></a>常用的功能</h2><p>接著我們來談談在linker script中常見到的功能，這邊我們可以參考 jserv 帶領成大同學開發的 rtenv 中的 <a href="https://github.com/southernbear/rtenv/blob/master/main.ld">linker script</a></p>
<p>那我們就一一了解每個符號的意義吧！</p>
<h3 id="ENTRY"><a href="#ENTRY" class="headerlink" title="ENTRY"></a>ENTRY</h3><p>用 ENTRY 可以指定程式進入點的符號，不設定的話 linker 會試圖用預設<code>.text</code>的起始點，或者用位址0的地方。</p>
<p>以 x86 為例，預設進入點是<code>ENTRY(_start)</code>，而 rtenv 則是設定為 <code>ENTRY(main)</code></p>
<h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h3><p>Linker 預設會取用全部的記憶體，我們可以用 MEMORY 指令指定記憶體大小，在 rtenv 的例子中，指定了 FLASH 跟 RAM 兩種的輸出位置與大小</p>
<p>ORIGIN代表起始位置，LENGTH為長度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">  FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 128K</span><br><span class="line">  RAM (rwx) : ORIGIN = 0x20000000, LENGTH = 20K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下來SECTION部分，就能用 &gt; 符號把資料寫到指定的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss : &#123;</span><br><span class="line">        _sbss = .;</span><br><span class="line">        *(.bss)         /* Zero-filled run time allocate data memory */</span><br><span class="line">        _ebss = .;</span><br><span class="line">    &#125; &gt;RAM</span><br></pre></td></tr></table></figure>

<h3 id="KEEP"><a href="#KEEP" class="headerlink" title="KEEP"></a>KEEP</h3><p>KEEP 指令保留某個符號不要被 garbage collection ，例如我們不希望 ARM 的 ISR vector 會被優化掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text :</span><br><span class="line">    &#123;</span><br><span class="line">        KEEP(*(.isr_vector))</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="section-的本體"><a href="#section-的本體" class="headerlink" title="section 的本體"></a>section 的本體</h3><p>section 的指定方式是 linker script 中的重點，其中也有許多設定。</p>
<p>我們可以參考<a href="https://sourceware.org/binutils/docs/ld/Output-Section-Attributes.html#Output-Section-Attributes">官方文件</a>先對 section 的功能做一個快速了解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section [address] [(type)] :</span><br><span class="line">  [AT(lma)]</span><br><span class="line">  [ALIGN(section_align) | ALIGN_WITH_INPUT]</span><br><span class="line">  [SUBALIGN(subsection_align)]</span><br><span class="line">  [constraint]</span><br><span class="line">  &#123;</span><br><span class="line">      output-section-command</span><br><span class="line">      output-section-command</span><br><span class="line">      ...</span><br><span class="line">  &#125; [&gt;region] [AT&gt;lma_region] [:phdr :phdr ...] [=fillexp]</span><br></pre></td></tr></table></figure>

<p>output-section-command 代表的就是我們要怎麼擺放每個 section。</p>
<p>在這個例子裡可以看到有許多 LMA，除了 LMA 外，其實還有 VMA，它們兩個究竟有什麼不同呢？</p>
<h4 id="LMA-VMA-的概念"><a href="#LMA-VMA-的概念" class="headerlink" title="LMA&#x2F;VMA 的概念"></a>LMA&#x2F;VMA 的概念</h4><p>這裡大概是最重要的部分，也是之前我一直搞不清楚的地方。</p>
<p>link script 中設計了兩種位址：VMA 和 LMA</p>
<table>
<thead>
<tr>
<th></th>
<th>LMA (Load Memory Address)</th>
<th>VMA (Virtual Memory Address)</th>
</tr>
</thead>
<tbody><tr>
<td>位置</td>
<td>ROM&#x2F;Flash</td>
<td>RAM</td>
</tr>
<tr>
<td>意義</td>
<td>程式碼保存的位置</td>
<td>程式碼執行的位址</td>
</tr>
</tbody></table>
<p>也就是 LMA 是 output file 的位置，VMA 是載入 section 到 RAM 時的位置，但是在大多數情況下兩者會是一樣的。</p>
<p>我們再看看上例是怎如何指定 LMA 和 VMA 的</p>
<ul>
<li>LMA 是用<code>AT</code>或<code>AT&gt;</code>來決定位址，為可選，沒指定就用VMA當LMA<ul>
<li><code>AT(LMA)</code>：告訴 linker 這個 section 應該要去哪個 LMA 載入資料到 VMA，要填 address</li>
<li><code>AT&gt;lma_region</code>：為 LMA 所在區域，需事先定義</li>
</ul>
</li>
<li><code>&gt;region</code>：為 VMA 所在區域，region需事先定義</li>
<li>在 linker script 的寫法基本上是這個架構<code>[VMA] : [AT(LMA)]</code></li>
</ul>
<p>繼續以 rtenv 為例，當指定了<code>_sidata</code>的 symbol 位置後，AT 就是要求載入到 FLASH 時要在<code>.text</code>的後面，換句話說<code>.data</code>的 LMA 要在<code>.text</code>後</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Initialized data will initially be loaded in FLASH at the end of the .text section. */</span><br><span class="line">.data : AT (_sidata)</span><br><span class="line">&#123;</span><br><span class="line">  _sdata = .;</span><br><span class="line">  *(.data)        /* Initialized data */</span><br><span class="line">  *(.data*)</span><br><span class="line">  _edata = .;</span><br><span class="line">&#125; &gt;RAM</span><br></pre></td></tr></table></figure>

<h3 id="取得-section-的位置"><a href="#取得-section-的位置" class="headerlink" title="取得 section 的位置"></a>取得 section 的位置</h3><p>在程式中，有時候可能還是會需要取得每個 section 的所在位址，我們可以用如下的方式取得</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text :</span><br><span class="line">    &#123;</span><br><span class="line">        KEEP(*(.isr_vector))</span><br><span class="line">         *(.text)</span><br><span class="line">         *(.text.*)</span><br><span class="line">        *(.rodata)</span><br><span class="line">        *(.rodata*)</span><br><span class="line">        _smodule = .;</span><br><span class="line">        *(.module)</span><br><span class="line">        _emodule = .;</span><br><span class="line">        _sprogram = .;</span><br><span class="line">        *(.program)</span><br><span class="line">        _eprogram = .;</span><br><span class="line">        _sromdev = .;</span><br><span class="line">        *(.rom.*)</span><br><span class="line">        _eromdev = .;</span><br><span class="line">        _sidata = .;</span><br><span class="line">    &#125; &gt;FLASH</span><br></pre></td></tr></table></figure>

<p>上面的7個 symbol 分別代表開始和結束，例如<code>_smodule</code>代表 module 的開始，而<code>_emodule</code>則代表 module 的結束。</p>
<p>這樣的好處是 symbol 的部分我們可以在主程式這樣使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> _sidata;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> _sdata;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> _edata;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> *idata_begin = &amp;_sidata;</span><br><span class="line"><span class="type">uint32_t</span> *data_begin = &amp;_sdata;</span><br><span class="line"><span class="type">uint32_t</span> *data_end = &amp;_edata;</span><br><span class="line"><span class="keyword">while</span> (data_begin &lt; data_end) *data_begin++ = *idata_begin++;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果 C 已經有用到該變數<code>_sidata</code>，那就要用<code>PROVIDE(_sdata = .)</code>來避免 linker 出現重複定義的錯誤</p>
<h3 id="Stack-的位址"><a href="#Stack-的位址" class="headerlink" title="Stack 的位址"></a>Stack 的位址</h3><p>通常 stack 位址我們都會放在 RAM 的最下方讓他往上長，所以我們可以用下面表示方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_estack = ORIGIN(RAM) + LENGTH(RAM);</span><br></pre></td></tr></table></figure>

<p>代表 stack 的放置位址是在 RAM 的最下方。</p>
<h2 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h2><h3 id="如果section重複被使用，會發生什麼事？"><a href="#如果section重複被使用，會發生什麼事？" class="headerlink" title="如果section重複被使用，會發生什麼事？"></a>如果section重複被使用，會發生什麼事？</h3><p>每個輸入檔的 section 只能在出現在 SECTIONS 中出現一次。什麼意思呢？讓我們看個例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">.data : &#123; *(.data) &#125;</span><br><span class="line">.data1 : &#123; data.o(.data) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們可以看到<code>data.o</code>中的<code>.data section</code>應該在第一個 OUTPUT-SECTION-COMMAND (也就是<code>.data : &#123; *(.data) &#125;</code>)被用掉了，所以在<code>.data1 : &#123; data.o(.data) &#125;</code>將不會再次出現，代表的就是<code>.data1 section</code>會是空的。</p>
<h3 id="如果只想要把某個library的-o放入的話"><a href="#如果只想要把某個library的-o放入的話" class="headerlink" title="如果只想要把某個library的.o放入的話"></a>如果只想要把某個library的.o放入的話</h3><p>可用<code>*xxx.a:*yyy.o (.bss*)</code>的方式，舉例來說：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss_RAM2 : ALIGN(4)</span><br><span class="line">    &#123;</span><br><span class="line">      *libmytest.a:*.o (.bss*)</span><br><span class="line">      *(.bss.$RAM2*)</span><br><span class="line">      *(.bss.$RamLoc64*)</span><br><span class="line">       . = ALIGN(4) ;</span><br><span class="line">    &#125; &gt; RamLoc64</span><br></pre></td></tr></table></figure>

<h3 id="如果我不想要把特定檔案的section放入"><a href="#如果我不想要把特定檔案的section放入" class="headerlink" title="如果我不想要把特定檔案的section放入"></a>如果我不想要把特定檔案的section放入</h3><p>可以使用<code>EXCLUDE_FILE</code>，例如我想放除了 foo.o、bar.o 外，所有的<code>.bss section</code>，可以這麼做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(*(EXCLUDE_FILE (*foo.o *bar.o) .bss))</span><br></pre></td></tr></table></figure>

<p>詳細可參考下方連結</p>
<ul>
<li><a href="http://forum.andestech.com/viewtopic.php?f=16&t=600">linker script之EXCLUDE_FILE語法</a></li>
<li><a href="https://stackoverflow.com/questions/21418593/linker-script-put-a-particular-file-at-a-later-position">Linker Script: Put a particular file at a later position</a></li>
</ul>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://sourceware.org/binutils/docs/ld/">ld 官方文件</a></li>
<li><a href="http://yodalee.blogspot.tw/2015/04/linker-script.html">Linker script 簡介</a></li>
<li><a href="http://wiki.csie.ncku.edu.tw/embedded/Lab19/stm32-prog.pdf">嵌入式系統建構：開發運作於STM32的韌體程式</a></li>
<li><a href="http://wen00072.github.io/blog/2014/03/14/study-on-the-linker-script/">Linker Script初探 - GNU Linker Ld手冊略讀</a></li>
<li><a href="https://www.slideshare.net/zzz00072/gnu-ldlinker-script">GNU ld的linker script簡介</a></li>
<li><a href="http://wen00072.github.io/blog/2014/12/22/rtenv-linker-script-explained/">Rtenv的linker Script解釋</a></li>
<li><a href="http://opass.logdown.com/posts/255812-introduction-to-stm32f429-linker-script">stm32f429 Linker Script簡介</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
        <tag>系統程式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 openssl 工具與函式庫</title>
    <url>/2018/05/13/openssl-library-example/</url>
    <content><![CDATA[<h2 id="安裝openssl"><a href="#安裝openssl" class="headerlink" title="安裝openssl"></a>安裝openssl</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install openssl</span><br></pre></td></tr></table></figure>

<p>MAC上如果要使用library有點麻煩，需要先找到對應的路徑</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find /usr/local/Cellar/ -name <span class="string">&quot;libssl.*&quot;</span>  <span class="comment"># 找到library的路徑</span></span><br><span class="line">/usr/local/Cellar//openssl/1.0.2o_1/lib/pkgconfig/libssl.pc</span><br><span class="line">/usr/local/Cellar//openssl/1.0.2o_1/lib/libssl.dylib</span><br><span class="line">...</span><br><span class="line">$ find /usr/local/Cellar/ -name <span class="string">&quot;ssl.h&quot;</span>  <span class="comment"># 找到header的路徑</span></span><br><span class="line">/usr/local/Cellar//node/8.4.0/include/node/openssl/ssl.h</span><br><span class="line">/usr/local/Cellar//openssl/1.0.2o_1/include/openssl/ssl.h</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>看起來路徑是在<code>/usr/local/Cellar/openssl/1.0.2o_1/</code>我們先記起來，後面編譯時會用到。</p>
<h2 id="創造憑證"><a href="#創造憑證" class="headerlink" title="創造憑證"></a>創造憑證</h2><p>openssl本身就有提供很多好用的工具，我們最常用到的大概就是用來產生憑證吧！</p>
<p>這邊介紹產生兩種常見憑證(RSA,ECC)的方法。</p>
<h3 id="產生RSA憑證"><a href="#產生RSA憑證" class="headerlink" title="產生RSA憑證"></a>產生RSA憑證</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 產生2048長度的key</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"><span class="comment"># 用key產生CSR，指定用sha384簽CSR</span></span><br><span class="line">openssl req -new -sha384 -key server.key -out server.csr</span><br><span class="line"><span class="comment"># 產生自簽名證書</span></span><br><span class="line">openssl x509 -req -sha1 -days 3650 -signkey server.key -<span class="keyword">in</span> server.csr -out server.crt</span><br></pre></td></tr></table></figure>

<h3 id="產生ECC憑證"><a href="#產生ECC憑證" class="headerlink" title="產生ECC憑證"></a>產生ECC憑證</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 產生ECC key</span></span><br><span class="line">openssl ecparam -genkey -name secp384r1 -out ecc.key</span><br><span class="line"><span class="comment"># 用key產生CSR，指定用sha384簽CSR</span></span><br><span class="line">openssl req -new -sha384 -key ecc.key -out ecc.csr</span><br><span class="line"><span class="comment"># 產生自簽名證書</span></span><br><span class="line">openssl x509 -req -sha1 -days 3650 -signkey ecc.key -<span class="keyword">in</span> ecc.csr -out ecc.crt</span><br></pre></td></tr></table></figure>

<h2 id="使用openssl內建的連線工具"><a href="#使用openssl內建的連線工具" class="headerlink" title="使用openssl內建的連線工具"></a>使用openssl內建的連線工具</h2><p>有時候我們只是想要測試ssl連線而已，還要自己寫程式有點麻煩，還好我們可以使用openssl提供的連線工具</p>
<p>client和server都有提供，非常方便的！</p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><ul>
<li><code>-msg</code>：看細節(hex格式)</li>
<li><code>-cipher</code>：決定要用哪種cipher連線</li>
<li><code>-showcerts</code>：把cert的chain也列出來</li>
<li><code>-curves</code>：指定要用的橢圓算法，client hello的extension中的elliptic_curves</li>
<li><code>-sigalgs</code>：指定交換key要用的簽名方式，client hello的extension中的signature_algorithms</li>
<li><code>-no_tls1 -no_ssl3</code>：加上後就可以只用tls1.2連線了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最基本連線</span></span><br><span class="line">openssl s_client -connect [IP]:[port]</span><br><span class="line"><span class="comment"># 看連線細節</span></span><br><span class="line">openssl s_client -msg -connect [IP]:[port]</span><br><span class="line"><span class="comment"># 指定連線方式</span></span><br><span class="line">openssl s_client -connect sslanalyzer.comodoca.com:443 -cipher ECDHE-RSA-AES128-GCM-SHA256 -curves secp384r1 -sigals RSA+SHA512</span><br><span class="line"><span class="comment"># 限制只能用TLS1.2連線</span></span><br><span class="line">openssl s_client -no_tls1 -no_ssl3 -connect [IP]:[port]</span><br></pre></td></tr></table></figure>

<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server開啟5678 port並且用server.key當private key，cert用server.pem</span></span><br><span class="line">openssl s_server -accept 5678 -key server.key -cert server.pem</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果要看有哪些連線方式，可使用如下指令</span></span><br><span class="line">openssl ciphers ALL</span><br></pre></td></tr></table></figure>

<h2 id="函式庫使用"><a href="#函式庫使用" class="headerlink" title="函式庫使用"></a>函式庫使用</h2><p>我們來介紹openssl的函式庫最基本的使用方式。</p>
<h3 id="基本範例-client-server"><a href="#基本範例-client-server" class="headerlink" title="基本範例 - client &amp; server"></a>基本範例 - client &amp; server</h3><p>這邊寫了兩個client和server的基本範例當作參考，大家可以基於這兩者來拓展自己的程式。</p>
<h4 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h4><p>ssl_client.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_SIZE 256</span></span><br><span class="line"></span><br><span class="line">SSL_CTX *<span class="title function_">create_sslcontext</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> SSL_METHOD *method;</span><br><span class="line">    SSL_CTX *ctx;</span><br><span class="line">    <span class="comment">// Support only TLSv1.2</span></span><br><span class="line">    method = TLSv1_2_client_method();</span><br><span class="line">    <span class="comment">// Create context</span></span><br><span class="line">    ctx = SSL_CTX_new(method);</span><br><span class="line">    <span class="keyword">if</span> (!ctx)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket</span><span class="params">(<span class="type">char</span> *ip, <span class="type">int</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// New socket</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// TCP connect to server</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    <span class="keyword">if</span> (connect(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage: ./ssl_client.out [IP] [port]</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    SSL_CTX *ctx;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    SSL *ssl;</span><br><span class="line">    <span class="type">char</span> buf[RECV_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Parse parameter</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connect to %s:%d\n&quot;</span>, argv[<span class="number">1</span>], port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SSL init</span></span><br><span class="line">    OpenSSL_add_ssl_algorithms();</span><br><span class="line">    <span class="comment">// Create SSL_CTX</span></span><br><span class="line">    <span class="keyword">if</span> ((ctx = create_sslcontext()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Create socket</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = create_socket(argv[<span class="number">1</span>], port)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Start to build ssl connection</span></span><br><span class="line">    ssl = SSL_new(ctx);</span><br><span class="line">    SSL_set_fd(ssl, fd);</span><br><span class="line">    <span class="keyword">if</span> (SSL_connect(ssl) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// SSL write/read</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Write data to server (q for quit): &quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        gets(buf);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;q&quot;</span>, buf) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (SSL_write(ssl, buf, <span class="built_in">strlen</span>(buf)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        len = SSL_read(ssl, buf, RECV_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Recv %d bytes: %s\n&quot;</span>, len, buf);</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// SSL close</span></span><br><span class="line">    SSL_shutdown(ssl);</span><br><span class="line">    <span class="comment">// Free resource</span></span><br><span class="line">    SSL_free(ssl);</span><br><span class="line">    close(fd);</span><br><span class="line">    SSL_CTX_free(ctx);</span><br><span class="line">    EVP_cleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ssl_server.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/ssl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSL_CERT <span class="string">&quot;server.crt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSL_KEY  <span class="string">&quot;server.key&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN  256</span></span><br><span class="line"></span><br><span class="line">SSL_CTX *<span class="title function_">create_sslcontext</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> SSL_METHOD *method;</span><br><span class="line">    SSL_CTX *ctx;</span><br><span class="line">    <span class="comment">// Support only TLSv1.2</span></span><br><span class="line">    method = TLSv1_2_server_method();</span><br><span class="line">    <span class="comment">// Create context</span></span><br><span class="line">    ctx = SSL_CTX_new(method);</span><br><span class="line">    <span class="keyword">if</span> (!ctx)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">configure_sslcertkey_file</span><span class="params">(SSL_CTX *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    SSL_CTX_set_ecdh_auto(ctx, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Load certificate file</span></span><br><span class="line">    <span class="keyword">if</span> (SSL_CTX_use_certificate_file(ctx, SSL_CERT, SSL_FILETYPE_PEM) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Load private key file</span></span><br><span class="line">    <span class="keyword">if</span> (SSL_CTX_use_PrivateKey_file(ctx, SSL_KEY, SSL_FILETYPE_PEM) &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (listen(fd, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage: ./ssl_server.out [port]</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> server_fd, client_fd;</span><br><span class="line">    SSL_CTX *ctx;</span><br><span class="line">    SSL *ssl;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    uint len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    <span class="type">char</span> buf[BUF_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Listen port: %d\n&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SSL init</span></span><br><span class="line">    OpenSSL_add_ssl_algorithms();</span><br><span class="line">    <span class="comment">// Create SSL_CTX</span></span><br><span class="line">    <span class="keyword">if</span> ((ctx = create_sslcontext()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Configure cert and key</span></span><br><span class="line">    <span class="keyword">if</span> (configure_sslcertkey_file(ctx) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Create socket</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = create_socket(port)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Accept connection</span></span><br><span class="line">    <span class="keyword">if</span> ((client_fd = accept(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, &amp;len)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Build SSL connection</span></span><br><span class="line">    ssl = SSL_new(ctx);</span><br><span class="line">    SSL_set_fd(ssl, client_fd);</span><br><span class="line">    <span class="keyword">if</span> (SSL_accept(ssl) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// SSL read/write</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        len = SSL_read(ssl, buf, BUF_LEN);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SSL_write(ssl, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Close client</span></span><br><span class="line">    SSL_free(ssl);</span><br><span class="line">    close(client_fd);</span><br><span class="line">    <span class="comment">// Close server and relase resource</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    SSL_CTX_free(ctx);</span><br><span class="line">    EVP_cleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="編譯與執行"><a href="#編譯與執行" class="headerlink" title="編譯與執行"></a>編譯與執行</h4><p>接下來寫個簡單的Makefile，這時候就要用到前面所找到的路徑了。</p>
<figure class="highlight mak"><table><tr><td class="code"><pre><span class="line">SSL_PATH=/usr/local/Cellar/openssl/1.0.2o_1/</span><br><span class="line">CFLAGS=-I<span class="variable">$(SSL_PATH)</span><span class="keyword">include</span> -L<span class="variable">$(SSL_PATH)</span>lib/ -lcrypto -lssl</span><br><span class="line">CC=gcc</span><br><span class="line">BIN=ssl_server ssl_client</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(BIN)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">ssl_server: ssl_server.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span>.out <span class="variable">$(CFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ssl_client: ssl_client.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span>.out <span class="variable">$(CFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        -rm *.o</span><br><span class="line">        -rm *.out</span><br></pre></td></tr></table></figure>

<p><strong>這邊要特別記住<code>-lcrypto -lssl</code>要放最後面，不然有些平台會有error</strong></p>
<p>然後就可以執行看看了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ ./ssl_server 2222</span><br><span class="line">Listen port: 2222</span><br></pre></td></tr></table></figure>

<p>這時候另一邊再來執行client</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ssl_client.out 127.0.0.1 2222</span><br><span class="line">Connect to 127.0.0.1:2222</span><br><span class="line">Write data to server (q <span class="keyword">for</span> quit): abcd</span><br><span class="line">Recv 4 bytes: abcd</span><br></pre></td></tr></table></figure>

<p>可以順利收送資料了！</p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://unix.stackexchange.com/questions/346864/how-to-link-openssl-library-in-macos-using-gcc">How to link OpenSSL library in macOS using gcc?</a></li>
<li><a href="https://wiki.openssl.org/index.php/Simple_TLS_Server">Simple TLS Server</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>port knocking</title>
    <url>/2017/08/27/port-knocking/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>port knocking就像是敲門的暗號一樣，以特定順序碰觸port，server就會執行特定指令<br>我們可以把這個功能用來開port，就像阿里巴巴要用咒語才可以開門一樣。<br>詳情可參考<a href="http://www.portknocking.org/view/about/summary">port knocking的定義</a></p>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>我這邊server是用Ubuntu, client是MAC環境。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install knockd</span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew insrall knock</span><br></pre></td></tr></table></figure>

<h2 id="設定檔"><a href="#設定檔" class="headerlink" title="設定檔"></a>設定檔</h2><p>通常在位置在<code>/etc/knockd.conf</code><br>最初的設定檔，可參考<a href="http://linux.die.net/man/1/knockd">manual</a><br>這邊是客製化的設定，目的是可以開關port 22，防止有人亂連。</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[options]</span></span><br><span class="line">        UseSyslog</span><br><span class="line"></span><br><span class="line"><span class="section">[openSSH]</span></span><br><span class="line">        <span class="attr">sequence</span>    = <span class="number">3389</span>:udp,<span class="number">80</span>:tcp,<span class="number">21</span>:udp,<span class="number">53</span>:tcp,<span class="number">23</span>:udp</span><br><span class="line">        <span class="attr">seq_timeout</span> = <span class="number">5</span></span><br><span class="line">        <span class="attr">command</span>     = /sbin/iptables -I INPUT <span class="number">1</span> -s %IP% -p tcp --dport <span class="number">22</span> -j ACCEPT</span><br><span class="line">        <span class="attr">tcpflags</span>    = syn</span><br><span class="line"></span><br><span class="line"><span class="section">[closeSSH]</span></span><br><span class="line">        <span class="attr">sequence</span>    = <span class="number">443</span>:tcp,<span class="number">80</span>:udp</span><br><span class="line">        <span class="attr">seq_timeout</span> = <span class="number">5</span></span><br><span class="line">        <span class="attr">command</span>     = /sbin/iptables -D INPUT -s %IP% -p tcp --dport <span class="number">22</span> -j ACCEPT</span><br><span class="line">        <span class="attr">tcpflags</span>    = syn</span><br></pre></td></tr></table></figure>

<p>功能大概看名字也可以猜出來</p>
<ul>
<li>sequence: 敲port的順序</li>
<li>seq_timeout: 間隔時間</li>
<li>command: 如果成功敲完，要執行什麼命令，這邊是用開ssh來當示範</li>
<li>tcpflags: 如果是TCP連線，需要有什麼flag</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><p>把<code>/etc/default/knockd</code>中的<code>START_KNOCKD</code>改成1<br>然後啟動</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service knockd start</span><br></pre></td></tr></table></figure>

<p>記得防火牆要先設定不讓外面的人進入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/iptables -A INPUT --dport 8888 -j DROP</span><br></pre></td></tr></table></figure>

<h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><p>須先安裝knock</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 開啓</span></span><br><span class="line">knock -v 192.168.0.1 3389:udp 80:tcp 21:udp 53:tcp 23:udp</span><br><span class="line"><span class="comment"># 關閉</span></span><br><span class="line">knock -v 192.168.0.1 443:tcp 80:udp</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>knock不一定要完全正確<br>例如說如果順序是7000,8000,9000<br>那麼我們用7000-9000依序敲過去仍然是可以打開<br>但是如果是分兩次knock就沒有用了</p>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>youtube-dl網路影片下載器</title>
    <url>/2018/11/25/youtube-dl%E7%B6%B2%E8%B7%AF%E5%BD%B1%E7%89%87%E4%B8%8B%E8%BC%89%E5%99%A8/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>當我們要下載網路影片時，通常會去使用browser上的套件來下載，其實除了browser套件外，我們也可以使用command-line的方式，也就是這篇要介紹的youtube-dl。</p>
<p>youtube-dl功能十分強大，也有很多參數可以調整，能下載的網站不只是youtube，也可以是其他熱門網站，例如Facebook等等，更重要的是這個工具有多個平台可以使用(Windows、Mac、Linux)。</p>
<p>除了<a href="https://rg3.github.io/youtube-dl/index.html">指令youtube-dl</a>以外，我們也可以用GUI的介面的工具<a href="https://github.com/MrS0m30n3/youtube-dl-gui">youtube-DLG</a>，使用上更為方便，詳請可參考<a href="https://www.kocpc.com.tw/archives/162438">最強的網路影片下載器　Youtube-dl-gui 只要有網址就能幫你搞定</a>。</p>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install youtube-dl</span><br><span class="line"><span class="comment"># 如果有需要後續轉檔的話</span></span><br><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install youtube-dl</span><br><span class="line"><span class="comment"># 如果需要後續轉檔的話</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ffmpeg</span><br></pre></td></tr></table></figure>

<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>其實更好的方法是使用Python的pip來安裝，因為youtube-dl本身就是使用Python所寫成的，而由於影片的網站更新很快，所以可能要隨時更新到最新版的youtube-dl才行，OS distribution不一定會出的那麼快。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --upgrade youtube_dl</span><br><span class="line"><span class="comment"># 如果使用python3的話</span></span><br><span class="line">pip3 install --upgrade youtube_dl</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>這邊介紹一些常用的指令</p>
<h3 id="支援"><a href="#支援" class="headerlink" title="支援"></a>支援</h3><ul>
<li>確定有支援下載哪些影片網站，相關列表也可以從<a href="https://github.com/rg3/youtube-dl/blob/master/docs/supportedsites.md">官網</a>查詢</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">youtube-dl --extractor-descriptions</span><br></pre></td></tr></table></figure>

<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>如果我們沒有指定格式的話，通常youtube-dl會幫我們挑最好的</p>
<ul>
<li>指定下載的影片格式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先查詢有哪些格式可下載</span></span><br><span class="line">youtube-dl -F [URL]</span><br><span class="line"><span class="comment"># 指定下載格式</span></span><br><span class="line">youtube-dl -f mp4 [URL]</span><br><span class="line"><span class="comment"># 或是用format code</span></span><br><span class="line">youtube-dl -f [列表中的format code] [URL]</span><br></pre></td></tr></table></figure>

<h3 id="輸出格式"><a href="#輸出格式" class="headerlink" title="輸出格式"></a>輸出格式</h3><p>由於官方的輸出格式預設有帶ID(<code>%(title)s-%(id)s.%(ext)s</code>)，我們可以將其去除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">youtube-dl -o <span class="string">&#x27;%(title)s.%(ext)s&#x27;</span> [URL]</span><br></pre></td></tr></table></figure>

<h2 id="字幕"><a href="#字幕" class="headerlink" title="字幕"></a>字幕</h2><ul>
<li>選擇嵌入特定字幕<ul>
<li><code>--write-sub</code>代表下載字幕</li>
<li><code>--embed-sub</code>代表嵌入字幕</li>
<li><code>--sub-lang</code>代表要選擇的字幕</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先列出可下載的字幕列表</span></span><br><span class="line">youtube-dl --list-subs [URL]</span><br><span class="line"><span class="comment"># 嵌入想要的字幕</span></span><br><span class="line">youtube-dl --write-sub --embed-sub --sub-lang [字幕] [URL]</span><br></pre></td></tr></table></figure>

<ul>
<li>直接嵌入所有字幕<ul>
<li><code>--all-subs</code>選擇所有字幕</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">youtube-dl --write-sub --embed-sub --all-subs [URL]</span><br></pre></td></tr></table></figure>

<h3 id="轉為音樂格式"><a href="#轉為音樂格式" class="headerlink" title="轉為音樂格式"></a>轉為音樂格式</h3><p>如果我們要下載音樂格式的話，基本上需要有ffmpeg的輔助</p>
<ul>
<li>選擇要下載的音樂格式，例如mp3、m4a、flac等等</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">youtube-dl -x --audio-format [音樂格式] [URL]</span><br></pre></td></tr></table></figure>

<ul>
<li>可以用<code>--audio-quality</code>強迫ffmpeg轉換較高品質的音樂，0是最好，9是最差</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">youtube-dl -x --audio-format [音樂格式] --audio-quality [音樂品質] [URL]</span><br></pre></td></tr></table></figure>

<ul>
<li>下載時附上封面(使用youtube截圖)和音樂資訊(作曲者等等)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">youtube-dl -x --audio-format [音樂格式] --embed-thumbnail --add-metadata [URL]</span><br></pre></td></tr></table></figure>

<h3 id="下載播放清單"><a href="#下載播放清單" class="headerlink" title="下載播放清單"></a>下載播放清單</h3><ul>
<li>其實只要把[URL]換成播放清單的網址即可，不過我們也可以指定開始和結束位址<ul>
<li><code>--playlist-start</code>：開始</li>
<li><code>--playlist-end</code>：結束，也就是倒數第幾個影片</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">youtube-dl --playlist-start [開始位置] --playlist-end [結束位置] [URL]</span><br></pre></td></tr></table></figure>

<h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><p>我這邊直接列出常用的指令，如果要使用可以直接copy比較快</p>
<ul>
<li>下載mp4影片並加上字幕</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">youtube-dl -f mp4 --write-sub --embed-sub --all-subs -o <span class="string">&#x27;%(title)s.%(ext)s&#x27;</span> [URL]</span><br></pre></td></tr></table></figure>

<ul>
<li>下載mp3音樂，並加上封面</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">youtube-dl -x --audio-format mp3 --audio-quality 0 --embed-thumbnail --add-metadata [URL]</span><br></pre></td></tr></table></figure>

<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://blog.gtwang.org/useful-tools/youtube-dl/">youtube-dl：下載 YouTube 影片的指令工具（支援 Windows、Linux 與 Mac OS X）</a></li>
<li><a href="https://yogapan.github.io/2017/08/16/Youtube-dl%E6%BF%83%E7%B8%AE%E6%95%99%E5%AD%B8%E7%AD%86%E8%A8%98/">Youtube-dl濃縮教學筆記</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>一些減少code size的方法</title>
    <url>/2019/08/03/%E4%B8%80%E4%BA%9B%E6%B8%9B%E5%B0%91code-size%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在開發嵌入式系統的時候，很常遇到需要在資源緊張的環境上進行開發，所謂的資源緊張大概不外乎memory不夠使用、flash不夠大，但是老闆或PM仍然希望RD在產品上面新增feature，這時候就只能針對code size進行優化了。我自己待的部門剛好就是遇到這種產品已經維護10年以上，可是又希望加新feature的狀況，因此開始尋找減少code size的方法，這邊分享一些我自己的心得。</p>
<h2 id="Compile-Optimization"><a href="#Compile-Optimization" class="headerlink" title="Compile Optimization"></a>Compile Optimization</h2><p>首先我們可以看一下compiler是不是已經做過優化了，大家都知道gcc在編譯的時候可以選擇optimization的level，從0-3。0代表的是default，而隨著數字越高，對code size和execution time的優化就越高。</p>
<p>大部分的人都會建議使用-O2，在code size和execution time取平衡，但是如果真的對code size十分在意的話，其實也可以使用-Os，代表的是-O2但是不包含部分會影響code size的優化。</p>
<p>到底每個optimization的level是做了那些優化，可參考<a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">GCC的官方文件</a></p>
<h2 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h2><p>strip算是最基本的降低code size工具，他會移除debug資訊(可供gdb使用的資訊)以及symbol table，因此size會降低許多。</p>
<p>這邊簡單做個實驗：</p>
<ul>
<li>我們先寫個簡單程式：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接著來編譯，為了凸顯strip的效果，我們加上-g來加上gdb debug訊息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接著我們可以用<code>nm -a test</code>來看到他的symbol table</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 a</span><br><span class="line">0000000000201030 b .bss</span><br><span class="line">0000000000201030 B __bss_start</span><br><span class="line">0000000000000000 n .comment</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<ul>
<li>以及用<code>objdump -h test</code>來看到有哪些section header，可以發現有許多debug資訊</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> 27 .debug_aranges 00000030  0000000000000000  0000000000000000  0000105d  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line"> 28 .debug_info   0000033a  0000000000000000  0000000000000000  0000108d  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line"> 29 .debug_abbrev 000000f6  0000000000000000  0000000000000000  000013c7  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line"> 30 .debug_line   000000d4  0000000000000000  0000000000000000  000014bd  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line"> 31 .debug_str    0000028a  0000000000000000  0000000000000000  00001591  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>接著執行<code>strip test</code>後，會發現symbol table已經消失了(無法使用nm)，以及沒有debug的section header。兩者size有極大差異。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">ls</span> -al</span><br><span class="line">-rwxrwxrwx 1 evshary evshary 11152 Aug  4 11:34 <span class="built_in">test</span></span><br><span class="line">&gt; strip <span class="built_in">test</span></span><br><span class="line">&gt; <span class="built_in">ls</span> -al</span><br><span class="line">-rwxrwxrwx 1 evshary evshary 6304 Aug  4 11:39 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="objcopy"><a href="#objcopy" class="headerlink" title="objcopy"></a>objcopy</h2><p>strip可以減少極大部分的code size，但是如果這樣還不夠的話，我們可以用objcopy把一些沒用到的section header移除掉，但是要提醒一下，這個移除幾乎不會影響太大，大概就幾百byte而已。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; objcopy -R .comment -R .note.ABI-tag -R .gnu.version <span class="built_in">test</span> small_test</span><br><span class="line">-&gt; <span class="built_in">ls</span> -al</span><br><span class="line">-rwxrwxrwx 1 evshary evshary 6304 Aug  4 11:39 <span class="built_in">test</span></span><br><span class="line">-rwxrwxrwx 1 evshary evshary 6024 Aug  4 11:45 small_test</span><br></pre></td></tr></table></figure>

<p>這邊所謂的沒用到section header主要是一些環境的版本資訊，到底這些header代表什麼意思，可以參考<a href="http://refspecs.linuxbase.org/LSB_3.0.0/LSB-PDA/LSB-PDA/specialsections.html">Linux Standard Base PDA Specification 3.0RC1 - Chapter 5. Special Sections</a></p>
<h2 id="利用-compile-option-來移除沒用到的-symbol"><a href="#利用-compile-option-來移除沒用到的-symbol" class="headerlink" title="利用 compile option 來移除沒用到的 symbol"></a>利用 compile option 來移除沒用到的 symbol</h2><p>我們知道程式裡面常常會有些程式碼(function&#x2F;data)並沒有被人使用到，不論是因為長久maintain被修修改改，還是因為本身就有預留給未來使用。但是這些沒用到的功能如果都被編進去程式中其實是很浪費的，我們這邊可以用一些小手段來移除。</p>
<p>在gcc的編譯過程中我們可以加上特別的編譯參數<code>-fdata-sections</code>和<code>-ffunction-sections</code>，這兩個的意思是把每個symbol(function或data)獨立成不同的section。為什麼要這樣做呢？當然是為了後面在link的時候我們可以直接移除沒用到的section，在link的時候多加上<code>--gc-sections</code>參數即可。</p>
<p>細節可以參考<a href="https://stackoverflow.com/questions/6687630/how-to-remove-unused-c-c-symbols-with-gcc-and-ld">How to remove unused C&#x2F;C++ symbols with GCC and ld?</a>。</p>
<h2 id="觀察-map-file"><a href="#觀察-map-file" class="headerlink" title="觀察 map file"></a>觀察 map file</h2><p>map file是我們在編譯過程中很重要的一個工具，他可以用來檢視目前symbol的size有多大，我們可以用nm來取得symbol table，甚至根據symbol的size大小來排序(指令是<code>nm --size-sort -r -S [執行檔]</code>)。透過觀察map file，我們可以瞭解程式內部每個功能佔的大小為何，進一步思考有沒有優化的空間，甚至發現該功能根本是沒有在使用的。</p>
<p>我自己也曾經有遇過code size的問題，那時候我一樣是用nm來讀取map file，忽然發現某個變數大到不可思議，觀察了一下發現那個變數是直接用global的方式宣告，並不是要用的時候才malloc，導致在一般firmware運作的過程中那塊記憶體完全沒辦法被使用。更重要的是那個功能並不常被使用，而且還會隨著硬體平台有不一樣的大小，結果RD為了方便，直接保留可能會用到的最大值，造成空間的極度浪費。</p>
<h2 id="Remove-debug-message"><a href="#Remove-debug-message" class="headerlink" title="Remove debug message"></a>Remove debug message</h2><p>其實RD在開發的過程中，或多或少都會留一些debug訊息，雖然少少的，但是累積起來量也是很驚人，畢竟一個debug訊息就是一個字串。在code size緊張的情況下，應該可以審視一下，看能不能把debug訊息移除。</p>
<p>值得注意的是有些embedded的firmware確實是會有關閉debug資訊的方式，但是這個有可能只是不顯示(例如關閉console顯示)，並不是真的移除，要仔細確認自己的狀況是哪種。</p>
<p>不過如果真的到了一定要移除debug訊息程式才能夠被使用的情況，這樣也挺危險的了，因為未來如果要maintain，必要的debug訊息還是逃不了。我會建議程式開發的過程中每個功能都可以自行決定要不要把debug的程式碼編進去，至少遇到bug還可以只開啟相關功能的debug訊息，而不是全部訊息都全開。</p>
<h2 id="移除沒用到的功能-library-、檔案"><a href="#移除沒用到的功能-library-、檔案" class="headerlink" title="移除沒用到的功能(library)、檔案"></a>移除沒用到的功能(library)、檔案</h2><p>在我們的embedded firmware裡面有些會需要使用SSL或SSH這種非常龐大的library，可能佔firmware的size超過1&#x2F;3。像是這種library其實有很多功能是我們沒有用到的，以SSL、SSH來說，其實我們只會用到其中少部分的加密cipher，而不是全部。如果真要使用，建議要對library本身功能機制足夠熟悉，在編譯的時候只開用到的option即可。</p>
<p>除了library外，一個產品經過長時間的maintain，中間一定會有許多功能是後來沒用到，卻沒被移除的。如果只是程式碼倒還好，可以用前面提到的gc-section來排除，但是如果是file system的檔案，那就要靠自己來處理了。我個人的經驗是，有很多功能是過去產品有的，但是因為後來時代不符合被移除，結果相關檔案就都一直遺留下來，例如可在browser上面運作的java plugin等等，這些的size是也很可觀的。</p>
<h2 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h2><p>壓縮也是減少code size的其中一個方法，除了啟動的程式外，我們可以把runtime過程才要load的東西進行壓縮。通常這類的角色可以是kernel啟動完成後另外加載的AP，或是filesystem。不過壓縮要考慮的點就是壓縮率、解壓的程式碼的大小以及速度，最好可以在這其中之間取得平衡。壓縮率對我們來說就是可以把程式縮小到什麼地步，如果縮小不大就沒有意義了，然後解壓的部分也很重要，要是有很高壓縮率，但是解壓程式很大，那整體來說並沒有得到多高的效益。而如果壓縮率高，但解壓速度過慢，也會影響到使用者體驗，這些都需要考慮到。</p>
<p>filesystem的部分有點可以稍微注意一下，大部分的應用都是web居多，而web其實是有壓縮的空間，且不需另外解壓的。我們知道一般web都是由html、CSS、javascript所組成，而這些內容丟給browser的時候並不需要是人眼比較好閱讀的方式，例如說不需要換行、縮排等等。這麼一來我們就有可以動手腳的空間，可以在編譯過程中，把原始的檔案做壓縮，最後才變成file system，這樣的壓縮率是很可觀的。除了減少size外，這還帶來另外一個很大的好處就是減少網路流量的傳輸，特別在embedded system中系統效能其實都不快。提醒一下，記得開發過程使用git追蹤的web檔案最好是原始檔案(人眼好讀的)，編譯過程才壓縮，不然這只是給自己帶來開發的困擾而已。</p>
<p>web壓縮的方式網路上有很多，有些甚至提供online的服務，例如<a href="https://htmlcompressor.com/compressor/">HTMLCompressor</a>或是<a href="https://www.textfixer.com/html/compress-html-compression.php">textfixer</a>等等，可以自己尋找適合的工具。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>上面分享了許多方法，但最後我要先澄清一下，自己需要搞清楚到底不夠的是flash還是memory，上面的方法並不是做了兩個都一定會減少。舉個例子來說，移除沒有必要用到的大變數通常只會影響memory的使用率，因為compile出來firmware的size並沒有包括大變數(因為是bss section，未初始化區段)，而file system的壓縮通常也只會影響flash的使用率，除非firmware有把檔案預先從flash讀出來放在memory中。我想強調的是使用這些方法時，還是要有必備的系統觀以及對你的系統有一定熟悉程度。</p>
<p>老實說軟體開發者最討厭的大概就是被各種硬體條件所限制，然而這些在embedded的世界中還是有很大的機會會遇到，特別是考量到成本的時候。雖然很討厭這類的問題，但是解決後其實還是蠻有成就感的。以上分享希望能夠幫助大家解決code size issue。</p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="http://linux.vbird.org/somepaper/20050117-jianfei.pdf">程式減肥三步走</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>系統程式</tag>
      </tags>
  </entry>
  <entry>
    <title>在非標準的道路上</title>
    <url>/2025/01/12/%E5%9C%A8%E9%9D%9E%E6%A8%99%E6%BA%96%E7%9A%84%E9%81%93%E8%B7%AF%E4%B8%8A/</url>
    <content><![CDATA[<p>或多或少，小時候總是會幻想著自己能成就一番大事，或許是引領人類技術的企業家、創造偉大作品的藝術家、又或者是發現新理論的科學家。然而，學校和社會所給予的教育大多數是讓我們走向標準化的的道路。它們使用了共同的評量指標來衡量人的成就，學生時期是成績和排名、出社會後是金錢和地位。這樣的系統並非沒有價值，它能夠訓練人們成為社會運作所需要的小齒輪。儘管齒輪是有功用的，但是也可以輕易被其他齒輪替代。</p>
<p>不僅如此，為了更有效率地完成這個過程，社會還發展出了各種方法。為了得到好的成績，因此有了補習班的存在；為了升遷或是加薪，坊間充斥著各種提昇工作技能、如何跳槽等等的書籍和課程。社會鼓勵著人們為這段已知的旅程做好事先規劃，考上好的大學、加入優秀的公司、透過跳槽或升遷提昇待遇、買房子、生孩子、並且讓孩子得到比自己更好的教育環境。每個階段都押上了截止日，透過社會的壓力以及與同齡者的比較，讓人不得不跟隨這樣的洪流前進。</p>
<p>然而，對有些人來說，常常會懷疑人生真的只是這樣而已嗎？</p>
<p>最近讀了不少這方面的書或文章，包括黑馬思維、<a href="/2024/10/06/%E7%82%BA%E4%BB%80%E9%BA%BC%E5%81%89%E5%A4%A7%E4%B8%8D%E8%83%BD%E8%A2%AB%E8%A8%88%E7%95%AB/">為什麼偉大不能被計劃</a>、知名創投 Paul Graham 的<a href="https://www.paulgraham.com/greatwork.html">如何做出偉大成就</a>等等。其中有個同樣被反覆提及的論點，那就是不需要事先去設定目標，依據自己的特質，跟隨內心的好奇心不斷去探索。在探索的路上不是跟著外在價值行動，而是傾聽心中的聲音，保持彈性隨時轉向最適合自己的機會。原本按照社會標準化的流程只會產生出標準化的個體。可是由於每個人都不一樣，感興趣的東西也不同，追尋個人價值反而更能抵達前所未見的目的地。</p>
<p>我想，往自己好奇的方向前進，雖然不一定真的能成就偉大的事業——那需要有運氣的加成——但是至少內心是滿足的。當能夠非常投入自己想做的事情，就能獲得自我實現的充實感。</p>
<p>不過跟隨好奇心走，堅持在非標準化的道路，也並不那麼容易。特別當見到他人在典型社會期望下達成一個個人生目標的時候，會不斷迷惘自己是否走錯了路。<strong>「我是不是應該跟大家一樣比較好」這樣的疑惑時不時會浮現在心中</strong>。</p>
<p>我自己是先嘗試忽略別人的目光，也不要和別人比較。當疑惑產生時，先問問：<strong>目前在做的事情是不是我想做的？</strong>畢竟做想做的事情才能產生出滿足感。除此之外，這也能幫助我們把重心放回自己身上。適當與人比較雖然可以協助定位自己，但更多的時候是消耗寶貴的內心能量。</p>
<p>通常我也會把過去的經歷整理起來，這有兩個好處，第一是給予自己信心，原來我也已經成就了那麼多事情。第二則是從這些經歷中更加認識自我。現在的我是由過去的我做了種種決定而來的，從這些決策中可以看清心中真正的價值觀與動力。</p>
<p>接下來，我會思考要怎麼往前進。人有追求自我成長的天性，同樣的工作做上千百次也是會感到煩膩。因此基於目前的位置持續往前進是有必要的。這點其實蠻困難的，特別有時候會覺得已經走到死胡同，一切都卡住了。這時能做的只有把所有潛在選項（或可能感興趣的事情）列出來，一一去嘗試看看。重點是不要停下來，不要害怕失敗。<strong>比起坐在那邊空想，唯有透過實際的行動才會知道某些選項可不可行，親身的經驗可以提供我們很多無法口語表達的資訊</strong>。</p>
<p>和自己佩服的人共事也是一個很好的方法。根據我的經驗，很多我很欽佩的技術大神，實際接觸後才會發現他們都是只是凡人。大多數時候，我們會遇到的困難，他們也會遇到，差別只是在他們肯花時間堅持下去，遵循內心對解決問題的渴望。這個認知會帶給自己極大的信心，<strong>人與人的差距在天份之前，更多是差在看待問題的態度上</strong>。</p>
<p>最後，<strong>不要有只要某個事情達成了，一切都會變好的想法</strong>。這個事情可能是某個工作變化、學會某個技能、看完某本書。就我的經驗來說，任何事情的完成，個人本身並不會有什麼劇烈的變化。我還是我，我還是繼續期望著下個事情的完成能帶來改變。與其用著功利心投入目前做的事情，不如享受在當下。投入某個專案不是為了虛榮心，而是發自內心對這個專案有興趣。學習某個技術不是為了方便面試找工作，而是可以用這個它解決想解決的問題。雖然只是些微的動機差異，但是對最後成果的影響可以說是非常的巨大。</p>
<p>如果把人生比喻成一種開放式遊戲，那為什麼一定要按照被定義好的攻略來玩呢？或許有些人會追求能最快速地破關，但對大多數人來說，找出遊戲中能讓自己投入的元素才能帶來最大的娛樂價值吧！</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>三年的工作省思</title>
    <url>/2019/06/23/%E4%B8%89%E5%B9%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%9C%81%E6%80%9D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作到現在已經三年半了，雖然有許多成長，但也看見自己很多的不足，可以再進步的地方。個人覺得如果要能夠更快速地成長，需要定期總結自己的經驗以及所學習的東西，並且思考未來可以再怎麼做會更好。平常我有做日記的習慣，但是還沒有為自己統整工作上面的心得，這邊除了當作紀錄以外，也是可以提供給跟我差不多狀況的人參考。不過老實說，這些分享並不一定正確，但是至少是此時此刻的我最真實的想法，也歡迎大家多多指教。</p>
<h2 id="經歷"><a href="#經歷" class="headerlink" title="經歷"></a>經歷</h2><h3 id="畢業前"><a href="#畢業前" class="headerlink" title="畢業前"></a>畢業前</h3><p>我是從研替開始軟體工程師的生涯，以前在大學、研究所時，雖然有寫程式，但是畢竟都還是學生等級的程式，個人是覺得不夠深入與成熟。不過另一方面其實也累積了不少基礎，有許多重要的知識都是那時紮根的，包括Linux的使用、git的使用、Network的概念、Security的概念，這些對後來的自己都有很多幫助。雖然有時會想要是現在的自己回到過去的話，肯定可以學得更快更好、更有效率，畢竟產業和學術上還是有多少落差，但這也都有點後見之明了，而且正是因為曾經經歷過，才會有不同看事情的角度。會覺得過去要是怎樣怎樣現在就會更好，大概是人免不了的通病吧！</p>
<h3 id="第一年"><a href="#第一年" class="headerlink" title="第一年"></a>第一年</h3><p>進到職場後，最不習慣的是每件事都要很清楚是在做什麼，過去在學校基本上只要code能work就行了，所以最常做的就是上stack overflow找找，然後copy &amp; paste，不太會去理清背後的原理，或是思考怎麼做才會更有效率。然而在職場上，如果只是剪剪貼貼的話，遲早會出問題的，被同事問回答不出來還是小事，更慘的是自己做完了導致其他的bug出現。另外一點是動作需要很迅速，我記得剛過試用期後就被交付了要porting BSP上的ICMP的功能到FreeRTOS，時間給我3天，結果最後花費的時間還是超過，這跟學校其實差異很大，我在學校光是改一個memory leak的bug就改了2個月(雖然是因為還要兼顧課業)。最後，關於品質的部分，也是那時的我需要克服的坎，我不喜歡做測試，可是當時的主管就很強調要做自我驗證，才不會提供的程式上面有很多顯而易見的問題，給出去的程式也是代表自己的品牌，需要細心驗證才行。</p>
<p>其實整體來說，我在職場上的第一年大概是以調整心態並且適應工作為主，而工作內容大概都是偏向AP層的修改，或是開發些應用程式。最常見的case大概是做客製化的firmware以及處理客戶回報的問題，改的內容不外乎是web上的修改，或是AP層上面的邏輯的問題。不過也不是沒有要寫新feature，包括在JAVA應用程式上用JNI連結到C library、Linux command line tool、帳號管理API等等，或多或少訓練了怎麼設計程式架構。</p>
<h3 id="第二年"><a href="#第二年" class="headerlink" title="第二年"></a>第二年</h3><p>第二年開始我已經有能力解決比較困難的問題，那時團隊遇到SDRAM不足的問題，後來我透過分析map檔找到一個沒有必要使用的巨大global variable，克服這個難關。不過老實說，我現在回想起來這個問題也不是太難，只是要對firmware compile過程有比較深一點的認知而已。另外當時遇到了過熱當機的問題，這個老實說是幫助我成長最大的問題，我把NXP的MCU spec讀了好幾次，了解了ARM的exception架構，另外也深入理解FreeRTOS以及lwip等NXP提供的BSP是怎麼與MCU互動的。除此之外，我基於資深同事提出的proprietary protocol架構上做改進，並且設計提供給AP使用的API，其實也理解了設計protocol的原則，包括易用、相容性、功能獨立性等等。</p>
<p>這一年對我來說是技術成長最快的一年，開始練習解決問題需要有系統的思維，除了AP層以外，更加理解軟體與硬體的相依性，BSP的概念等等。那時候我常常都是在ARM的exception handler中加上dump stack的功能，然後反推造成當機的原因。這些經驗對後來看待問題時有很大的幫助，會思考這個OS的運作性質是什麼，怎麼去分配記憶體的，比較能夠有系統觀去解決問題。</p>
<h3 id="第三年"><a href="#第三年" class="headerlink" title="第三年"></a>第三年</h3><p>第三年因為要做經驗傳承，開始跟資深同事學習公司既有的proprietary OS，除了AP以外，更重要的是底層kernel的運作，類似UNIX上面STREAM的架構。由於FreeRTOS的架構相對來說比較簡單(有些人甚至認為比較像library)，所以proprietary OS也是強化了我對OS的理解，而且多了可以比較的參照物。除此之外，因緣巧合下我開始有了機會可以當project leader，雖然團隊加上我只有3個人，不過也算是個不錯的經驗。我主要負責的是與PM、測試溝通，然後分配feature &amp; bug給團隊，並且確保merge的code沒有任何問題。同時間，我也開始和其他同事合作導入CI&#x2F;CD、code review的概念，剛好就在我的project上進行實驗。</p>
<p>這個時間點對我來說除了技術以外，開始有了與人相關的任務，不論是領導還是溝通。另外因為自己有比較多一點的權力，所以也嘗試導入自己所喜歡的文化，如CI&#x2F;CD。比較有趣的是，我發現以前的同學也差不多在這個時間擔任leader的角色，也許大家走的路都差不多吧！</p>
<h3 id="現在"><a href="#現在" class="headerlink" title="現在"></a>現在</h3><p>延續前一年，我開始擔任既有產品的maintain窗口，學習分配工作給團隊的其他人，並且思考要怎麼進行有效率的溝通，不論是團隊內還團隊外。技術方面則是開始接觸eCos這個系統，雖然外界已經沒人在用了，但是這個產品仍然需要有人maintain。發現挺有趣的是我差不多一年接觸一種OS，也加深了以前學OS的一些概念，例如synchronization、scheduler等等。</p>
<p>其實到了現在我覺得已經進入了一個坎，技術開始進步緩慢，而且因為既有產品線眾多，有許多maintain的effort，沒有心力去學新技術。目前，不得不好好反思自己的職涯規劃，以往我都是認為只要有學習成長就可以了，沒有想太多自己未來的走向，包括什麼是自己的強項，我接下來的時間要學什麼，可以成長多少等等。如果再宏觀一點，從人生角度來說，我規劃學習這些技術對工作有什麼幫助？在我的生命中是什麼樣的地位？我的人生究竟是想要什麼？成就感嗎？還是只要賺夠多錢就行了？這些都是以前有想過，但是沒有仔細思量的，現在因爲工作上面遇到了些障礙，所以會開始思考什麼才是自己想要的。</p>
<p>雖然我是因為感覺沒有成長所以思考是不是要改變跑道，但是另一方面來說，我覺得也是因為這個契機才開始會反省工作在自己人生中的意義是什麼，這倒也不是什麼壞事。人本來就應該要很清楚自己想要什麼，留在某個地方就是要承擔自己失去的其他機會成本，離開某個地方就是要能捨棄當前環境的舒適以及穩定，沒有好或壞，就只是要自己承擔相對應的責任。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這職場三年多下來，其實我也學習了很多事情，比起技術而言，我覺得最重要的是觀念的改變。從一個人的觀念和面對事情的態度，大概就可以推估他的未來發展。技術要學其實是可以很快，但是個人特質是很難短時間內改變，因此我覺得這是影響個人成就非常深遠的關鍵。以下就我的觀點分享認為重要的事情。</p>
<ol>
<li>發問前一定要再三思考<ul>
<li>在問別人問題的時候，要先思考想從對方那邊得到什麼樣的答案。簡單來說就是不要無腦發問，同事都是很忙的，所以相對應來說可以問問題的次數是有限制。因此每次發問都先思考：我問的問題是否其實查一查資料或做做實驗就可以解決？我想問的問題到底是什麼？有時候整理一下自己的想法後，就赫然發現其實問題已經得到了解答，根本不需要問人，這也是常聽到的<a href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E9%BB%84%E9%B8%AD%E8%B0%83%E8%AF%95%E6%B3%95">Rubber Duck Debugging</a>。</li>
<li>一般來說我們遇到不確定的問題都會去請教主管，看要怎麼做會比較好，這個做法在剛進公司時是OK的，畢竟對工作內容還不熟，但是隨著自己慢慢熟悉，要做的應該是自己能夠做主並且決策。以公司的角度來說，多請人就是要減少大家的工作量，如果事事都要去問人的話，那就不需要多請人了。當然有些問題可能是一定要主管做決策的，那可以提出自己的想法以及建議的解決方式，主管只要確認我們的解法沒有什麼大問題就可以了。</li>
</ul>
</li>
<li>定期反省，找出更有效率的做法<ul>
<li>可以的話，建議每天做日記，思考今天的工作內容有什麼可以改進之處。不過老實說這樣確實是蠻累的，而且會變成無腦的慣性，所以也可以改成每週一次。一個人在工作上的表現，大概就是解決問題的能力和效率，如果這個能力能不斷提升，能創造的價值就越高。</li>
<li>舉例來說，在我的公司就是要處理很多文件流程，每次要跑大家就都要到處問人，後來我受不了了，乾脆自己整理一份跑流程的SOP，每次跑我就參考SOP執行，如果有錯再修改SOP，大大減少我在工作上的煩躁感。而且後來有新人進來要跑流程時，我也可以請他們看SOP，而不需要手把手教學，減少時間的浪費。</li>
</ul>
</li>
<li>用目的論思考，了解自己做的事情是為了什麼，要解決什麼問題<ul>
<li>我發現有時候自己做的事情和別人對我的期待其實是有落差，我認為重要的東西，別人卻覺得那個不是重點。因此面對任何任務，都要確定做這件事的目的是什麼，例如是要給客戶滿意的解釋，還是要百分之百肯定問題的根因，然後是不是值得投入相對應的資源。</li>
<li>常常做事情都會不小心過度鑽研在細節上面，大家各自提出自己的意見，而無法做出正確的決策，這時候最好都是要回到最初的問題：我們到底是要解決什麼，怎麼決策才能符合我們最一開始的目的。不會有完美的解答，但是只要能達到設定的目標，那就是可以接受的答案。</li>
</ul>
</li>
<li>溝通的時候，站在對方的立場思考<ul>
<li>工作上基本上一定會有cowork的機會，而很多的爭論幾乎都是來自於溝通不夠完全。回應他人的問題時，可以站在他的角度思考，他想得到什麼答案，我能提供什麼答案，怎麼在中間取得平衡，不要變成事情都是某一方去承擔，另一方面也是提高溝通效率，不會信件來回很多次都得不到共識。</li>
<li>有時候不要太依賴信件，有些情況直接面對面溝通會來得有效率，且也不會太過生硬，讓人有距離感，有時候都是因為雙方文字上彼此誤會而吵起來。</li>
</ul>
</li>
<li>要定期盤點自己的能力<ul>
<li>我會強烈建議要隨時maintain一份A4的履歷，並不是說要騎驢找馬，而是為了把自己重點且精華的能力精簡成一份履歷，其實也是認識自我的一種方式。整理完後會發現原來自己的強項是什麼、還欠缺什麼，工作的時候就比較不會得過且過，而是會用宏觀的視野思考為什麼要做，還能怎麼做會更好，因為這些都將變成未來與人談判的籌碼。當然如果有好的機會的話，已經有一份履歷在手，就可以隨時把握。</li>
</ul>
</li>
<li>負起責任<ul>
<li>負起責任有幾個方面，首先就是對自己做的事情，任務交到自己的手上，那就是要把它做好，如果發現有任何問題就是要隨時反應，不要到了最後一刻才說。另外這也隱含了一點：我不是機器人，別人說什麼就做什麼，而是要有能力自己判斷、決策並且承擔最後的結果。能做到這點，周圍的人就可以放心與自己合作了。</li>
<li>另外一方面是對自己負責，<strong>永遠要記得不管做什麼決定，承擔結果的是自己</strong>。不管是想要加班做事情、針對某個問題作深入鑽研、隱藏遇到的問題裝做表面一片和諧，其實都無妨，只要能夠接受最終結果就好。既然都已經是成年人了，就不要想著拿盡所有好處而且可以逃避責任。以職業生涯來說，選擇自己的去留也是同樣的道理，如果放棄了現在的位置，那就別未來才後悔失去了許多福利，如果選擇留著，那也別再抱怨沒有新的成長，一切都是在於自己的選擇。</li>
</ul>
</li>
</ol>
<p>不過老實說，上面的分享也只適用於想不斷提升自己的情況，但是人生是有很多面向的，我也曾經看過有人工作只出五分力，剩下的時間都是專注在自己的生活品質上面。這並沒有什麼不好，甚至如果以長遠來看，他說不定活得還比認真努力打拼的人更快樂。反正，最重要的還是要記得<strong>人生是自己的，做什麼決定都沒關係，只要肯承擔後果就好</strong>。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>天性與熱情</title>
    <url>/2024/12/01/%E5%A4%A9%E6%80%A7%E8%88%87%E7%86%B1%E6%83%85/</url>
    <content><![CDATA[<p>長久以來，專長與興趣一直是人們爭論的焦點。往往我們所擅長的事情和感興趣的事情不會完全一致，所以這也被大家一直拿出來討論，到底要順著自己能力走，還是應該要順著自己喜愛的方向去。長輩或老師們很常給出的建議是，用自己擅長的能力來為生，然後多餘的時間再來發展自己的興趣。這個可以說是最穩健的做法了。</p>
<p>最常拿出來的例子就是愛因斯坦。他是人類歷史上最偉大也是最知名的物理學家之一，能與他相比的大概也只有牛頓而已。然而在成為物理學家之前，他是想成為帕格尼尼一樣出色的小提琴演奏家。最終，他還是選擇了物理當他的工作，小提琴當成是興趣。根據一位音樂評論家所說，愛因斯坦的演奏很棒，但是世界上還有很多跟他一樣優秀的演奏家。因此可以合理判斷他如果轉職去當小提琴演奏家，可能並不會有像他在物理學界中這樣偉大的地位。</p>
<p>不過我最近讀了「<a href="https://www.books.com.tw/products/0010914870">別做熱愛的事，要做真實的自己</a>」，對於所謂的專長與興趣的爭論有了不一樣的觀點。其實書中的核心概念是就算做你有熱情的事情，但是偏離自己的核心價值觀和核心能力，一樣不會感到快樂。我原來的想像是如果能做自己感到興趣的事情，就算沒有其他人優秀，應該也會很開心才對。然而事情並不是這樣的。</p>
<p>比起過去所謂的專長與興趣，天性和熱情或許是更適合拿來討論的框架。所謂的天性並不只是關於你擅長什麼，更多的是你在什麼樣的狀態會最舒適，能發揮出潛力。至於熱情則是更加和自我理想相關，期望能夠在某個領域有所成就，產生出影響力。這兩者並不必然會一致。我們可能會因為社會期待、過去經歷等等原因，希望得到像心目中典範人物的成就，但是因為生長背景的關係，欠缺達到這樣成就的個性和能力。這時就算我們非常有熱情，也會因為和自己天性不合，而不斷消耗精力，過得很不快樂。</p>
<p>用實際一點的例子來說，一個人可能因為過去受到老師的啟發，希望未來也能成為像恩師一樣幫助更多小孩。但是如果他本身並不善於與人溝通打交道，更別說年紀差距很大對象，這時就算他對教育很有熱情，也會不斷被現實所消磨，不再那麼快樂。又或者說，我們看到名人非凡的成就，如 Elon Musk 創造了對人類未來影響巨大的多間公司，內心感到彭湃衝動，覺得大丈夫當如是也。然而回歸到現實層面，姑且不論金錢或是運氣成分，有多少人可以像是 Musk 一樣不斷去賭身家冒險，一次失敗可能就跌落谷底，更別說他敢於得罪人，一旦覺得成本不划算就大幅裁員。他能夠為了達到目標不擇手段，因此可以有如此偉大的成就，這是他的天性，所以做起來沒太大壓力，而想要模仿他的人，光是這些事情的內在消耗就足以讓人精疲力竭了。</p>
<p>由上述例子可以知道，專長和興趣比較集中在技能上面的討論，但是天性和熱情則是更廣泛，更加注重我們內在的價值觀和動機。因此，我們更有可能找出兩者的交集，也正是<strong>在具有熱情的領域中做符合自己天性的事情</strong>。同樣用上面的例子，對教育有熱忱但卻又相對內向的人或許不適合當直接面對孩子的老師，他也許可以鎖定在家長身上，又或者是撰寫兒童教育相關的文章教學，提供給家長們參考。對崇拜 Elon Musk 的人來說，更重要的是了解為何自己會對他的成就所感染，也許是享受被人關注、又或者是對人類未來科技發展非常關注，找出動機，然後試著搭配符合天性的能力，這或許才是自己真正所想要的。</p>
<p>如何找到適合自己天性與熱情的工作一直都不是容易的事情，<strong>重點在於要認識自己的天性以及尋找自己的熱情</strong>。到底自己擅長做什麼，什麼環境讓自己舒適能發揮能力，更重要的是什麼是內心不可退讓的核心價值觀。這些是很多人都無法明確回答的問題。另一方面，我們也要尋找什麼事情能夠感染自己，這唯一能做的只有多加嘗試和閱讀。嘗試去經歷不同的事情，多加與不一樣的人交流，都是很好的方式知道適不適合。其中成本最低的方式莫過於閱讀了，透過閱讀可以非常輕易地了解與自己完全不一樣的人的經驗與觀點。我非常相信這個世界上一定有一個最適合自己並且能產生無可取代價值的位置，只是現在我們還沒遇到而已。</p>
<p>不用過於著急，畢竟宏觀來說，人生的目的不過就是一趟尋找自己天性與熱情交會之處的旅程而已。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>學習之道</title>
    <url>/2025/01/26/%E5%AD%B8%E7%BF%92%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<p>學習並非是一件容易的事情，但在變化迅速的現代社會中，學習新技能卻又是不可避免的事情。以前人們可以靠一門手藝就能成家立業，然而現在隨著電腦、手機、AI 等科技不斷演化，任何一門行業也都必須要不斷與時俱進才行。不會使用新的科技，競爭力就會弱於精通的同行，舉例來說，會使用 Uber 的店家比起傳統餐廳會多了新的客源。「活到老，學到老」或許不再是勵志的鼓勵，而是未來社會生存所需遵守的殘酷法則。</p>
<p>話說如此，其實也是有些技巧可以輔助我們學習的。</p>
<h2 id="學問的骨架"><a href="#學問的骨架" class="headerlink" title="學問的骨架"></a>學問的骨架</h2><p>首先，最重要的是要掌握骨架。人類並不擅長把所有細節都記住，但是卻非常善於聯想。利用這個特點，我們可以先把某門學問的衣架穩固搭建起來，然後在上面掛上各種知識的衣服。用比較實際的例子來說，假設我們現在要學某個國家的歷史，最好的方式會是先記住這個國家有哪些朝代，而不用管每個朝代的特色和細節。甚至應該說，<strong>學習時要有意識地去忽略各種細節，直到框架被建立起來為止</strong>。當我們可以隨時從腦海中調用出框架時，在上面連結的各種知識才會有所本，不至於變成零散的小知識，遺失在大腦的某個角落裡。</p>
<p>下個問題可能是，那我怎麼知道這個框架長什麼樣子？這分成兩種情況：如果是已經比較成熟的領域，可以直接參考各種書的目錄。大部分優秀的書籍都會有很好的方式來梳理知識的脈落，我們可以利用這個框架，然後在大腦中重新搭建屬於自己的架構出來。另一種情況則是比較嶄新的領域，尚未有人做好整理，只有很多知識零碎地散在網路上。這時候必須依靠自己來為知識做分類歸納。一般來說可以先找出架構圖，基於這架構來拓展自己的知識。例如說現在比較新的電動車領域，我們可以用車子本身的架構當作基礎，然後再針對每個元件來一一了解，如電池、馬達等等。之後隨著自己對該領域理解的增加，可以再逐漸調整認知的框架。</p>
<h2 id="重視輸出"><a href="#重視輸出" class="headerlink" title="重視輸出"></a>重視輸出</h2><p>任何學習都不能只是接收資訊而已，沒有具體輸出、實際使用，一切都只是空談而已。最有名的費曼學習法就是運用這個道理：我們嘗試用簡單的方式向他人解釋某個知識，在過程中發現有解釋不清楚的地方，就回過頭來重新檢視自己的理解，直到能夠清楚講解為止。很多時候我們以為已經學會了，但其實並沒有，那只是大腦的錯覺。唯有嘗試用自己的話語來表達，才會發現某個環節並沒有想像中那麼清楚。<strong>語言對人類思考有著至關重要的影響，當我們能組織好言語脈落，才能證明已經真正理解其中意義</strong>。</p>
<p>這也印證了前面提到的骨架重要性。要能講清楚某件事情，其實很大程度依賴於一個清楚的框架，如此才能有條不紊地陳述，讓他人容易理解。缺乏框架，不只自己不好學習，也容易讓聽眾混淆，無法真正理解想傳達的概念。</p>
<p>除了用講的，若是學習技能類的事物，一定要去使用，特別在自己所需的情境下使用。學習而沒有使用，就好像單純看著地圖認路一樣。我們可以記住某條路到某條路的交叉口要右轉，但是一個熟悉的在地人更多是靠著明顯的路標來記憶路線要怎麼走。這些路標也可以稱之為「情境」。背了很多單字文法，和實際上跟外國人對話所需要的能力並非一致。按照書本學習寫程式的語法和最佳實踐，和實際開發專案所用到的知識也是有所落差。這並非是學習教材有問題，而是<strong>只有我們真正使用時才會意識到有些細微的情境並無法完整用言語呈現，必須透過親身經歷才行</strong>。</p>
<h2 id="善用-AI-工具"><a href="#善用-AI-工具" class="headerlink" title="善用 AI 工具"></a>善用 AI 工具</h2><p>在 AI 尚未出現前要自學其實難度並不低，最大的困難點在於學習不免會碰上卡關的地方。如果有老師在可以快速給予反饋，若是沒有就需要花大量時間去尋找資料，比對不同教材，看看有沒有誰的講法更讓自己易懂。這是我過去自學所遇到的最大困難。</p>
<p>現在有了 AI 輔助，大大減少了尋找資料的時間。對一門新的領域，可以先讓 AI 用簡單的方式講述基本框架，並且取得適合的參考連結。學習的過程中，一有問題馬上就直接詢問，還是不懂的地方也能追問或請它換個方式講述。這就好像多了一位老師可以 24 小時待命一樣。更別說像是語言類的學習還能夠直接與它對話，就像是真的與老外對談一樣。</p>
<p>不過，如果是要學習嶄新或冷門領域的學問，AI 可以給予的幫助就有限了。AI 擅長的是在大量資料中整理出脈絡，因此資料的品質極為重要。全新或冷門領域的知識，一來量少，二來品質也參差不齊，必須要有批判性的判斷來篩選才行。有些 AI 會提供它的資訊來源，最好需要仔細驗證才行。</p>
<h2 id="重視動機"><a href="#重視動機" class="headerlink" title="重視動機"></a>重視動機</h2><p>學習動機或許是學習過程中最重要的部分了。我們被過去的應試教育所訓練，認為學習要積極主動、甚至在碰到問題前就先學起來放。然而這反而會加大自己的壓力、增添煩惱、並且失去動機，最後聽到學習就退避三舍。</p>
<p>最好的方式是偷懶一點，當有需要用到的時候再來學。我們動機應該是遇到了問題需要解決，而非因為榮譽或是其他外在因素。這個很重要，因為它代表了學習的方向。以程式為例，我們可能是要解決某個專案的問題而不得不學，這時目標就很明確，只需要學習需要用到的部分就好，而不是完全精通所有程式語法。<strong>人類比我們想像中更善於解決問題，當明確知道方向時，所能展現的能力將會出乎意料</strong>。</p>
<p>另外一種動機可能是好奇心，其實某種程度上也是要解決問題，只是這個問題是來自我們心中的疑惑。解決心中的疑惑並不必要把某門知識從頭學起。也許我們對物理的相對論感興趣，但是比起從大學的普通物理開始讀起，更好的方式是去看點科普讀物，當有更多疑惑時再一個個去理解就好。</p>
<p>總而言之，學習的動機應該要具體而微，而非大又廣泛。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>市面上教導如何學習的書千百種，各式各樣的方法都有，例如刻意練習、沉浸式學習、間隔學習等等，而上面所分享的是個人經驗中對我特別有用的方法。不過，比起討論什麼學習方法才正確，更重要的是找出適合自己的方法。現代社會中最需要學習的不是某門特定的學問和知識，而是學會「元學習」，也就是學習如何學習這回事！</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>川普當選後對世界格局分析</title>
    <url>/2024/11/17/%E5%B7%9D%E6%99%AE%E7%95%B6%E9%81%B8%E5%BE%8C%E5%B0%8D%E4%B8%96%E7%95%8C%E6%A0%BC%E5%B1%80%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近最熱門的事情莫過於川普當選後人們紛紛嘗試預測未來世界格局會怎麼變化、該如何進行投資。我自己也很喜歡讀國際政治、財經相關的文章。在閱讀那麼多資訊後也來嘗試整理一下自己的分析和觀點，幫助未來更好地修正自己的系統判斷。</p>
<p>川普是屬於典型的強人，很重視個人魅力，而不是傳統上的政治妥協。因此比起其他的總統，他的個性就特別的重要。川普畢竟是商人出身，比起價值來說更重視利益，彼此之間的關係能不能帶來商業價值，所以不會用價值體系來強化盟友關係，而是更多用雙邊談判取代多邊談判。他很喜歡強調和其他獨裁強人的關係很好，因為他認為可以只要搞定獨裁者就可以省去其他談判上的麻煩，儘管這並不是事實(想想他第一任北韓的例子)。川普也很好大喜功、愛面子，更重要的是著迷於權力，要求部屬對其完全的忠誠。</p>
<p>在美國內政上，我們先不考慮金融海嘯或是疫情等無法預測的黑天鵝。川普的民調沒太多意外的話上任一陣子後應該會快速滑落，主要原因在於他任用的官員幾乎都是對其忠心的人為主，很多私德或能力上面有很多問題(至少從目前公布的名單來看)。一旦團隊出了包，肯定會被對其不是那麼友好的媒體放大檢視，創造出很多爭議的話題出來。另外馬斯克所提出的改善政府效率部門也會因為得罪很多政府單位的人而造成爭議，可以想想當初 X 是怎麼被人批評的。然而這也是有好處的，當政府效率提升、管制變少，再加上川普很重視股市，可以想像經濟會繼續向上提升，至於通膨是否會更嚴重那就真的不好說了，至少目前市場是這麼認為的。我對川普 2026 的期中選舉並不會很樂觀，就如同他的第一任一樣。在民調下滑時，強人通常會採取對外強硬的態度，接下來就看看外交部分。</p>
<p>先看看烏克蘭，我的看法是戰線會開始緩和下來，最終形成如南北韓的格局。川普有很大的可能性會直接和普丁碰面，如同他和金正恩碰面一樣，想展現他解決問題的能力。然而因為俄烏問題實在太過複雜，他不太可能逼迫哪方讓步，最終就是看在美國壓力上維持現狀。烏克蘭需要美國武器，俄羅斯不希望美國解禁長程武器的限制和提供更多先進裝備，雙方只能妥協。烏克蘭要不回烏東領土、俄羅斯也無法將烏克蘭去軍事化，納入其大斯拉夫主義下的緩衝區。這對烏克蘭是短空長多，至少他有時間重建經濟，接受歐盟援助。對俄羅斯則是短多長空，雖然取得大片烏東領土，但因為兩年的戰爭已轉為戰時經濟，再加上歐美制裁可能不會那麼簡單解除，經濟會大受影響，更別說石油價格可能會因為川普的政策大幅下滑，進而影響其出口。我猜測到時俄羅斯目前多餘的軍工產能會轉移到其他地方，特別是非洲，造成當地局勢升溫。</p>
<p>中東部分按照川普第一任做法應該會持續對以色列友好，畢竟以色列不需要過多的軍援，且可以牽制伊朗，達成美國的戰略目標。在現在伊朗的代理人哈馬斯、真主黨等等都遭受大量打擊的情況下，巴勒斯坦人的聲音會逐漸消失於媒體之中。沙烏地阿拉伯不見得會和以色列建交，但是關係的改善是可預見的。至於伊朗和沙烏地阿拉伯的關係雖然之前有所緩和，但是應該不會近一步升溫。不過由於土耳其前陣子才斷絕與以色列的關係，他的態度如何值得繼續觀察。</p>
<p>另一個熱點東亞從川普目前內閣名單來看對中會持續強硬，再加上他討厭為他國提供保護的角度來看，應該會放手讓日韓自己強化軍備，特別日本新首相石破茂也希望戰略自主的情況下。對台灣方面，由於選前不斷放話要保護費，可預見的是軍售項目會增加，另外也會將此視為對中國施壓的籌碼。至於北韓部分，川金會面的機率應該不大，北韓不太可能放棄核武，而現在又有俄羅斯撐腰，更沒有意願和美國對話。對俄羅斯而言，北韓不只是提供炮彈和兵力的盟友，更可以當成撬動對美國東亞布局的槓桿，可預見兩國關係會持續深化。中國對川普上台應該會很難受，特別是中國是美國最大的戰略對手，他會更加強化與東南亞和拉丁美洲的關係，至少在兩國對抗中不會站隊到美國陣營去，另外也期望能多少彌補失去的美國市場。至於俄中關係不大可能會結成同盟，但會持續彼此利用，美國是否能像過去聯中抗蘇一樣做到聯俄抗中，我是不太看好，畢竟其歐洲盟友對此會非常敏感。</p>
<p>至於投資上，我對股票市場前景算是看好，川普討厭貿易逆差，因此討厭匯率高，他應該會逼迫 FED 主席鮑威爾降息 (FED 願不願意做是另一回事)。如果再加上管制放寬，可預見新創企業會有很多新機會，特別是跟 AI 相關的。在政府減少監管下，手握大量現金的科技巨頭也會開始併購企業。軍工行業部分，雖然川普不愛戰爭，但是他喜歡做生意，再加上美國縮手在全世界的軍事存在感，各國對國防需求會大增，我想軍工企業生意應該會變好。至於石化能源，川普對其友善，並且會取消綠能補助，但是如果大量生產石油反而會造成石油價格下降，而石油下降又會對純電動車造成壓力，因此我對石化產業和綠能、電動車產業沒那麼看好。區塊鏈相關企業應該會放寬管制，但我總覺得區塊鏈會對美元霸權造成威脅，所以需要多些研究才行。以地域方面來看，美國的關稅會迫使企業從中國轉移到第三方，如印度、東南亞、南美，而中國為了爭取支持也會大量投資他們，這些地方應該會持續受惠。</p>
<p>以上是目前我所看到的趨勢，但是實際上並不一定會這樣走，畢竟川普的不可預測性真的有點高，大家都是邊看邊調整。對於專家來說預測失準非常正常，更別說是我這樣業餘興趣的人了。總之先提出想法，再根據世界變化來修正認知，找出跟當初想像不吻合之處，這樣才能逐漸提高自己的眼光。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>常用軟體工具統整</title>
    <url>/2017/11/11/%E5%B8%B8%E7%94%A8%E8%BB%9F%E9%AB%94%E5%B7%A5%E5%85%B7%E7%B5%B1%E6%95%B4/</url>
    <content><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="開啟docx-pttx-xlsx"><a href="#開啟docx-pttx-xlsx" class="headerlink" title="開啟docx, pttx, xlsx"></a>開啟docx, pttx, xlsx</h3><ul>
<li>Office(word, excel, powerpoint, visio)：Windows和MAC上還是用就微軟的工具比較方便。</li>
<li>LibreOffice：Linux上的話可以用這個，但是其實我是不推薦在Linux上做類似的事。</li>
</ul>
<h3 id="開啟pdf"><a href="#開啟pdf" class="headerlink" title="開啟pdf"></a>開啟pdf</h3><ul>
<li>Foxit：適用於Windows、Linux，可用來取代Adobe Reader來看pdf檔案。</li>
<li>MAC的話其實用預設的預覽程式就足夠了。</li>
</ul>
<h3 id="筆記"><a href="#筆記" class="headerlink" title="筆記"></a>筆記</h3><p>下方筆記軟體都是可以跨平台的</p>
<ul>
<li>QOwnNotes：支援Markdown、tags和資料夾的筆記軟體，我會搭配dropbox來進行同步，可參考<a href="http://www.qownnotes.org/">官網</a></li>
<li>evernote：最常見的筆記軟體，但是不支援完整Markdown，我只用來記雜事用。</li>
<li>GitBook：之前有用這個來做筆記，但是反應速度有點慢，不推薦。</li>
</ul>
<h3 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h3><ul>
<li>texmaker: 專門處理Latex的工具</li>
<li>Poedit: 專門處理po的工具</li>
</ul>
<h2 id="網路功能"><a href="#網路功能" class="headerlink" title="網路功能"></a>網路功能</h2><h3 id="browser"><a href="#browser" class="headerlink" title="browser"></a>browser</h3><ul>
<li>Chrome</li>
<li>Firefox</li>
</ul>
<h3 id="檔案交換"><a href="#檔案交換" class="headerlink" title="檔案交換"></a>檔案交換</h3><ul>
<li>Dropbox：支援跨平台</li>
</ul>
<h3 id="FTP-client"><a href="#FTP-client" class="headerlink" title="FTP client"></a>FTP client</h3><ul>
<li>FileZilla FTP：支援跨平台。</li>
</ul>
<h3 id="遠端連線"><a href="#遠端連線" class="headerlink" title="遠端連線"></a>遠端連線</h3><ul>
<li>TeamViewer：支援跨平台。</li>
</ul>
<h3 id="ssh-client"><a href="#ssh-client" class="headerlink" title="ssh client"></a>ssh client</h3><p>下面只介紹Windows的部分，因為Linux和MAC都可以用ssh或scp指令連線</p>
<ul>
<li>putty(MTPutty)</li>
<li>pietty：支援Big5的putty版本</li>
<li>winscp：如果要用ssh來取得檔案用這個很方便。</li>
</ul>
<h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><ul>
<li>FortiClient SSL VPN：我只用過這個，而且還是舊版的，我記得是每個OS都可以使用，未來可以再研究看看。</li>
</ul>
<h3 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h3><p>只支援Windows，如果是Linux和MAC是可以用command line下載TFTP。</p>
<ul>
<li>Tftpd32：如果要自架TFTP Server的好工具，可參考<a href="http://tftpd32.jounin.net/">官網</a></li>
</ul>
<h2 id="社交軟體"><a href="#社交軟體" class="headerlink" title="社交軟體"></a>社交軟體</h2><ul>
<li>Skype</li>
<li>LINE</li>
<li>Telegram</li>
</ul>
<h2 id="程式"><a href="#程式" class="headerlink" title="程式"></a>程式</h2><h3 id="文字編輯器"><a href="#文字編輯器" class="headerlink" title="文字編輯器"></a>文字編輯器</h3><p>一樣只介紹Windows，其他平台建議直接用vim</p>
<ul>
<li>notepad++：非常輕量級的文字編輯器，非常好用。</li>
<li>gvim：Windows上的vim，但是有時候並不是那麼好用。</li>
</ul>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>其他平台我是都用command line，但是也許可以再找找有沒有好的圖形化介面</p>
<ul>
<li>Git &#x2F; Tortoise Git：用來追蹤code必備工具</li>
</ul>
<h3 id="虛擬化"><a href="#虛擬化" class="headerlink" title="虛擬化"></a>虛擬化</h3><ul>
<li>VirtualBox：跟其他虛擬機的差異是他是Open Source，但是穩定度比起來還是有差。</li>
<li>Docker：我是比較少用，但是用的對的話，其實是個好工具。</li>
<li>qemu：當沒有開發板的時候挺好用的</li>
</ul>
<h3 id="interpreter"><a href="#interpreter" class="headerlink" title="interpreter"></a>interpreter</h3><ul>
<li>Python：可以用來執行我們寫的簡單小程式。</li>
</ul>
<h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><ul>
<li>CodeBlock：要測試code可以在上面compile看看，但是不夠輕量，有時候不如開Linux虛擬機測試比較快。</li>
<li>gcc：MAC和Linux。</li>
</ul>
<h3 id="GUI-Editor"><a href="#GUI-Editor" class="headerlink" title="GUI - Editor"></a>GUI - Editor</h3><ul>
<li>vscode：好用的編輯器，而且跨平台，支援許多套件</li>
</ul>
<h3 id="debug工具"><a href="#debug工具" class="headerlink" title="debug工具"></a>debug工具</h3><ul>
<li>Wireshark：抓封包專用，三個平台都適用。</li>
</ul>
<p>以下都是Windows上的工具，還沒找到其他平台的版本</p>
<ul>
<li>iReasoning：可以用來做SNMP query。</li>
<li>HxD：看檔案的二進位。</li>
<li>WinMerge：比對code專用。</li>
<li>Colasoft Packet Builder: 修改pcap</li>
<li>Colasoft Packet Player: 重放packet</li>
</ul>
<h2 id="影音"><a href="#影音" class="headerlink" title="影音"></a>影音</h2><h3 id="播放音樂"><a href="#播放音樂" class="headerlink" title="播放音樂"></a>播放音樂</h3><ul>
<li>iTunes：適用Windows和MAC，播放、整理音樂的工具。</li>
</ul>
<h3 id="影片"><a href="#影片" class="headerlink" title="影片"></a>影片</h3><ul>
<li>SMPlayer：適用於Windows和Linux的播放器</li>
<li>IINA：適用於MAC。</li>
</ul>
<h3 id="剪輯影片"><a href="#剪輯影片" class="headerlink" title="剪輯影片"></a>剪輯影片</h3><ul>
<li>威力導演：剪影片專用，適用於MAC</li>
</ul>
<h3 id="燒錄"><a href="#燒錄" class="headerlink" title="燒錄"></a>燒錄</h3><p>目前找到的都只適合Windows</p>
<ul>
<li>Free Make Vedio Converter：燒DVD專用。</li>
<li>burnaware：可以燒iso和音樂CD。</li>
<li>DVDFab Virtual Drive：模擬虛擬光碟機。</li>
</ul>
<h3 id="轉檔"><a href="#轉檔" class="headerlink" title="轉檔"></a>轉檔</h3><ul>
<li>格式工廠：如果要轉檔的話非常好用。</li>
</ul>
<h2 id="系統"><a href="#系統" class="headerlink" title="系統"></a>系統</h2><h3 id="套件管理"><a href="#套件管理" class="headerlink" title="套件管理"></a>套件管理</h3><ul>
<li><p>Linux就隨Distro而有不同</p>
</li>
<li><p>MAC的話可用homebrew</p>
<ul>
<li>brew的使用方法如下</li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新list</span></span><br><span class="line">brew update</span><br><span class="line"><span class="comment"># 找套件</span></span><br><span class="line">brew search [套件名]</span><br><span class="line"><span class="comment"># 檢查哪些套件過時</span></span><br><span class="line">brew outdated</span><br><span class="line"><span class="comment"># 更新套件</span></span><br><span class="line">brew upgrade</span><br><span class="line"><span class="comment"># 清除cache</span></span><br><span class="line">brew cleanup</span><br><span class="line"><span class="comment"># 找官網</span></span><br><span class="line">brew home</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="優化電腦"><a href="#優化電腦" class="headerlink" title="優化電腦"></a>優化電腦</h3><ul>
<li>WiseCare 365：適合Windows</li>
<li>Magican、AppCleaner：適合MAC</li>
</ul>
<h3 id="監控系統狀態"><a href="#監控系統狀態" class="headerlink" title="監控系統狀態"></a>監控系統狀態</h3><ul>
<li>CrystalDiskInfo：監控硬碟狀態，適合Windows</li>
<li>smartd：Linux可用這套軟體看硬碟狀態。</li>
<li>menumeter：看系統整體資訊的付費軟體，適用MAC。</li>
</ul>
<h3 id="解壓縮工具"><a href="#解壓縮工具" class="headerlink" title="解壓縮工具"></a>解壓縮工具</h3><ul>
<li>7-zip：適合Windows</li>
<li>The Unarchiver：解壓縮工具，適用MAC</li>
<li>CleanArchiver：壓縮工具，適用MAC</li>
</ul>
<h3 id="連接手機"><a href="#連接手機" class="headerlink" title="連接手機"></a>連接手機</h3><ul>
<li>Android File Transfer：在MAC上如果要連android手機必備</li>
</ul>
<h2 id="CLI-tools"><a href="#CLI-tools" class="headerlink" title="CLI tools"></a>CLI tools</h2><p>MAC可以用iterm取代原來terminal</p>
<h3 id="CLI-Editor"><a href="#CLI-Editor" class="headerlink" title="CLI - Editor"></a>CLI - Editor</h3><ul>
<li>vim</li>
</ul>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><ul>
<li>zsh</li>
<li>tmux</li>
<li>mosh：可以保持連線不要斷掉，當網路一旦恢復就會馬上連回去。</li>
</ul>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><ul>
<li>git</li>
<li>tig</li>
</ul>
<h3 id="program"><a href="#program" class="headerlink" title="program"></a>program</h3><ul>
<li>ipython</li>
<li>irb</li>
<li>silversearcher-ag：找字串</li>
<li>cloc：算程式碼數量</li>
<li>ctags</li>
<li>astyle：coding style工具</li>
</ul>
<h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><ul>
<li>lynis: 檢查系統安全性<ul>
<li>使用方式<code>lynis -c</code></li>
</ul>
</li>
<li>smartmontools：讀取硬碟資訊</li>
<li>mtr：看網路狀態，ping和traceroute的結合</li>
<li>tree：可以列出目錄</li>
<li>htop、iotop、iftop：各類的top</li>
<li>httpie：command是http</li>
<li>ncdu：加強版的du</li>
<li>tldr：簡化版的man</li>
<li>trash-cli：trash-list, trash-rm, trash-put, trash-empty, restore-trash</li>
<li>fd：更簡單的find</li>
</ul>
<h3 id="hacker"><a href="#hacker" class="headerlink" title="hacker"></a>hacker</h3><ul>
<li>nmap：掃描網路上的機器</li>
<li>hydra：暴力破解的軟體</li>
<li>openssl：加解密工具</li>
<li>sqlmap：SQL injection工具</li>
</ul>
<h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><ul>
<li>qpdf：對pdf檔做一些操作</li>
<li><a href="https://evshary.github.io/2018/12/02/gnuplot%EF%BC%9A%E5%A0%B1%E5%91%8A%E5%BF%85%E5%82%99%E7%9A%84%E7%B9%AA%E5%9C%96%E5%B7%A5%E5%85%B7/">gnuplot</a>：畫圖的工具</li>
<li><a href="https://evshary.github.io/2018/11/25/youtube-dl%E7%B6%B2%E8%B7%AF%E5%BD%B1%E7%89%87%E4%B8%8B%E8%BC%89%E5%99%A8/">youtube-dl</a>：下載youtube<ul>
<li>使用方式youtube-dl -F [URL]：看有哪些格式</li>
<li>youtube-dl -f 136&#x2F;mp4 [URL]：選擇格式下載</li>
</ul>
</li>
<li><a href="https://evshary.github.io/2018/12/01/ffmpeg%E5%BD%B1%E9%9F%B3%E8%99%95%E7%90%86%E5%B7%A5%E5%85%B7/">ffmepg</a>：轉換影片檔</li>
<li><a href="https://evshary.github.io/2018/10/14/GnuPG%E6%95%99%E5%AD%B8/">GPG</a>：認證工具</li>
<li>irssi：IRC工具</li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>updating</tag>
      </tags>
  </entry>
  <entry>
    <title>《心流》：最佳體驗的專注</title>
    <url>/2018/04/28/%E5%BF%83%E6%B5%81%EF%BC%9A%E6%9C%80%E5%84%AA%E9%AB%94%E9%A9%97%E5%BF%83%E7%90%86%E5%AD%B8/</url>
    <content><![CDATA[<p>人生的意義到底是什麼呢？這個問題應該每個人或多或少在成長過程都有想過吧？特別是在青春期的時候，心裡因為不知道未來的方向，而有陷入迷惘中，會覺得人生好像是沒有意義的。在我高中時期就是在這樣的狀態中，為了符合外在的要求(拿到好成績)而努力，但是卻不知道自己心裡真正是為何而努力。這樣的心情雖然隨著年齡的增長而慢慢減緩，但是若是問到自己的人生有什麼意義這回事，我想我還是回答不出來。</p>
<p>但是，人生的意義其實根本就只是個偽命題。我們通常期望很輕鬆地得到一個目標，然後再去努力，但是常常人生的意義是先去努力，然後才會得到。最近看了「<a href="http://www.books.com.tw/products/CN11489806">心流：最優體驗心理學</a>」 ，裡面提到了「<strong>最終目標只要能為一生的精神能量建立秩序，它本身是什麽並不重要。人生的意義就在於“尋求意義”：不論它的本質，不論它來自何處，只要找到一個統一的大方向，人生就會有意義。</strong>」，這時才隱隱約約明白，原來我根本不缺乏人生意義，我想要的是內心的平靜、內心的秩序，也就是作者所講的心流狀態。意義本身並不重要，每個人都可能有屬於自己的意義，但是在追求意義本身就會為自己生命賦予價值。</p>
<p>「心流」這個概念其實我很久以前就聽過了，一開始是從強者我朋友那裡得知，我原本以為這是一個用在學習的工具罷了，並不是很在意。最近因為有些我看的書籍有再次提到這個概念，才想說來看看當初提出這個概念的作者米哈里的原書。這本書最早是在1990出版，台灣也有出自己的翻譯本，應該是叫<a href="http://www.books.com.tw/products/0010036164">快樂.從心開始</a> ，但也已經絕版了，而最近中國才重出了這本書。的確，如果 google 心流這個詞，十之八九是講我們在面對有一定挑戰性的事情時，進入了聚精會神的狀態，忘了時間的流動，只專注在當下。進入心流會創造最佳的體驗，會讓自己想要一再體驗，這也是很多學習的書籍鼓吹的學習方式。</p>
<p>如果把進入心流的條件和刻意練習相比，會發現兩著有很高的相似性。兩者都一樣需要有個明確的目標、有即時的反饋、需要全神貫注地投入、需要有適當的挑戰性(跨出舒適圈)。但是在本書的介紹序也有提到，兩者的動機是完全不同的，刻意練習是為了讓自己的能力獲得提升，是一種行為，而心流則是一種體驗，讓人沈醉且上癮。儘管如此，我個人的經驗是有意識進行刻意練習時，有時候也會有種進入心流的狀態，忘記時間，想要繼續做下去。雖然本質不同，但是兩者是可以相輔相成的。</p>
<p>為什麼進入心流會讓我們愉悅呢？書中有提到一個概念叫做精神熵，熵在物理的意義是亂度，越高代表越混亂。如果我們的精神熵越高，就代表我們的意識失去了秩序，受到了威脅，我們必須要去防衛，自然就會感到不快樂。心流的意義我會解釋成<strong>心靈的秩序</strong>，就像磁鐵要有磁性一定要被磁化，讓內部分子的南北極都同向，對外才會產生出一股磁力。當我們進入心流狀態也就是在內心建立起了秩序，不會被外界可能讓心靈混亂的事物打擾，因此才會有忘記自我，忘記時間的感覺。</p>
<p>以秩序來解釋為什麼會快不快樂似乎有其道理。米哈里提到了享樂和樂趣的差別：享樂是恢復均衡的體驗，主要是維持意識的秩序，但無法創造新秩序，樂趣需要高度注意力，完成意料之外的事情。因為樂趣的高複雜度、有挑戰性，所以不斷提供大腦新鮮感，這也是樂趣可以維持比較長久的快樂。另外值得一提的是，如果我們是為了什麼目的才做某件事情，可能就不有趣，就像我們不是為了得到勝利而玩遊戲，而是享受在玩遊戲的過程。因為如果有目的的話，我們就不是專心在當下遊戲規則所帶來的秩序了。遊戲規則主導了我們的心流，讓我們內心維持了秩序，所以有些人在使用外掛後很快就會對遊戲失去興趣的原因也是在秩序已經被破壞了，規則無法再帶給我們心靈秩序了。</p>
<p>米哈里不只是用心流來解釋我們進入專心的狀態，書中他更是嘗試用心流來解釋人類的社會、文化、甚至是遇到困境時要怎麼克服。這也是讓我眼界大開的一部份，原來心流也是可以用來解釋更高層次的現象。社會與文化說穿了其實也就是一種規則，一種秩序，在過去社會文化上的規範會規定我們的外在行為應該要怎麼做，有很多的限制，但是大多數人在成長過程中接受了這樣的限制，然後久而久之自己也成為要求他人遵守這些規則的人。然而在現在的世界，國際間的文化交流、網際網路的發達，拓展了每個人的視野，追求個人自由的風氣中屏棄掉了傳統文化，因此人們有更多選擇。但是更多選擇不代表會更快樂，因為會陷入了不知道要選什麼才好的狀態。這就跟我們父母一輩不會有用興趣選職業這件事，而是找個穩定收入的工作或繼承家業，沒有什麼其他選擇，而我們這代則會迷惘進大學時到底要選擇什麼樣的科系，未來要找什麼工作，到底自己對什麼有興趣。這個選擇越多越不快樂的現象正呼應了人失去了秩序後會不快樂的概念。</p>
<p>但是我個人覺得，這不代表我們要走回頭路，的確規範可以帶給大多數人秩序，但是並沒有道理要求所有人都遵守這樣的規範，自由與民主已經深入人心，難以逆轉。我們能做的是知道這個現象，然後清楚自己的迷惘是來自心靈的失序，接著透過不斷與外界的互動來重新建立自己的秩序，最後就會形塑出屬於個人的價值觀，也就是個人的生命意義。米哈里也建議，我們可以從宗教、歷史、文學等等過去前人所建立的秩序中吸取經驗，建立起屬於自己內心不被擾亂的模式，用前人的力量賦予自己生命新的意義。</p>
<p>本書帶給我很多新的觀念，特別是讓我重新認識了「心流」。在閱讀時，我得承認作者的敘述、排版方式有點冗長，比較沒有架構性，不過不妨礙本書的價值。另外我會推薦大家要看一下推薦序的部分，雖然我從來沒看過那麼長的推薦序，但是卻是一個很好的總結，書中大多數的精華都有被整理出來了。我們不只是要追求在學習上全神貫注的心流，更是要追求人生的心流，真正內心的秩序必須要上從人生觀下到自己的行為都達成一致，並且能心無旁騖專注在其中。如果要用一句話解釋我從這本書得到的觀念，我會這麼說：<strong>快樂與幸福來自我們內心的和諧，建立一個可以應付外界干擾的秩序，讓自己的外在行為與內心秩序一致，那就是在人生的心流之中了</strong>。</p>
]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>我對 AI 的應用與反思</title>
    <url>/2025/02/23/%E6%88%91%E5%B0%8D%20AI%20%E7%9A%84%E6%87%89%E7%94%A8%E8%88%87%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>隨著 AI 的普及，我在日常生活中使用 AI 的機會也越來越多。AI 的能力不斷提升，每年都有質的飛躍，使得許多事務都可以依賴這個新工具。因此，了解 AI 能為我提供哪些幫助，以及它的極限在哪裡，就變得至關重要。</p>
<h2 id="AI-對我的幫助"><a href="#AI-對我的幫助" class="headerlink" title="AI 對我的幫助"></a>AI 對我的幫助</h2><p>以下是我最常使用 AI 的四種功能：</p>
<h3 id="1-語言學習"><a href="#1-語言學習" class="headerlink" title="1. 語言學習"></a>1. 語言學習</h3><p>首先影響最大的是語言學習上。過去，我們學一個語言會需要老師幫我們糾正文法和用詞，現在則不同。由於網路充滿各種文本資源，因此每個 AI 都是語言大師，能夠流暢處理各種語言。我經常請 AI 協助修改文章，不論是中文還是英文，它都能提供建議，修正文法和流暢度，甚至還能夠調整文章架構和標題。雖然大部分情況下我為了保留個人風格會有限度地採納，但是多了一位智能編輯幫忙給意見確實有很大的幫助。</p>
<p>除此之外，現在 AI 不只能夠修正文字，更重要的是可以口語對話。一般來說學語言最難的是口說的部分，畢竟除非是去上課，不然不會有太多對話的機會。現在 AI 突破了這個限制，我們可以跟它天南地北地聊各種主題，不用害怕講錯話，還可以從對話中學習新單字和用詞。其實，口語對話並沒有那麼困難，甚至大多數情況也不用太在乎文法正確性，重點是能夠流暢表達自己的想法。可以說 AI 有效幫助我突破了這層心理障礙。</p>
<h3 id="2-學習新知識"><a href="#2-學習新知識" class="headerlink" title="2. 學習新知識"></a>2. 學習新知識</h3><p>過去，我在學習一門新領域的知識時，大部分會先去取得該領域介紹書籍，了解該領域的基本框架。當有問題的時候則是大量查詢網路上的資源，期盼有人有遇到同樣問題，並且有相對應解答。這個過程可以說非常耗時間，有些問題其實很細節，不太容易找到資料，就算請教老師，因為需要時間反芻，也不一定可以當下聽懂。</p>
<p>這個情況在有了 AI 後就完全不同了，我們可以先讓 AI 用簡單的方式告訴我們該領域的基礎概念，而不需要一開始就去讀整本的書籍。最重要的是，當有任何問題我們隨時都可以發問，這點可以省去大量的查詢時間。我們想要的解答通常存在網路上的某個地方，原來需要自己不斷搜索，融會貫通，現在 AI 可以直接幫我們處理掉這段。更棒的是，我們能夠自己掌握學習的節奏，想追問細節就追問，需要時間思考也可以毫無顧忌隨時停下來。</p>
<p>舉例來說，最近我在學區塊鏈中智能合約。以往，我需要去查詢多篇講智能合約的教學或書籍，比較並整合，整理出一個大致上的合約流程。而現在，我可以直接詢問 AI，當我覺得哪邊講不夠細或有問題，可以立刻追問請它補充。例如，當我想知道佈署智能合約的封包內容這類細節的知識，以前需要翻閱專門的技術文件，如今 AI 能馬上告訴我，學習效率大幅度提升。</p>
<h3 id="3-取代部分筆記功能"><a href="#3-取代部分筆記功能" class="headerlink" title="3. 取代部分筆記功能"></a>3. 取代部分筆記功能</h3><p>以前，我習慣將常用的程式語法和工具使用方式記錄在 <a href="https://github.com/evshary/cheat-sheet">GitHub</a> 上，以便日後快速查閱。初次使用某個工具時，我會花時間查詢安裝與使用方法，並確認網路上的教學內容是否可行，為了避免下次重複查找，通常都會寫下筆記。</p>
<p>然而，如今有了 AI，比起翻找過去的筆記，直接詢問 AI 可能更為快速。有些過去的筆記可能已經不再具有價值，甚至未來許多筆記都不需要再紀錄，因為 AI 可以隨時提供可靠的答案。</p>
<h3 id="4-輔助開發"><a href="#4-輔助開發" class="headerlink" title="4. 輔助開發"></a>4. 輔助開發</h3><p>AI 也能在開發過程中提供幫助，雖然目前 AI 無法完全取代軟體工程師，但在一定程度上能減少開發負擔。例如，我最常使用 AI 來開發簡單的腳本程式。開發者時常需要撰寫程式來處理資料、繪製圖表等，而這些簡單的工作通常需要調用知名函式庫或熟悉特定腳本工具。以往，工程師只能透過搜尋 API 文件和範例來學習，畢竟沒人會完全記得怎麼用，現在則可以直接請 AI 生成程式碼，大幅加快開發速度。過去可能需要半天完成的工作，現在可以在半小時內搞定。</p>
<p>此外，對於某些輸入輸出明確的演算法與函式，AI 也能提供協助。例如，以前要撰寫一個計算四分位數的函式，可能需要上網尋找範例或自行手刻，現在只要清楚描述需求，AI 便能直接給出正確的程式碼。我認為，這也使得傳統演算法測試（如 LeetCode）變得越來越沒有價值，因為未來更重要的是如何清楚定義問題，而不是單純記憶演算法解法。當然基礎的演算法和資料結構還是得熟練，但是沒必要走火入魔地追求演算法解題速度。就像雖然會使用普通的螺絲起子，能用電動螺絲起子省時省力的時候還是應該去用。</p>
<h2 id="AI-的限制"><a href="#AI-的限制" class="headerlink" title="AI 的限制"></a>AI 的限制</h2><p>AI 進步速度很快，卻在某些情境還是表現不甚理想。儘管在日新月異的科技進步下，也許未來這些問題都將會被解決，然而在此之前，我們還是要對其能力極限有所認知。</p>
<ol>
<li><p>新興領域資訊不足</p>
<p>當我們所要學習的領域並非熱門領域時，網路上的資料少且品質參差不一，甚至在變動很快的領域上，可能很多資料都是過時的。AI 因為使用網路資源來學習，所給出的答案也會受到影響。在這種情況下，我常常發現它的答案很常是前後不一致或是根本錯誤。現在很多 AI 回答問題時都會提供它的資訊來源，要特別檢查一下是否可信。</p>
</li>
<li><p>無法應對複雜系統和情境</p>
<p>在簡單明確的狀況，AI 可以給出完美的答案，但是在大多數狀況下，我們要解決的問題可能更加複雜。例如在 A 系統和 B 系統一起運作的時候會出現特定 bug，又或者是在跑某個條件下的測試，效能會大幅度降低。這些問題很難讓 AI 直接替我們解答。這時軟體工程師的價值就在於拆分大問題並一一排除，直到找到問題的根源。AI 能幫我們的是確認拆分出來的小問題有沒有問題，像是某段程式碼有沒有邏輯錯誤之類的。</p>
</li>
<li><p>可能會出錯</p>
<p>AI 是有可能出錯的，有時候會發現它產生的程式碼並不能順利編譯和運作，因此工程師們需要有最基礎的判斷能力來檢查它的結果。很多情境我們並不是直接拿它的產出結果來用，而是基於此之上做改進。工程師和 AI 的關係不是單純一個做一個說，更多情況是 AI 做簡單但繁瑣的事情，工程師檢查後再拿來做複雜的應用。AI 就像是一個能力有限但動作很快的夥伴，我們要熟知這個特點，在避免錯誤下來提升工作的效率。</p>
</li>
</ol>
<h2 id="人類的核心能力"><a href="#人類的核心能力" class="headerlink" title="人類的核心能力"></a>人類的核心能力</h2><p>當 AI 能力不斷提升，那麼什麼對人類才是最重要的呢？下面三點是我認為在與 AI 共存的時代所需的能力：</p>
<ol>
<li><p>想法重於技術</p>
<p>當 AI 已經能輕易完成人類需要很長時間才能熟練的技術時，十年磨一劍的刻苦精神或許價值沒那麼高了。對人類而言，真正重要的是我們想要做什麼、解決什麼問題，也就是要有清楚的想法。很多原來受限技術的事情，我們可以用 AI 來輔助完成。過去寫個網站、APP 有些難度，需要有一定程度的開發者才能做到，未來可能門檻不再那麼高，普通人只要有想法，都能自行弄出一套系統出來。<strong>這個時代將不缺聽指令做事的人，AI 可以替換他們，但是卻無法取代有各種奇思妙想的創造者。</strong></p>
</li>
<li><p>表達能力</p>
<p>在過去人們總強調團隊合作的重要性，團隊怎麼相處和溝通會影響成敗。<strong>未來世界將不僅如此，我們要學會跟 AI 溝通才行</strong>。這就牽涉到表達能力的重要性，我們是透過語言讓 AI 幫我們做事，如果沒辦法明白把自己的需求講清楚，將只會得到錯誤的結果。如何有邏輯易懂的方式講述問題，將會是重要的關鍵。</p>
</li>
<li><p>承擔責任</p>
<p>AI 再怎麼強大，在負起責任上還是無法取代人類。我們可以聽 AI 的醫學建議，但是還是需要有個實際的醫生存在，因為這個醫生才是負起責任的人。當 AI 出錯的時候，我們沒辦法向 AI 究責，因此需要有個實體存在。這也是為何自駕車的推廣那麼困難了，當自駕車發生車禍的時候，究竟誰能負起責任呢？<strong>因此不應該害怕承擔責任，責任反而是人無法被取代的重要因素。</strong></p>
</li>
</ol>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>就如同現在人類已經無法脫離 3C 產品一樣，未來我們的日常生活都需要 AI 輔助提高效率。我不認為 AI 能完全取代人類，但我們必須認知它的能力和極限，在了解這個工具的情況下，專注於我們人類最核心的價值。過去，機器解放了人類的體力勞動，讓我們專注於腦力工作；現在，AI 逐步取代大量的腦力工作，使我們能夠進一步發揮創造力，邁向更高層次的發展。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>探討區塊鏈的價值</title>
    <url>/2025/03/09/%E6%8E%A2%E8%A8%8E%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E5%83%B9%E5%80%BC/</url>
    <content><![CDATA[<p>加密貨幣這個詞越來越常出現在人們生活中，不論是新聞媒體還是朋友圈中。可惜的是，大家探討的通常是「比特幣又突破新高」、「某國總統發行了迷因幣」、「某個名人投資虛擬貨幣被詐騙」，很少真正觸及加密貨幣背後——也就是區塊鏈——的本質。</p>
<p>區塊鏈是什麼？究竟解決什麼問題？如果無法理解它的價值就去投資加密貨幣，那內心就會隨著幣圈中各種消息而起伏，心裡不踏實。</p>
<p>這篇文章會先探討區塊鏈想解決什麼問題，然後再簡單描述其運作原理。</p>
<h2 id="公開帳本的價值"><a href="#公開帳本的價值" class="headerlink" title="公開帳本的價值"></a>公開帳本的價值</h2><p>讓我們先把區塊鏈放一邊。想像一個跟我們一樣的世界，但唯一的差別是<strong>這個世界有一個公開的公佈欄，任何人都能在上面記錄資訊，而且這些記錄無法抹除或竄改</strong>。請問我們可以怎麼使用這個公佈欄呢？</p>
<p>我想你一定可以想到很多應用，其中最重要的應用跟錢脫離不了關係——也就是「帳本」。過去人們交易要怎麼證明自己有付錢呢？我們可能是一手交錢一手交貨，也可能是透過銀行轉帳，對方確認帳戶有收到錢。一般來說這樣並沒有什麼問題，然而這是在人們可以直接接觸，又或者是都在同一個銀行體系的情況下。如果我們想把錢轉給地球上另一個人，這個過程會經過層層不效率的銀行體系，最後才到對方的手裡。</p>
<p>若是使用這個公佈欄，那會有什麼改變呢？我們只需要在公佈欄上記錄 A 轉 100 元給 B，這樣就行了。這之間完全不需要涉及第三方（如銀行），而且價值轉移是立即完成，對方也可以馬上從公佈欄上確認。最重要的是，我們不需要使用實體的錢，完全依靠公佈欄上的記錄就可以。舉例來說，A 收到了 500 元，轉了 100 元出去，計算後知道 A 剩下 400 元。只要對方能相信公佈欄上的記錄，A 就可以用剩餘的 400 元來進行其他交易。<strong>本質上，對公佈欄的信任就是這個流程最重要的基礎</strong>。</p>
<p><img src="/images/%E5%85%AC%E9%96%8B%E5%85%AC%E4%BD%88%E6%AC%84.drawio.svg" alt="公開公佈欄"></p>
<h2 id="區塊鏈的原理"><a href="#區塊鏈的原理" class="headerlink" title="區塊鏈的原理"></a>區塊鏈的原理</h2><p>然而，我們現實世界並沒有這樣的公開公佈欄。因此，中本聰發明了「區塊鏈」來確保公佈欄公開並且可以隨時存取的特性。</p>
<p>區塊鏈這個系統讓多個人<strong>分散持有</strong>這個公佈欄，並且有<strong>經濟誘因</strong>一起記錄各種交易。由於多人持有，所以不會因為任何人離開而無法存取這個公佈欄。而為了讓人願意參與這個系統，則需要提供足夠的經濟動機。</p>
<p>下面我們針對這兩點來分別說明：</p>
<h3 id="分散持有"><a href="#分散持有" class="headerlink" title="分散持有"></a>分散持有</h3><p>分散持有聽起來很美好，但分散也就意味著彼此同步的困難。以區塊鏈來說，需要透過所有人的共識來確保公開紀錄的一致性。</p>
<p>在區塊鏈上，我們會把交易紀錄記在一個個區塊上面，而每個區塊都可以產生出某個特殊的特徵值。這個特徵值會被包含在下一個區塊上，並依此產生出新的特徵值。因此，區塊和區塊之間就有了關係，形成了一條鍊，也就是「區塊鏈」的名稱由來。</p>
<p><img src="/images/%E5%8D%80%E5%A1%8A%E9%8F%88%E7%9A%84%E6%A6%82%E5%BF%B5.drawio.svg" alt="區塊鏈的概念"></p>
<p>透過一些加密演算法，這些特徵的產生很困難，需要大量的計算。越多人參與計算，又或者說算力越強，就越有可能找出特徵，形成鏈上的新區塊。</p>
<p>然而，由於分散持有，我的計算結果和你的計算結果可能會有差異，這條鏈就分叉了。這時就要引入共識機制：所有人只會接受最長的鏈，較短的鏈會被捨去。越長的鏈代表著越多的參與者，所以某種程度上也算是多數決，由多數的那方決定哪個分岔要留下來。</p>
<p><img src="/images/%E4%BF%9D%E7%95%99%E6%9C%80%E9%95%B7%E7%9A%84%E9%8F%88.drawio.svg" alt="保留最長的鏈"></p>
<p>透過這樣的方式，我們就能在分散的情況下，確保紀錄的公開一致性了。</p>
<h3 id="經濟誘因"><a href="#經濟誘因" class="headerlink" title="經濟誘因"></a>經濟誘因</h3><p>解決了公開一致的問題後，我們還需要確保有足夠多的參與者，畢竟沒有人會想白白提供自己的計算能力給別人。因此，還必須提供一些經濟動機給參與者。</p>
<p>前面提到區塊的產生需要找出獨特的特徵值，區塊鏈會透過獎勵找到特徵值的人一些收益，來增加人們參與系統的意願。當你的計算力越強，產生出的區塊越多，就能有越多收益。這樣從無到有產生出價值的行為，類似於礦工從礦石中挖出黃金的形象，所以人們又稱之為「挖礦」。</p>
<p>區塊鏈設計巧妙之處在於，<strong>明明參與者只是為了自己的利益而行動，但是他行動的副產品，卻又協助紀錄各種交易，維持公開帳本的存在</strong>。隨著人們越來越信任公開帳本，參與者收益的價值會不斷向上提昇，進而吸引更多人參與其中。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>除了最基本的公開帳本功能，後來的區塊鏈技術衍生出更多的應用，例如自動執行程式的智能合約、確認所有權的 NFT 等等。雖然這些複雜的應用擁有更多潛在的經濟價值，但也提昇了一般人進入的門檻。我們需要回歸區塊鏈最基礎的本質來思考。</p>
<p>此外，人們對區塊鏈的認知過度強調加密貨幣的價格波動，而非它能解決什麼問題上，這並非是好事。<strong>一項技術的成功必須基於其本身的價值，唯有了解其價值，才能真正客觀看待未來的發展性</strong>。</p>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>區塊鏈</tag>
      </tags>
  </entry>
  <entry>
    <title>《深度學習的技術》：一種學習的框架</title>
    <url>/2018/03/11/%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E7%9A%84%E6%8A%80%E8%A1%93/</url>
    <content><![CDATA[<p>會知道這本書是因為之前有在追蹤該作者的<a href="https://4think.net/">部落格</a>，該部落格是分享作者看完書後的讀後心得，他看的書品質都算是很高，有時候我也都會參考他的書單、心得來決定是否要看這本書。後來作者把他看的書做一個總結，寫成一本關於學習的書，也就是這本「<a href="https://4think.net/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92%E7%9A%84%E6%8A%80%E8%A1%93%E3%80%8B/">深度學習的技術</a>」。原本是有點懶得買，因為並不是實體而且感覺轉帳什麼的很麻煩，不過在同事的勸誘下還是買了。從結論來說我覺得這本真的值得這個價錢，畢竟作者的論述很清晰、有條理，而且都有引用其他著名書籍內容，某種程度上也是集大成了，可以從作者的方法再進一步學習、研究出屬於自己的學習方式。</p>
<p>作者把整個學習過程分成五個階段：<strong>記、懂、網、拓、活</strong>。記是記憶的意思，講了幾個科學上實驗研究很有用的記憶方法，包括「提取練習效應」、「間隔效應」、「交錯效應」、「生產效應」、「變動效應」等等。但我從中學到的是<strong>記不是要強調記憶本身，而是要練習「提取記憶」這件事</strong>，所以這些方法都是訓練自己在不同情況下都能夠順利提取記憶，確保自己真的有記憶牢靠，所以也難怪背誦時只是不斷重複閱讀是效率極差，而透過各種提取，如講出來、寫出來、測驗等等記憶的效率會再高一點。這點我應該可以拿來在學習單字上試試做些驗證。</p>
<p>懂的部分就是要讓自己記憶力最大化，有幾個方式：相鄰可能(複利效應)、發散模式(利用散步等時間思考事情)、自然頻率(找適合人類的學習方式，如故事、思想實驗)、透徹程度(以教為學)、工作記憶(善用紙筆)。內容就不一一多提，但是我想最重要的是人類在演化上、構造上還是屬於生物，所以學習上還是有一定生理限制，這些就是讓我們可以用比較輕鬆的方式理解知識。</p>
<p>網則是強調知識的排列重要性，作者強調了碎片化學習不是不好，畢竟很多時候都只能利用零散的時間來學習，但是最重要的是我們需要把知識進行排列，因為往往知識的排列本身比起知識點是更為重要的。要構成知識網有兩個支柱，分別為知識排列以及刻意練習，知識排列算是我們對外顯知識(例如物理學、經濟學等理論)的人工佈線，透過佈線構成自己的知識架構，而刻意練習則是用在學習內隱知識(如開車、游泳等等難用文字描述的領域)，強化我們網狀架構的廣度、強度和密度。這邊不得不提<a href="http://www.books.com.tw/products/0010752714">刻意練習</a>真的自從出版後就被各種提到，而且都是我覺得值得一看的好書，好的方法果然是會被其他好書不斷重複提起，這也驗證了重要知識是很容易在生活中重複出現的。</p>
<p>前面都在講怎麼學習，但是學習什麼也是很重要的。拓的部分在講知識是有品質的差別的，要如何辨別知識對自己的價值有三個方面：正確性(過濾機制)、多樣性(跨領域學習)、創造性(思想孵化器)。我認為正確性講的是人類總是有心理學上的弱點，而透過第二層思考就可以盡可能避免被錯誤的知識誤導。多樣性則提到了蒙格的多元思維模型，透過學習多個學科最重要的模型，破除學問間的壁壘，可以解決更多困難的問題。順帶一提，蒙格的<a href="http://www.books.com.tw/products/0010643983">窮查理的普通常識</a>也是被各種推廣的好書，雖然內容並不是很有條理的方法論(比較多是演講形式)，但背後的思想可是備受推崇，之後可能也會想收藏一本當傳教用(誤)。最後的創造性則是強調透過寫作讓自己的思維可視化，並且促進更進一步的思考。</p>
<p>最後的「活」先提到了要時時注意一石多鳥，學習要用最有效率的方式學習，不論是閱讀還是做筆記都是，找到好的方法，並且使用它。而更重要的是學了知識就是要用，我很喜歡書中的這句話<strong>「知識就像是金錢一樣，不花就等於不曾有過」</strong>，作者建議使用知識的方法是開始屬於自己的個人項目，並且給了一些找到與實踐個人項目的方法和原則。我是很認同他的想法，畢竟我也常覺得看完書後好像就只是這樣，沒有真正改變了什麼。也許我也該從一個個人項目開始發揮我所學到的內容。</p>
<p>這本書原則上我非常地推薦，是值得一讀的好書。先不論書中方法對錯，光是作者把各個書的精華統整出自己的知識架構就已經值回票價了。當然，我不是完全認同書中的方法，但是我覺得書中的統整確確實實是改變我一些學習的方法。所以我的建議是<strong>不要完全照抄書中的方法，而是要善用作者的統整，建構出屬於自己的學習習慣</strong>，這樣才算是最大化利用這本書。</p>
]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>淺談函式庫</title>
    <url>/2018/05/12/%E6%B7%BA%E8%AB%87%E5%87%BD%E5%BC%8F%E5%BA%AB/</url>
    <content><![CDATA[<h2 id="比較shared-static-library"><a href="#比較shared-static-library" class="headerlink" title="比較shared&#x2F;static library"></a>比較shared&#x2F;static library</h2><p>程式在執行的時候，大部分都會需要引用函式庫(library)，library有分shared和static，兩者代表不同的引用方式。</p>
<table>
<thead>
<tr>
<th></th>
<th>static library</th>
<th>shared library</th>
</tr>
</thead>
<tbody><tr>
<td>優點</td>
<td>不需要考慮執行環境的相依性問題</td>
<td>使用空間小(檔案和記憶體)、更換library不用重build</td>
</tr>
<tr>
<td>缺點</td>
<td>執行檔極大、更換library需重build</td>
<td>在異地執行可能會因為相依性無法執行</td>
</tr>
</tbody></table>
<h2 id="動態函式庫"><a href="#動態函式庫" class="headerlink" title="動態函式庫"></a>動態函式庫</h2><p>在開始前，先確定幾個名詞</p>
<ul>
<li>soname：代表特定library的名稱，如libmylib.so.1，最後面的1是version</li>
<li>real name：實際放有library程式的檔案名稱，名稱會包含三個版號，分別為version, minor和release，如libmylib.so.1.0.0<ul>
<li>version代表原介面有移除或改變，與舊版本不相容</li>
<li>minor代表新增介面，舊介面沒改</li>
<li>release代表程式修正，介面沒改</li>
</ul>
</li>
<li>linker name：用於連結時的名稱，不含版號的soname，如libmylib。通常會link到實際的real name。</li>
</ul>
<h3 id="動態函式庫-如何編譯"><a href="#動態函式庫-如何編譯" class="headerlink" title="動態函式庫 - 如何編譯"></a>動態函式庫 - 如何編譯</h3><p>首先我們先把<code>.c</code>編譯成<code>.o</code>，這邊要加上-fPIC的參數</p>
<p>這個原因是要產生Position Independent code，確保code segment在動態連結時不用花時間重新定位，而且重新定位會造成無法和其他process共享.text區段。</p>
<p>事實上，如果不加-fPIC也是可以產生library，但是產生的執行檔就需要另外存有重新定位的資訊(.rel.dyn區段)，而且會有上述的問題。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c -fPIC hello.c world.c</span><br></pre></td></tr></table></figure>

<p>接下來就是產生shared library了，解釋一下參數的意思</p>
<ul>
<li><p><code>-shared</code>：代表要編成shared library</p>
</li>
<li><p><code>-Wl</code>：是用來傳遞參數給linker，讓-soname和libmylib.so.1傳給linker處理</p>
</li>
<li><p><code>-soname</code>：用來指名soname為libmylib.so.1</p>
</li>
<li><p><code>-o</code>：最後library會被輸出成libmylib.so.1.0.0</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -shared -Wl,-soname,libmylib.so.1 -o libmylib.so.1.0.0 hello.o world.o</span><br></pre></td></tr></table></figure>

<p> soname很重要，就如同前面所提，可以讓開發者和應用程式表示兼容標準，可以用objdump確認soname</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ objdump -p libmylib.so.1.0.0 | grep SONAME</span><br><span class="line">  SONAME               libmylib.so.1</span><br></pre></td></tr></table></figure>

<p> 完成後再用ln建立soname和linker name兩個檔案</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s libmylib.so.1.0.0 libmylib.so</span><br><span class="line"><span class="built_in">ln</span> -s libmylib.so.1.0.0 libmylib.so.1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="動態函式庫-如何使用"><a href="#動態函式庫-如何使用" class="headerlink" title="動態函式庫 - 如何使用"></a>動態函式庫 - 如何使用</h3><p>如果有人要使用的話，下列兩種方式都可以。不過要注意目錄下如果同時有static和shared會使用shared為主，如果要static就要加上-static編靜態函式庫</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc main.c libmylib.so -o a.out</span><br><span class="line">gcc main.c -L. -lmylib -o a.out</span><br></pre></td></tr></table></figure>

<p>但是shared library執行的時候還是需要有library才能執行，所以要把.so安裝到系統中，有三種方法：</p>
<ol>
<li>把libmylib.so.1 放到系統常見的library目錄，如&#x2F;lib, &#x2F;usr&#x2F;lib</li>
<li>設定<code>/etc/ld.so.conf</code> ，加入一個新的library搜尋目錄，並執行ldconfig更新<code>/etc/ld.so.cache</code></li>
<li>設定LD_LIBRARY_PATH 環境變數來搜尋library，如<code>LD_LIBRARY_PATH=. ./a.out</code></li>
</ol>
<p>這邊提一下一般而言找library的順序</p>
<ol>
<li><code>LD_LIBRARY_PATH</code>或<code>LD_AOUT_LIBRARY_PATH</code>環境變數所指的路徑</li>
<li>從<code>ld.so.cache</code>的記錄來找shared library。</li>
<li><code>/lib</code>,<code>/usr/lib</code>內的檔案</li>
</ol>
<h3 id="查看shared-library的關係-ldd"><a href="#查看shared-library的關係-ldd" class="headerlink" title="查看shared library的關係 - ldd"></a>查看shared library的關係 - ldd</h3><p>我們要怎麼知道某個執行檔有使用到哪些library呢？這時候就要用到ldd這個指令了。</p>
<p>ldd其實是一個shell script，它會把檔案所用到library一一列出，包括library會用到的library。</p>
<p>舉例來說，如果我們不用ldd，其實是可以從ELF的Dynamic Section獲得shared library資訊</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -d /bin/cat</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x7dd8 contains 26 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x000000000000000c (INIT)               0x15e8</span><br><span class="line"> 0x000000000000000d (FINI)               0x5a4c</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我們看到NEEDED就是需要的dynamic library，但是這個library可能也需要其他library。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -d /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x198ba0 contains 26 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [ld-linux-x86-64.so.2]</span><br><span class="line"> 0x000000000000000e (SONAME)             Library soname: [libc.so.6]</span><br><span class="line"> 0x000000000000000c (INIT)               0x20050</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>因此我們知道&#x2F;bin&#x2F;cat需要libc.so.6，而libc.so.6還需要ld-linux-x86-64.so.2。這樣尋找實在太麻煩了，其實我們可以直接用ldd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ldd /bin/cat</span><br><span class="line">        linux-vdso.so.1 (0x00007fff8613c000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f654a3bf000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f654a967000)</span><br></pre></td></tr></table></figure>

<p>看，是不是很輕鬆呢？</p>
<h2 id="靜態函式庫"><a href="#靜態函式庫" class="headerlink" title="靜態函式庫"></a>靜態函式庫</h2><p>會有static library的概念是，如果我有很多.o檔，那每次要引用其實都不是很方便，所以最好的方法還是可以打包起來，也就是使用ar指令。</p>
<h3 id="靜態函式庫-如何編譯"><a href="#靜態函式庫-如何編譯" class="headerlink" title="靜態函式庫 - 如何編譯"></a>靜態函式庫 - 如何編譯</h3><p>static libary建立方式很簡單，一樣要先建立.o</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c test1.c test2.c</span><br></pre></td></tr></table></figure>

<p>接下來開始打包，參數意義如下</p>
<ul>
<li><p>r：代表加入新檔案或取代現有檔案</p>
</li>
<li><p>c：.a檔不存在時不會跳錯誤訊息</p>
</li>
<li><p>u：根據timestamp保留檔案</p>
</li>
<li><p>s：建立索引，加快連結速度</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar rcs libtest.a test1.o test2.o</span><br></pre></td></tr></table></figure>

<p> 如果要顯示函式庫 libstack.a 的內容</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ar -tv libtest.a</span><br><span class="line">rw-r--r-- 0/0   1464 Jan  1 00:00 1970 test1.o</span><br><span class="line">rw-r--r-- 0/0   1464 Jan  1 00:00 1970 test2.o</span><br></pre></td></tr></table></figure>

<p> 如果要從libtest.a中取出test1.o</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ar -x libtest.a test1.o</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="靜態函式庫-如何使用"><a href="#靜態函式庫-如何使用" class="headerlink" title="靜態函式庫 - 如何使用"></a>靜態函式庫 - 如何使用</h3><p>編譯方法一樣很簡單，有兩種</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc main.c libtest.a</span><br><span class="line"><span class="comment"># 也可以使用gcc的-l，-L代表要搜尋的目錄位置，-l會捨去library的lib開頭</span></span><br><span class="line">gcc main.c -L. -ltest</span><br></pre></td></tr></table></figure>

<h2 id="symbol衝突"><a href="#symbol衝突" class="headerlink" title="symbol衝突"></a>symbol衝突</h2><p>假設我們在創建library時遇到symbol衝突會發生什麼事呢？這邊我們分三種情況探討</p>
<p>首先先創三個檔案</p>
<p>hello.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>world.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shared-library連結時，object-file有衝突"><a href="#shared-library連結時，object-file有衝突" class="headerlink" title="shared library連結時，object file有衝突"></a>shared library連結時，object file有衝突</h3><p>嘗試編譯與連結</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -c -fPIC hello.c world.c</span><br><span class="line">$ gcc -shared -o libmylib.so hello.o world.o</span><br><span class="line">world.o: In <span class="keyword">function</span> `<span class="built_in">test</span><span class="string">&#x27;:</span></span><br><span class="line"><span class="string">world.c:(.text+0x0): multiple definition of `test&#x27;</span></span><br><span class="line">hello.o:hello.c:(.text+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>

<p>會發現出現錯誤，原因是動態連結跟一般編譯一樣會檢查symbol是否重複</p>
<h3 id="static-library打包時，object-file有衝突"><a href="#static-library打包時，object-file有衝突" class="headerlink" title="static library打包時，object file有衝突"></a>static library打包時，object file有衝突</h3><p>那如果是用static library呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -c hello.c world.c</span><br><span class="line">$ ar crs libhello.a hello.o</span><br><span class="line">$ ar crs libworld.a world.o</span><br><span class="line">$ gcc -o main.out main.c libhello.a libworld.a</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>發現居然沒事，這個原因是因為ar只有打包功能不負責檢查。可是問題來了，到底是執行哪個呢？答案是看順序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -o main.out main.c libhello.a libworld.a</span><br><span class="line">$ ./main.out</span><br><span class="line">hello</span><br><span class="line">$ gcc -o main.out main.c libworld.a libhello.a</span><br><span class="line">$ ./main.out</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<h3 id="使用shared-library時，不同library有衝突"><a href="#使用shared-library時，不同library有衝突" class="headerlink" title="使用shared library時，不同library有衝突"></a>使用shared library時，不同library有衝突</h3><p>那如果是兩個shared library彼此間有函數衝突的現象呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared -o libhello.so  hello.c</span><br><span class="line">gcc -fPIC -shared -o libworld.so  world.c</span><br><span class="line">gcc -o main.out libhello.so libworld.so main.c</span><br></pre></td></tr></table></figure>

<p>結果一樣沒有錯誤，原因是在動態連結時會使用最先看到的symbol，所以順序不同就有不同結果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -o main.out libhello.so libworld.so main.c</span><br><span class="line">$ LD_LIBRARY_PATH=. ./main.out</span><br><span class="line">hello</span><br><span class="line">$ gcc -o main.out libworld.so libhello.so main.c</span><br><span class="line">$ LD_LIBRARY_PATH=. ./main.out</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<p>這個特性也跟LD_PRELOAD有關，我們可以用LD_PRELOAD來抽換shared library就是因為連結時會先使用先看到的symbol。當然這也曾經造成了一些危害，例如goahead的<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-17562">CVE-2017-17562</a>。</p>
<h2 id="執行中載入library"><a href="#執行中載入library" class="headerlink" title="執行中載入library"></a>執行中載入library</h2><p>除了執行開始時載入library外，我們也可以用程式來載入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 動態載入所需的header</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="comment">// 載入指定library</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">// 透過symbol name取得symbol在library的記憶體位址</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">const</span> <span class="type">char</span> *symbol)</span>;</span><br><span class="line"><span class="comment">// 關閉dlopen開啟的handler</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span>;</span><br><span class="line"><span class="comment">// 傳回錯誤訊息。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">dlerror</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>範例：dltest.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">void</span> *handle;</span><br><span class="line">  <span class="type">void</span> (*f)();</span><br><span class="line">  <span class="type">char</span> *error;</span><br><span class="line">  <span class="comment">/* 開啟之前所撰寫的libmylib.so 程式庫 */</span></span><br><span class="line">  handle = dlopen(<span class="string">&quot;./libmylib.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">  <span class="keyword">if</span>( !handle ) &#123;</span><br><span class="line">    <span class="built_in">fputs</span>( dlerror(), <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 取得hello function 的address */</span></span><br><span class="line">  f = dlsym(handle, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(( error=dlerror())!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 呼叫function */</span></span><br><span class="line">  f();</span><br><span class="line">  <span class="comment">/* 結束handler */</span></span><br><span class="line">  dlclose(handle);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>記得編譯時要連結dl library</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc dltest.c -ldl</span><br><span class="line">LD_LIBRARY_PATH=. ./a.out</span><br></pre></td></tr></table></figure>

<h2 id="library公開symbols管理"><a href="#library公開symbols管理" class="headerlink" title="library公開symbols管理"></a>library公開symbols管理</h2><p>有時候我們並不希望所提供的library會把所有symbol都洩漏出去，這時候大部分的人都會使用static限制外部呼叫。但是當這個函式在library中其他檔案會引用到，那就沒辦法設為static了。</p>
<p>那該怎麼辦呢？這邊有兩個方法：</p>
<h3 id="使用-version-script"><a href="#使用-version-script" class="headerlink" title="使用 version script"></a>使用 version script</h3><p>首先我們先創兩個檔案當範例</p>
<p>test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;test\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func\n&quot;</span>);</span><br><span class="line">  test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後我們編成shared library，並且看看symbol</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -fPIC -c test.c func.c</span><br><span class="line">$ gcc -shared -o libmylib.so test.o func.o</span><br><span class="line">$ nm -D libmylib.so | grep -v <span class="string">&#x27;_&#x27;</span>  <span class="comment"># -D 代表顯示dynmaic部分，-v 代表反向選擇</span></span><br><span class="line">00000000000005e8 T func</span><br><span class="line">                 U puts</span><br><span class="line">00000000000005d5 T <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>可以看到test還是被暴露出來了，但是明明test應該只想要在library中被使用而已。</p>
<p>這時候我們可以試試GNU linker的version script。</p>
<p>libmylib.map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  global: func;</span><br><span class="line">  local: *;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>這個意思是只要顯示func，其他function都要隱藏。然後我們link的時候加上version script試看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -shared -o libmylib.so test.o func.o -Wl,--version-script,libmylib.map</span><br><span class="line">$ nm -D libmylib.so | grep -v <span class="string">&#x27;_&#x27;</span></span><br><span class="line">00000000000004e8 T func</span><br><span class="line">                 U puts</span><br></pre></td></tr></table></figure>

<p>成功隱藏test了！</p>
<h3 id="使用-attribute-語法"><a href="#使用-attribute-語法" class="headerlink" title="使用__attribute__語法"></a>使用__attribute__語法</h3><p>除了使用version script以外，也可以用gcc特有的語法，<code>__attribute__((visibility(&quot;default&quot;)))</code></p>
<p>首先我們先改寫要公開的函式，代表我們只要暴露func()給外界看到</p>
<p>func.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">__attribute__((visibility(<span class="string">&quot;default&quot;</span>))) <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func\n&quot;</span>);</span><br><span class="line">  test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後在編譯成.o時要記得加上<code>-fvisibility=hidden</code>，把其他function都隱藏起來。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -c -fPIC test.c func.c -fvisibility=hidden</span><br><span class="line">$ gcc -shared -o libmylib.so test.o func.o</span><br><span class="line">$ nm -D libmylib.so | grep -v <span class="string">&#x27;_&#x27;</span></span><br><span class="line">00000000000005a8 T func</span><br><span class="line">                 U puts</span><br></pre></td></tr></table></figure>

<p>達到的效果和version script一樣！</p>
<h3 id="用version-script控制版本"><a href="#用version-script控制版本" class="headerlink" title="用version script控制版本"></a>用version script控制版本</h3><p>這邊我們再多談談version script其他的用法，其實他除了管理要暴露出來的symbol外，我們也可以依照版本控制library要暴露出來的function。</p>
<p>首先我們先出第一版程式</p>
<p>libtest.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;num=%d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>libtest1.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>

<p>version1.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libtest1.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  func(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後正常編譯執行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -fPIC -c libtest.c</span><br><span class="line">$ gcc -shared -o libtest.so libtest.o</span><br><span class="line">$ gcc -L. -ltest -o version1.out version1.c</span><br><span class="line">$ LD_LIBRARY_PATH=. ./version1.out</span><br><span class="line">num=1</span><br></pre></td></tr></table></figure>

<p>很順利正常執行，那我們假設現在要出第二個版本可以怎麼做</p>
<p>libtest2.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_1</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;num=%d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_2</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;num1=%d, num2=%d\n&quot;</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line">__asm__(<span class="string">&quot;.symver func_1,func@LIBTEST_1.0&quot;</span>);</span><br><span class="line">__asm__(<span class="string">&quot;.symver func_2,func@@LIBTEST_2.0&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>稍微解釋一下，首先先實作兩個function，然後再用後面兩個<code>__asm__</code>的<code>symver</code>來把同樣symbol加上版號，至於第二行<code>@@</code>的意思代表為預設版本。</p>
<p>接下來的部分就一樣撰寫新的程式</p>
<p>libtest2.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br></pre></td></tr></table></figure>

<p>version2.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libtest2.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  func(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然後這時候就要出動version script了</p>
<p>libtest2.map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIBTEST_1.0 &#123;</span><br><span class="line">  global: func;</span><br><span class="line">  local: *;</span><br><span class="line">&#125;;</span><br><span class="line">LIBTEST_2.0 &#123;</span><br><span class="line">  global: func;</span><br><span class="line">&#125;LIBTEST_1.0;</span><br></pre></td></tr></table></figure>

<p>然後我們編譯並執行看看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -fPIC -c libtest2.c</span><br><span class="line">$ gcc -shared -o libtest.so libtest2.o -Wl,--version-script,libtest2.map</span><br><span class="line">$ gcc -L. -ltest -o version2.out version2.c</span><br><span class="line">$ LD_LIBRARY_PATH=. ./version1.out</span><br><span class="line">num=1</span><br><span class="line">$ LD_LIBRARY_PATH=. ./version2.out</span><br><span class="line">num1=1, num2=2</span><br></pre></td></tr></table></figure>

<p>可以看到兩者執行結果不同，為什麼會這樣呢？我們先看一下他們連結到的symbol</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ readelf -a version1.out  | grep func</span><br><span class="line">000000601018  000500000007 R_X86_64_JUMP_SLO 0000000000000000 func + 0</span><br><span class="line">     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND func</span><br><span class="line">    51: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND func</span><br><span class="line">＄ readelf -a version2.out  | grep func</span><br><span class="line">000000601018  000100000007 R_X86_64_JUMP_SLO 0000000000000000 func@LIBTEST_2.0 + 0</span><br><span class="line">     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND func@LIBTEST_2.0 (2)</span><br><span class="line">    46: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND func@@LIBTEST_2.0</span><br></pre></td></tr></table></figure>

<p>可以看到version1.out是使用<code>func</code>，而version2.out的symbol就是<code>func@@LIBTEST_2.0</code>。那同樣是引用相同library，到底是怎麼知道要呼叫哪個func呢？在呼叫<code>func</code>的情況下，會自動找到最初的版本也就是<code>func@LIBTEST_1.0</code>。而之後的程式編譯時link library則會去找default的版本，也就是有兩個@的<code>func@@LIBTEST_2.0</code>，所以就不會有搞混的情況發生了。</p>
<p>這個方法在要維持兼容性的情況下非常好用，可以在不影響舊版的情況下改變函式規格。</p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="http://www.books.com.tw/products/0010587783">BINARY HACKS：駭客秘傳技巧一百招</a></li>
</ul>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>GNU tool</tag>
        <tag>系統程式</tag>
      </tags>
  </entry>
  <entry>
    <title>《為什麼偉大不能被計畫》：人類如何成就偉大</title>
    <url>/2024/10/06/%E7%82%BA%E4%BB%80%E9%BA%BC%E5%81%89%E5%A4%A7%E4%B8%8D%E8%83%BD%E8%A2%AB%E8%A8%88%E7%95%AB/</url>
    <content><![CDATA[<h2 id="這本書在說什麼-適合的人"><a href="#這本書在說什麼-適合的人" class="headerlink" title="這本書在說什麼 &amp; 適合的人"></a>這本書在說什麼 &amp; 適合的人</h2><p>「<a href="https://www.books.com.tw/products/CN11869057">為什麼偉大不能被計劃</a>」是由兩位作者 Kenneth Stanley 和 Joel Lehman 所著。他們是機器學習和人工智慧研究學者，其團隊做了一個圖片孵化網站，意外發現要從亂數中產生出好的圖片並不能透過事先的計劃，而是只能透過不斷嘗試，發掘夠新奇有趣的圖片，然後以此為踏腳石繼續往下探索。這樣的發現也可以套用到其他人類偉大的發現和發明之中。這些偉大的成就，大多都不是透過設定目標和安排計畫來達成，反而都是因為在興趣探索時意外發現。</p>
<p>在現代社會中，人生也都有既定的目標，讀書升學、找個好工作、結婚買房、賺到可以退休的錢。有時候也會不禁想到按照這樣目標走，好像缺乏了什麼，無法創造不一樣的可能性。若是對這樣的人生有所疑惑的話，卻又沒有個方向的話，這本書可以很好地釐清並啟發自己不同的想法。</p>
<h2 id="我畫線的地方"><a href="#我畫線的地方" class="headerlink" title="我畫線的地方"></a>我畫線的地方</h2><p>書中有些讓我特別有感觸的地方：</p>
<ul>
<li><p>越是遠大的目標，越是不可能透過計畫來達成。能夠透過努力和計畫達成的目標根本稱不上偉大，因為每個人都可以透過同樣的方式達成。</p>
<blockquote>
<p>若⽬標設置⾜夠適度，它就會起到積極作⽤；反之，⽬標越「⾼⼤上」，情況就越複雜…關鍵在於，通向「⾼⼤上」⽬標的踏腳⽯，往往⾮常奇怪。也就是說，若你只是悶頭盯著⾃⼰的⽬標，那它們可能就是你根本意想不到的東西。</p>
</blockquote>
</li>
<li><p>新奇比起固定方向的目標更為可靠，因為沒有人踩過，更有可能有別人所沒注意到的發現，雖然我們並不知道是什麼。</p>
<blockquote>
<p>設定⽬標意味著遵循⼀條未知的路徑，朝著遙遠的⽬的地前⾏，⽽新奇性只要求我們遠離已經到過的地⽅。離開⼀個已經到過的地⽅，不僅更簡單輕鬆，還蘊含了更豐富的信息…相信新奇性是推動進步的⼀台有意義的引擎。</p>
</blockquote>
</li>
<li><p>我們的教育讓大家少了目標就沒有方向了，這時或許順應興趣、本心直覺去走，會是一個更靠譜的方式。</p>
<blockquote>
<p>如果你想知道如何擺脫對⽬標的盲⽬信奉，只需要隨⼼⾏事、遵循個⼈興趣的指引即可。不是所有的事情都需要以嚴謹的⽬標為指導。如果你對某件事有強烈的直覺，不妨順應本⼼。如果你沒有明確的⽬標，那也沒必要患得患失，因為不論你最終⾛到哪⾥，結果都不會太壞。</p>
</blockquote>
</li>
<li><p>一直以來我們都有所誤會，物競天擇的重點不在於競爭，而是避開競爭。避開競爭才能夠有更大的生存空間。</p>
<blockquote>
<p>⾃然進化並不是通過競爭來獲得⽣物多樣性，⽽是通過避免競爭。特別是某⼀⽣物如果能以⼀種新⽅式謀得⽣存，那便是成功找到了⾃⼰的專屬⽣態位。因為它會成為第⼀個以這種新⽅式⽣存的⽣物，所以作為此道開⼭者，競爭不會太激烈，繁衍也會更容易。</p>
</blockquote>
</li>
<li><p>過於專注在支微末節的競爭沒有太大意義，重點是這個是不是能夠帶來全新領域的踏腳石。想想自己是不是也常在不重要的地方跟別人競爭那細微的差異呢？</p>
<blockquote>
<p>通過細枝末節的調整，擠出最後⼀絲性能提升空間的做法，並不會帶來令⼈振奮的洞見…所有被歷史記住的算法，必然是為未來的開拓者奠定基礎的算法。它們將推動新算法的誕⽣，甚⾄幫助我們開闢全新的領域。到那時，誰還會在乎這些新算法在剛開始出現時，與「⽼靠譜」算法⽐較時的表現如何呢？</p>
</blockquote>
</li>
</ul>
<h2 id="個人想法"><a href="#個人想法" class="headerlink" title="個人想法"></a>個人想法</h2><p>從小我就很相信目標論。相信任何事物都可以透過設定目標並且執行詳實的計畫來完成。越是想達成偉大的成就就更應該設定遠大的目標、加倍的努力、以及嚴謹的紀律。然而這本書卻打破了想像，提供了完全不一樣的視角。下面三點是我從中獲得的最大收穫。</p>
<h3 id="偉大目標無法被設定"><a href="#偉大目標無法被設定" class="headerlink" title="偉大目標無法被設定"></a>偉大目標無法被設定</h3><p>作者的圖片孵化器網站讓人們能夠協作從最基本的圖形，過程不斷產生些微隨機變異，最終產生出各種有趣的圖片。然而，人們卻無法透過事先設定想要產生某種圖案來達成，只能在產生圖片的過程中挑選比較新奇的圖片並且持續嘗試。舉例來說，就像是下圖，我們沒辦法透過事先設定好要創作汽車來產生期待的結果，反而意外是從外星人的圖片演化而來。當初的創作者從來也不會想過外星人的眼睛可以轉換成汽車的輪子。</p>
<p><img src="/images/%E5%A4%96%E6%98%9F%E4%BA%BA%E5%88%B0%E8%BB%8A%E5%AD%90.png" alt="外星人到車子"><br>圖片取自 <a href="https://www.youtube.com/watch?v=dKazBM3b74I">Kenneth Stanley 的演講</a></p>
<p>這樣的現象其實在其他研究中也有同樣發現，就像是走迷宮，如果只是設定要往最接近出口的方向前進，很可能會卡在死胡同出不來。然而如果我們不要設定目標，讓探索更隨意，單純去嘗試過去沒試過的路線，反而更有機會走出迷宮。讓機器人學習走路的過程中，設定目標要它不要跌倒反而學不會走路，因為飛踢是往前邁步的開端。這些目標的設定反而成了目標的阻礙。</p>
<p>在人類偉大的發現發明中，因為繞路反而達成目標的情況並不罕見。例如，當初發明真空管並不知道可以用來製作電腦；而人類想要飛行不是像鳥一樣使用翅膀，而是發明內燃機，有趣的是內燃機最一開始也不是為了飛機而做。沒有這些看似不相關的發明，或者說踏腳石，後續更偉大的成就就不可能達成。<strong>越是困難、高大上的目標，越是無法被詳實計畫。因為從所在位置到目標之間，並不是筆直一條線</strong>。</p>
<h3 id="新奇搜索：放棄目標才有可能成就偉大"><a href="#新奇搜索：放棄目標才有可能成就偉大" class="headerlink" title="新奇搜索：放棄目標才有可能成就偉大"></a>新奇搜索：放棄目標才有可能成就偉大</h3><p>既然設定目標不管用，難道就沒有什麼其他比較好的方法了嗎？確實是有其他的方法，也就是所謂的新奇搜索法。主動去尋找新奇有趣的事物，因為這些事物看似雖然沒有關聯，但是卻是有可能成為未知目標所需要的踏板。</p>
<p>這裡作者用的比方我很喜歡：各種偉大的成就就像是散落在一個很大的空間之中，要前往某個偉大的目的地，這之間我們需要有很多踏腳石。然而不能期望前進的方向上所有踏腳石都清晰可見，有時離下一個踏腳石距離太遠根本勾不到。不過也許換個方向走，尋找其他看似不相關的踏腳石，卻反而有可能抵達該目的地。目標就像是指向偉大成就的羅盤一樣，方向明確但並不一定有用。</p>
<p>從上面的比喻我們可以知道，要在這個巨大的搜索空間中尋找有價值的事物，比起一味朝著某個方向前進，不斷去搜尋可以成為踏腳石的地方更為重要。最適合在這個空間中搜尋這些踏腳石的方法，就是所謂的新奇搜索法。我們越是去尋找有趣，從未見過的事物，它們可以創造的可能性越多，通往下個踏腳石，甚至是偉大的成就的機會也越大。<strong>我們放棄了偉大的目標，追隨自己的好奇心走，反而可能會抵達另一個不在計畫中的偉大</strong>。</p>
<h3 id="避開競爭，走出屬於自己的人生道路"><a href="#避開競爭，走出屬於自己的人生道路" class="headerlink" title="避開競爭，走出屬於自己的人生道路"></a>避開競爭，走出屬於自己的人生道路</h3><p>書中我最喜歡的一段是把生物的演化論拿來類比新奇搜索法。生物之所以會存在就是不斷的生存和繁衍，過去課本所學到的物競天擇會進行篩選，留下可以有競爭力、有能力存活的物種，讓生命持續「進化」。然而，作者反對這樣的思維方式，他認為生物演化就像是把牛奶往外潑，牛奶會持續向外擴散，直到遇到障礙物為止。生物也一樣，會不斷去尋找不同的可能性，盡量避免競爭。比起與同物種競爭，最終產生出一個超級生物，更好的方式是尋找新的生活空間、到新的生存環境，相對來說這個更容易達成。這也是為什麼我們會看到世界上有那麼多生物種類，不同環境都有自己的生態圈的原因。</p>
<p>用企業的角度來看，這也是一樣的。在上個世紀各種石油巨無霸、汽車製造巨頭主導著市場，但我們並沒有看到有什麼新的相關領域企業出現並與其競爭。反而是在未知領域，半導體、軟體、網路等方向有新的巨頭出現，對比這些舊企業對世界有更大的影響力。因為避開了在同個市場的直接競爭，所以有新的生存空間能夠發展。這個也是人們常說的紅海藍海的概念，在沒有過多競爭的藍海，才能有更大的可能性。</p>
<p>回歸到個人，老生常談中的做自己就好以及跟著興趣走其實也是有道理的。<strong>在人多的地方就會充滿各種競爭，跟著直覺覺得有意思的方向走，依據自己的個人特點避開競爭，反而更有可能得到世俗意義上的成功</strong>。書中有個比喻，假設目標是要成為百萬富翁，我就會避開沒有支薪的實習，就算非常喜愛這個工作。然而現實往往是因為追尋了內心的激情和興趣，而不是向「錢」看，某天才意識到自己離百萬富翁只差一個踏腳石而已。</p>
<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p><strong>小目標可以被計畫，但是偉大則不能</strong>。本書打破了目標的迷思，大從政府企業，小到個人，對於偉大的成就需要有新的認知。在<a href="https://www.books.com.tw/products/0010819494">黑馬思維</a>那本書有提到很多成功人士都是不會執著於特定目標，願意嘗試各種新事物，一旦感到苗頭正確，就做出特定的改變。或許這也是有異曲同工之妙。先追尋自我找到有趣的事情，一旦發展到後來對他人有價值，就能發揮出影響力，這時反而各種一般人所盼望的成就也會隨之而來。對於偉大，越是汲汲營營，越是不可得，就像是「眾裡尋他千百度，驀然回首，那人卻在燈火闌珊處」一樣。</p>
<h2 id="反思與行動"><a href="#反思與行動" class="headerlink" title="反思與行動"></a>反思與行動</h2><p>雖然這本書是比較概念性的內容，還是盡可能轉換成可執行的行動，應用在自己人生中。</p>
<ol>
<li>自己會走到當下這個位置，是經過無數選擇和探索，跟其他人完全不同。因此對於未來要走的道路，也不需要跟別人比較與競爭。</li>
<li>在當下所處的位置去思考有哪些可能性，保持好奇心，以實際行動去探索新奇事物。</li>
<li>一旦發現吸引自己的事情，就安心地跟著直覺走，勇於改變方向並前進。</li>
</ol>
]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>為什麼動機比努力重要</title>
    <url>/2025/03/30/%E7%82%BA%E4%BB%80%E9%BA%BC%E5%8B%95%E6%A9%9F%E6%AF%94%E5%8A%AA%E5%8A%9B%E9%87%8D%E8%A6%81/</url>
    <content><![CDATA[<p>「能請你描述網路封包從網卡接收到使用者程式的流程嗎？」</p>
<p>這是某次面試我被問到的問題。原本以為我對網路架構已經足夠熟悉，然而卻發現自己沒辦法很流暢地回答這個看似基本的問題。不僅面試官不滿意，我也不滿意自己的答案。</p>
<p>這是因為工作不認真，沒有學好技術嗎？不，以客觀標準來說，我絕對屬於認真的那群。那難道是經驗不夠嗎？也不是，自從畢業以來，我從事的工作都和網路相關。這並不能當作藉口。</p>
<p>那麼問題出在哪裡呢？又或者我們可以進一步問，明明花同樣的時間，為何人與人之間的能力差距會這麼大呢？這個疑惑不斷在心中徘徊，困擾了很久，最終找到了真正的答案：</p>
<p>那就是「動機」。</p>
<h2 id="你的努力搞錯了方向"><a href="#你的努力搞錯了方向" class="headerlink" title="你的努力搞錯了方向"></a>你的努力搞錯了方向</h2><p>或許你對這樣的答案不以為然：動機只是做一件事情的理由罷了，哪會影響做這件事的結果。</p>
<p>我原本也是這樣想，但是回想自己過去學習與工作的經歷，那些表現好的領域，無不是因為我對那些知識感到好奇，想要徹底搞懂；而表現不突出的，往往都不是為了學習本身而行動，而是為了得到好成績或是完成某個任務，學會那些領域知識只是副產品罷了。</p>
<p>明明都花一樣時間、一樣努力，只是動機不同，可是最後成果卻天差地別。</p>
<p>為什麼會這樣呢？讓我們用更加實際的情境來說明：</p>
<p>想像有兩個能力伯仲之間的員工，一個想要得到老闆賞識，認為完成越多任務越好，而另一個人則是對事情充滿好奇心，接收到的任務會想盡辦法了解各種細節。</p>
<p>前者只要任務完成了就會馬上著手下一個任務，所以完成的數量遠遠高於後者。然而有好奇心的員工卻會在完成任務之餘嘗試理解其中的各種知識，而這些知識又可以用在未來其他任務上。拉長時間來看，他才是真正累積了這個領域的專業能力，能解決未來更加困難的問題。</p>
<p>兩個人都付出了同等的努力，但是由於各自的動機不同，最終所能達成的成就也不同。</p>
<p>如果努力是汽車的油門，那麼動機就是方向盤。一旦動機有稍微的偏差，差之毫釐失之千里，我們將會駛向錯誤的目的地。</p>
<h2 id="經驗並不重要"><a href="#經驗並不重要" class="headerlink" title="經驗並不重要"></a>經驗並不重要</h2><p>但是不管動機如何，如果一個事情做了十年，總會變成這個領域的佼佼者吧？也許你會想這樣反駁。</p>
<p>我有個朋友當了產品經理十多年，然而其他人私底下評價他都認為能力差不多就是剛畢業的學生。對於他所管理的產品，從來不會想進一步了解，完全是別人怎麼說就怎麼做，一個指令一個動作。對他而言，能完成主管交辦的工作就好，並沒有任何動機學習產品的技術原理、市場趨勢和發展前景。</p>
<p>就如同我們天天開車不會哪天變成 F1 賽車手一樣，我們也不會因為用同樣的技能做重複性的工作，就能獲得突破性成果。所謂的經驗累積並非單純的時間累積。究竟我們是用一年的工作能力重複做十年，還是十年內有意識不斷學習新的知識呢？</p>
<p>這也正是「刻意練習」這本書所強調的觀念：一個技能要有所成長，需要持續突破舒適圈，克服自己的弱點。單純重複同個行為一萬小時並不會讓自己成為專家。</p>
<p>時間從來都不是重點，重要的是在這段時間內我們的內在動機為何，以及採取了什麼行動。只有不斷經歷各式各樣的事物，時間的積累才會有價值。</p>
<h2 id="好奇心才是最佳的動機"><a href="#好奇心才是最佳的動機" class="headerlink" title="好奇心才是最佳的動機"></a>好奇心才是最佳的動機</h2><p>知名物理學家費曼曾說：「對任何事物都充滿了好奇，是我學習和理解世界的方式」。發明蘋果手機的賈伯斯也說過：「Stay Hungry, Stay Foolish」。</p>
<p>過去我都很無法理解為什麼這些有所成就的人總是強調好奇心的重要性，明明看起來跟他們所獲得的成功沒有太大關聯。我的想像中他們應該要更強調天賦、努力等等更直接的因素才對。</p>
<p>然而，好奇心正是他們行動背後的真正動機，這些人不追求成功本身，而是想要瞭解世界運作背後的本質和原理，只是在探索的過程中不經意得到成功這個副產品罷了。如果一開始就以功成名就為目標，反而會離它越來越遠。</p>
<p>越單純的心念，越能夠接觸事物的本質，而越能掌握本質的人，越能在這世界中發揮影響力。一旦混入了對名利的追求，就無法全心投入其中。</p>
<p>對世界的好奇，是人類與生俱來的天賦，每個孩子一誕生就有的才能，只是我們在長大的過程中被蒙蔽了而已。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>回到最一開始的問題，為什麼我沒辦法回答看似基本的問題。原因也很簡單，過去的工作中我很認真，或者說太過認真，全心全力解決被交辦的任務。我所累積的並不是技術能力，而是怎麼把工作做好的能力。</p>
<p>當有取巧的做法可以繞過問題時，我不會回過頭思考問題根因在哪裡。當遇到一個樹木的問題時，我只看見樹木，而不是從整個樹林的角度來思考。錯誤的動機侷限了我行動的方向。</p>
<p>我很努力，但只是在努力成為好員工，而不是努力理解技術原理、滿足好奇心。</p>
<p>在「<a href="https://evshary.com/2024/10/06/%E7%82%BA%E4%BB%80%E9%BA%BC%E5%81%89%E5%A4%A7%E4%B8%8D%E8%83%BD%E8%A2%AB%E8%A8%88%E7%95%AB/">為什麼偉大不能被計畫</a>」這本書中強調過去人類的偉大成就都不是靠著設定目標而達成，而是一小群人追尋新奇事物，意外發現這可以有獨特的應用，進而創造了科技的突破。就像是真空管，一開始發明的人也沒想過用在電腦上，但最終卻引領了電腦革命。</p>
<p>以往，我們過度強調了努力的重要性，設定好目標，遵循著社會定義的道路前進。然而，我們更應該跟隨內心最純粹的好奇心、單純滿足自己的求知慾，而不是被外在成就這個副產品所蒙蔽。</p>
<p><strong>人與人最大的差異不在於努力、不在於經驗，而是動機。</strong></p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>為什麼社會有分歧</title>
    <url>/2024/10/27/%E7%82%BA%E4%BB%80%E9%BA%BC%E7%A4%BE%E6%9C%83%E6%9C%89%E5%88%86%E6%AD%A7/</url>
    <content><![CDATA[<p>在現代社會中，人們常常都在說社會分裂越來越嚴重。由於網路的發展，各種意見容易匯聚，然後又因為社群媒體的演算法不斷擴大同溫層，讓某些意見持續放大，最終產生出衝突。常見的例子像是國家定位、同性婚姻、核電使用，而在國外更有持槍議題、移民、人種平權等等。</p>
<p>在社會中，某些議題上有立場衝突必定是會存在的。社會是由人組成的，人人也都有不同意見。當大家對某個方向都贊同，那社會肯定是會朝這個方向前進，這時就沒有太多討論價值。會吸引人們目光的總是那些有不同意見的議題，透過激烈討論，直到達成某種程度的共識後才會逐漸潛伏，被其他更引人注目的議題所取代。這就如同大海上有很多波浪，當最大的波浪消失了，大家的注意力就會集中在次高的波浪上一樣。</p>
<p>隨著時代的推進，人們的價值觀也不斷更新，過去認為正確的概念在現代可能也會被推翻。其中最著名的就是種族不平等。以美國為例，奴隸制度直到內戰才被廢除，但是一直要到二戰後才真正落實廢除種族隔離。而現在很多社會運動者更加追求在各個領域，各種人種都要能一定程度的參與，例如大學入學或是公司聘用。</p>
<p>然而這類社會進步價值的推進，也一定會帶來反作用力。追求進步價值的人 (SJW)，常常會被其他相對比較保守的人嘲笑為「覺青」、「左膠」。這個非常正常，任何對社會現狀的改動都會有阻力。一開始可能因為某些事件爆發(如 Black Lives Matter、Me too)，改革的動力非常強大，不斷在某個議題上面往前推進，社會也願意支持。但隨著時間推移，改革者的要求越來越多，社會大眾也會逐漸對議題失去興趣，其中的保守派也會開始抗拒，最終反而形成另一股強烈的反對力量把改革派反推回去。這就像是鐘擺一樣，在議題中的兩個立場不斷擺盪，直到形成社會可以接受的新共識。</p>
<p>這樣的現象其實我們可以在很多例子上看見。以前陣子台灣的同婚議題來看，同志對同性婚姻的訴求得到年輕人的認可，產生出改革力量，推動公投。然而社會雖然對同性戀愛的接受度越來越大，卻還是無法忍受改變傳統上對婚姻的定義，最終在公投上否決了這項改變。不過從結果上來說，儘管同性婚姻沒成功，但是社會也接受了新的同性伴侶相關法律。就像是改革派往前兩步，保守派往後推一步，最終還是前進一步，社會達成了新的共識。</p>
<p>同樣的狀況也發生在全球化上面，過去幾十年由於全球化，人們可以享受發展中國家製造的便宜商品，但卻也造成了先進國家的製造業外流。美國的藍領階層在 2016 年的大選反撲中選出了川普，透過拉高關稅而造成逆全球化。現在再加上地緣政治和疫情的原因，逆全球化的趨勢短時間內應該是不會緩解，但可預期的是也不會回到大家完全閉關鎖國的格局。整體態勢應該最終還是在一個新的共識點達成平衡，直到下一股外在力量再次引發改變。</p>
<p>回到我們個人，我們所參與的團體，例如公司、社團等等，其實也是一種小社會。當遇到外在壓力下，通常也會產生出改革和保守兩股力量。舉例來說，公司營收不好需要進行轉型、社團老化需要吸引新血加入。改革派會認為不變動就是等死，保守派則是擔心太大的變動會失去了團體本身的價值，導致團體的崩解。兩種力量在內部不斷拉扯，直到找出新的平衡出來。</p>
<p>雖然我們這裡使用改革和保守兩種詞，但這並沒有任何的褒義和貶義。改革並不代表有完美結局，看看多少國家在革命後陷入貧窮崩壞。保守而轉型太慢也常常是公司被新的挑戰者所取代的原因。改革沒有保守的制約往往會衝太快，讓系統不穩定而崩潰，反過來說，保守也需要有改革派的驅動來應對新的挑戰。有智慧的領導人必須要在這兩種勢力中小心翼翼維持平衡，走出緩慢並有力的改變力量。</p>
<p>我們人類總是喜歡有共識沒分歧，但是分歧在一個正常的社會中是一定存在的，因為人與人彼此間就是不一樣。分歧從來不是壞事，這是社會多樣性的一種展現。當我們可以用比較自然態度看待他人意見不同時，社會也越不會二極化、彼此相互對立。因為我們知道不同立場都有存在的必要，唯一需要的是一套穩定合理產生出彼此都能接受共識的方法。這個方法可能是公投、可能是選舉，只要人們可以接受即可。當分歧可以用這套系統來彌合，社會就不會因此而產生分裂，進而朝有共識的方向往前邁進。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>為何我選擇定期定額投入市值型 ETF</title>
    <url>/2025/02/09/%E7%82%BA%E4%BD%95%E6%88%91%E9%81%B8%E6%93%87%E5%AE%9A%E6%9C%9F%E5%AE%9A%E9%A1%8D%E6%8A%95%E5%85%A5%E5%B8%82%E5%80%BC%E5%9E%8B%20ETF/</url>
    <content><![CDATA[<p>從小因為家庭的教育，我對股票市場一直有種莫名的恐懼，聽過好多例子因為投資股票而傾家蕩產。直到出了社會接觸了更多資訊後才發現，股票其實也有很穩健的投資方式。目前，大多數推薦的作法是定期定額投入市值型的 ETF。</p>
<p>ETF 的定義是依據某種指數或是策略買進一系列的股票組合。這個組合有可能是根據發放股息的高低、公司的產業類別、又或者是符合 ESG 之類的公司治理方式。而這邊所說的市值型 ETF 則是針對股票市場的價值高低所組合而成。舉例來說，元大台灣 50 (0050) 就是追蹤台灣前 50 大公司市值比例而形成的指數。這個指數會依據各個公司的股票價值漲跌而定期調整，汰弱留強，確保其追蹤的永遠都是最大的 50 家企業。</p>
<p>2024&#x2F;12&#x2F;31 元大台灣 50 的前 10 大標的</p>
<table>
<thead>
<tr>
<th>股票名稱</th>
<th>比例</th>
<th>股票名稱</th>
<th>比例</th>
</tr>
</thead>
<tbody><tr>
<td>台積電</td>
<td>57.81%</td>
<td>富邦金</td>
<td>1.64%</td>
</tr>
<tr>
<td>鴻海</td>
<td>4.82%</td>
<td>中信金</td>
<td>1.43%</td>
</tr>
<tr>
<td>聯發科</td>
<td>4.70%</td>
<td>國泰金</td>
<td>1.40%</td>
</tr>
<tr>
<td>台達電</td>
<td>2.08%</td>
<td>日月光投控</td>
<td>1.17%</td>
</tr>
<tr>
<td>廣達</td>
<td>1.75%</td>
<td>聯電</td>
<td>1.13%</td>
</tr>
</tbody></table>
<h2 id="為什麼市值型-ETF-有用"><a href="#為什麼市值型-ETF-有用" class="headerlink" title="為什麼市值型 ETF 有用"></a>為什麼市值型 ETF 有用</h2><p>ETF 的好處是不會單押某家公司，而是依據一定的比例分散投資到多家企業上。這樣的好處是一旦某家公司因為內部或外在的因素而表現不好，我們持有的股票不會有很大的波動，一定程度上分散了風險。</p>
<p>那為何市值型會比其他方法還要好呢？<strong>因為很多 ETF 的挑選或多或少都加入了人為的價值判斷，而現實常常不會跟人類的判斷一致</strong>。更別說其他方法的 ETF 管理費還高過被動的市值型了。</p>
<p>看看目前常常出現在報章雜誌上的公司，它們成立的時間可能不超過 30 年，如谷歌、亞馬遜。而過去我們常聽到的巨無霸公司，不是消失就是沒落。一項新技術的發明、一個管理層的錯誤決策都可能讓公司走下坡。在快速的科技進步以及劇烈的商業競爭下，沒人能知道現在的巨星會不會五年後成為明日黃花。看看下面 2000 年和 2024 年前十大公司的對比：</p>
<table>
<thead>
<tr>
<th>排名</th>
<th>2000 年</th>
<th>2024 年</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>微軟（Microsoft）</td>
<td>蘋果（Apple）</td>
</tr>
<tr>
<td>2</td>
<td>通用電氣（General Electric）</td>
<td>英偉達（NVIDIA）</td>
</tr>
<tr>
<td>3</td>
<td>思科（Cisco Systems）</td>
<td>微軟（Microsoft）</td>
</tr>
<tr>
<td>4</td>
<td>埃克森美孚（ExxonMobil）</td>
<td>Alphabet（Google 母公司）</td>
</tr>
<tr>
<td>5</td>
<td>英特爾（Intel）</td>
<td>亞馬遜（Amazon）</td>
</tr>
<tr>
<td>6</td>
<td>諾基亞（Nokia）</td>
<td>沙特阿美（Saudi Aramco）</td>
</tr>
<tr>
<td>7</td>
<td>甲骨文（Oracle）</td>
<td>Meta（Facebook 母公司）</td>
</tr>
<tr>
<td>8</td>
<td>IBM</td>
<td>特斯拉（Tesla）</td>
</tr>
<tr>
<td>9</td>
<td>花旗集團（Citigroup）</td>
<td>博通（Broadcom）</td>
</tr>
<tr>
<td>10</td>
<td>沃達豐（Vodafone）</td>
<td>波克夏·哈薩威（Berkshire Hathaway）</td>
</tr>
</tbody></table>
<p>回到 2000 年，那些大企業無不在稱霸一方，誰能知道自己會這麼快被後起之秀所追過呢？優秀的 CEO 無法預測、專業的投資者無法預測、更別說是我們了。既然無法預測未來，最好的策略是讓現實(市值)告訴我們誰才是好公司，並且不斷調整。</p>
<h2 id="為什麼建議定期定額"><a href="#為什麼建議定期定額" class="headerlink" title="為什麼建議定期定額"></a>為什麼建議定期定額</h2><p>其實理性來說，一次性把資產投入股票市場更有可能獲得高報酬。這是經過經濟學家驗證過的。畢竟當某檔股票未來會漲到 100 元的時候，你也不會在意是在 50 買還是 55 元買了。不過我個人還是更喜歡用定期定額的方式來投資。</p>
<p>對於普通人來說，一旦自己買入的股票賠錢，心裡通常會非常難熬，特別是已經把一大筆錢放進去的情況。定期定額可以有效幫助我們緩解這個心情。如果我們只是投入資產的一小部分，能賺錢當然心情很好，但是賠錢的時候也還能安慰自己，我手上還有現金，可以趁現在逢低買入。<strong>投資股票最重要的是要能長期持有</strong>。雖然定期定額會少賺一點，卻能讓我們更堅定的持續握住股票。</p>
<p>除此之外，一般買股票的時候總是會擔心自己是不是買在高點，不知道到底下單要用什麼價格比較好。若是我們有一個固定的策略，那就不用還要費心思考什麼時間要用什麼價格來買進。長時間堅持一個好策略，比起不斷追逐最棒的策略，更加容易去執行。</p>
<h2 id="理財只是生活的一部分"><a href="#理財只是生活的一部分" class="headerlink" title="理財只是生活的一部分"></a>理財只是生活的一部分</h2><p>我對賺錢有興趣，但老實說我對關注盤市、操作股票卻是興致缺缺。在各國央行大放水的時代，現金貶值的速度比我們想像中快得多。我只想要資產不要被通膨稀釋就好。</p>
<p>巴菲特曾有個著名的賭注：單純追蹤美國股市的基金，可以輕易打敗專業基金經理人組成團隊；而在十年之後，巴菲特選擇的被動指數基金報酬率遠遠高於對手選的五檔對沖基金。根據研究報告指出，在十年內可以打敗市場大盤的基金大約也就 10% 而已，隨著時間拉長，我相信這個比率會進一步降低。</p>
<p>這些著名基金操盤人無不是天之驕子，名校畢業，經過層層篩選後進入這一行。連他們這種全天以分析公司和股市維生的人都無法長期打敗大盤，那我這個業餘看看股市的人更是不可能。我相信一定有人很厲害可以如巴菲特一樣長期贏過被動指數基金，但我更加相信這個人不會是我。</p>
<p><strong>既然已經有一種長期來說會贏過 90% 專業基金經理人的方法，而且還不需要花多餘的心思研究操盤，那何必這麼辛苦想成為那 10% 呢</strong>？現在的我只有固定時間看看是否足以定期定額扣款，很少關注當天的股市漲跌了。我們可以把這些時間留下來做更加值得做的事情，像是閱讀、旅行、陪家人等等。要記得不只是投入股市的本金，時間也是成本的其中之一。</p>
<h2 id="可能的風險"><a href="#可能的風險" class="headerlink" title="可能的風險"></a>可能的風險</h2><p>投資市值型 ETF 並非毫無風險，事實上<a href="https://www.books.com.tw/products/E050210444">兆億大戰</a>這本書在推薦 ETF 之餘也點出對現代金融可能造成的危害。不過大多數的情況下，大盤不好，其他基金可能表現會更糟糕。因此我還是認為這是比較穩健的作法。</p>
<p>然而確實並非每個國家的大盤都會是長期看漲。一個國家的股市反應的是這個國家的經濟和競爭力。以日本失落的 30 年來說，長期股市大盤就都不斷盤整沒有向上。台灣若是因為地緣政治的因素發生戰爭，我想可能也會發生同樣的狀況，因此我比較高的比例是放在美國市場。不管你喜歡美國與否，美國擁有最強的武力和全世界最聰明的人才，除了地緣位置極佳沒有外敵外，還有美元霸權的支撐。我相信就算美國自身出了什麼問題，她也會想盡一切辦法轉嫁到外部去，就像是 2008 年金融危機一樣。若要說長期看好某個市場，那肯定還是要選擇美國。</p>
<p>另外，我們一直不斷強調長期，代表著不能因為短期外在因素而不得不認賠殺出。隨時都應該要保留一定的生活費，就算因為短時間內沒有收入也不至於需要賣股票來維生。如果預知會有大筆開銷，我們也可以提前選擇在市況較好的時候轉為現金。總之，我比較喜歡採取保守的作法，在確保生活無虞的情況下，讓金錢盡可能留在股市複利成長。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>人總是會高估自己忍受低谷的能力。我也曾認為自己從事科技業，應該能看得準行業趨勢。在買進了 Netflix、META 和 Palantir 後，2022 年剛好慘遇股災，每天看著股票價值不斷向下跌，砍半再砍半。心中不斷質疑我會不會其實看錯了，這些科技公司確實要不行了。最終忍受不了，全部出清，轉為 VTI 和 QQQ 這類的 ETF。然而就像大多數人所經歷的一樣，這些股票全部都在 2023-2024 年大反彈，恢復前高。特別是 Palantir，在 2025 年初已經抵達 100 元，距離低點漲超過 10 倍。</p>
<p>其實我很感謝這樣的經驗。沒有經歷過股市大跌，就不會真的認識自己的能力極限。現在我只會把大部分的部位放在市值型 ETF。就算它們大跌，我也很清楚這只是一時的，遲早會回來，甚至更應該趁機加碼。因為我知道它們的背後原理，而且過去的歷史也提供了佐證。</p>
<p><strong>唯有明白事物的運作機制，才能堅信不移。而唯有堅信不疑，才能在低谷時持續堅持。</strong></p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>為何比特幣是加密貨幣中的定海神針</title>
    <url>/2025/04/13/%E7%82%BA%E4%BD%95%E6%AF%94%E7%89%B9%E5%B9%A3%E6%98%AF%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%B5%B7%E7%A5%9E%E9%87%9D/</url>
    <content><![CDATA[<p>從初次接觸加密貨幣領域以來，這個圈子不論是誰都倡導比特幣是風險最低的投資方式，這讓我感到非常不解。</p>
<p>在科技領域中，後進者取代先驅的例子屢見不鮮。往往是有用取代無用，效能好替換效能差，就如同當初智慧型手機取代傳統手機、Google 的搜尋引擎替換 Yahoo 的入口網站一樣。長江後浪推前浪是科技產品的宿命，同時也增進了人類社會的進步。</p>
<p>然而，同樣是科技最前沿的加密貨幣領域，情況卻又有所不同。作為加密貨幣的最早先驅比特幣，從 2008 年發明至今，鮮少有大型更新，至今依然缺乏智能合約或是 NFT 等等後進加密貨幣的必備功能。儘管如此，它卻擁有不可撼動的最高地位，市值穩定佔整個加密貨幣市場的 40% 以上。</p>
<center>比特幣市值佔比圖，資料來源：coingecko</center>

<p><img src="/images/%E6%AF%94%E7%89%B9%E5%B9%A3%E5%B8%82%E5%80%BC%E4%BD%94%E6%AF%94%E5%9C%96.png" alt="比特幣市值佔比圖"></p>
<p>這是為何呢？經過研究後，我總結了兩個原因：</p>
<h2 id="穩定"><a href="#穩定" class="headerlink" title="穩定"></a>穩定</h2><p>身為所有加密貨幣的祖先，比特幣可以說是整個行業的信仰支撐。認可其他數位資產的大多數人，普遍也認可比特幣。從發明至今，比特幣遭受無數的攻擊，卻依然屹立不搖，其存在證明了加密貨幣價值儲藏以及傳遞的可靠性。</p>
<p>在這個情況下，人們自然期望它越穩定越好。一旦出現重大問題，對整個行業來說就是地動山搖。這也解釋為什麼比特幣大多是漸進的調整，很少做出巨大的變化。為了維持這種可靠性，比特幣在多個方面做出取捨：</p>
<ul>
<li>為什麼要使用大量的電力來維持共識演算法呢？因為要維持穩定。</li>
<li>為什麼不要引入智能合約、NFT 等等功能呢？因為要維持穩定。</li>
<li>為什麼不更積極地改善交易的效率呢？因為要維持穩定。</li>
</ul>
<p>穩定高於一切。<strong>人們並不希望比特幣成為萬能的解決方案，而是希望當加密貨幣領域出現任何風險時，比特幣可以是永遠可靠的避風港。</strong></p>
<h2 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h2><p>跟其他加密貨幣不同，比特幣並沒有一個明確的領導者或是組織，甚至其發明者中本聰身份也一直是謎。基於這個原因，比特幣無法被任何個體或組織所控制，需要靠集體的共識來決定方向。換句話說，比特幣本身和其生態系統都呈現高度去中心化。</p>
<p><strong>去中心化雖然會導致運作效率不高，但也同樣帶來了重要的優點：信任</strong>。有中心化的組織就可能有腐敗、可能被政治控制、可能因為領導人的言行而造成不必要的波動。一旦其運作足夠去中心化，比特幣的發展就無法被單方面掌控，例如某個國家或公司，持有人也會更加放心。</p>
<p>以 2022 年爆發的俄烏戰爭為例，俄羅斯被美國為首的西方國家制裁，無法使用美元進行交易，因此俄羅斯就使用比特幣來處理部分交易，而這正是比特幣無法被單一國家勢力控制的最好證明。另一方面，烏克蘭開放了比特幣的捐款方式，而避難的群眾在法幣被凍結情況下，也可以輕易攜帶比特幣離境。在兩國勢如水火的對抗下，比特幣依然可以得到雙方的承認和使用。</p>
<h2 id="比特幣就是數位黃金"><a href="#比特幣就是數位黃金" class="headerlink" title="比特幣就是數位黃金"></a>比特幣就是數位黃金</h2><p>基於上述理由，雖然比特幣和當前加密貨幣主流技術應用關聯不大，人們依然認可其價值。就如同我們日常交易都是使用像是台幣、美元等法幣，但是黃金還是被視為很有價值的商品。其實，從黃金身上我們也會看到類似的兩種特性。</p>
<p>從穩定性來說，沒有任何一種金屬比黃金還穩定了：在地球上的數量稀少、不容易起化學反應、還很難偽造。因為這些特性，當發生天災人禍時，人們傾向持有黃金避難。在國民政府當初從中國大陸撤退到台灣的時候，也是攜帶大量的黃金，用來穩定混亂的時局。</p>
<p>從去中心化來說，黃金的價值是被普遍世界承認的，到任何國家都可以交易，甚至沒有一個國家有絕對掌控權。有趣的是，在人類歷史中被用來當成貨幣的物品各式各樣，有貝殼、駱駝、各種金屬，但是只有黃金是所有人都能接受的。就算兩個國家發生戰爭，彼此還是能用黃金做交易。</p>
<p>黃金雖然已較少用於日常生活中，但人類用黃金當貨幣的歷史記憶依然留存至今。同樣地，比特幣作為加密貨幣的先行者，人們依然相信其價值。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>台灣前央行總裁彭淮南早在 2013 年時就說過：「比特幣是一種貴金屬」。真不愧是專業經濟學者，這個類比可說是一針見血。</p>
<p>比特幣並不是普遍使用的貨幣，也不是功能強大的科技產品，人們從不期望它好用或是功能複雜。<strong>正是這種對特定功能的克制，才造就了比特幣本身的獨特優勢</strong>。</p>
]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>區塊鏈</tag>
      </tags>
  </entry>
  <entry>
    <title>理論與經驗：知識如何落地</title>
    <url>/2024/12/15/%E7%90%86%E8%AB%96%E8%88%87%E7%B6%93%E9%A9%97%EF%BC%9A%E7%9F%A5%E8%AD%98%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0/</url>
    <content><![CDATA[<p>傳聞中，德國皇帝威廉二世在第一次世界大戰兵敗退位二十年後，讀到了德文版的孫子兵法，感慨自己若是能早點讀到這本書，也不至於落到如此境地。聽到這個故事不禁讓我思考，如果我們能提前讀遍經典、知曉無數道理，是否真的能避免失敗，直達成功的彼岸呢？</p>
<p>然而，理論並非萬能。三國時期的就是個典型的例子。他飽讀兵書，深受諸葛亮的信任，在南征孟獲時還曾經提出「攻心為上」的方針。但是在街亭之戰中，卻因為過度拘泥於居高臨下的理論，不顧有豐富實戰經驗的副將王平勸阻，在山上佈陣，最終被張郃切斷水源所敗。他的失敗印證了劉備對其「言過其實」的評價，也給後人一種紙上談兵的印象。這樣看來，單純懂很多理論知識，似乎也沒辦法確保能在現實中取得好成果。</p>
<p>其實在怎麼好的道理理論都有其適用的情境範圍。以馬謖前面的例子來說，居高臨下可能在大多數的情境都是好的決策，因此兵書也會這樣記載。然而，這樣的軍事指導也是有自己的水源不能被敵人所切斷的前提。他的副將可能書沒有馬謖讀得多，但是因為有豐富的經驗，所以知道這樣做會有問題。這時候經驗的價值就遠遠超過理論的指引了。</p>
<p>然而我們也不能說理論就沒有任何價值了，它是一盞明燈，可以幫助我們明確前進方向，最大程度避開前人所踩的坑。只是路上遇到的問題並不能全靠理論來解決，因為理論本來就不可能把所有可能發生的問題都窮舉出來，唯有自己親身經歷過才會真正了解。用比較科學的方式來說，<strong>理論所能蘊含的資訊量也不過就文字而已，經驗則是來自我們的五官，提供給我們的訊息遠遠多過於理論</strong>。</p>
<p>這個也是為什麼當人上了年紀，看事情的境界就不再相同。年輕時常常被告誡身體健康很重要，我們也都清楚並同意這件事，沒有人會說健康不重要，但是不到自己有了年紀、健康實際出了狀況，就不會下定決心要好好運動、保養身體。因此回到德國皇帝的故事，他會覺得感慨，並不只是孫子兵法是好兵書的關係，更多可能是因為它觸動了德國皇帝失敗的經驗，理論和經驗相互印證。假設同樣的兵書給年輕的威廉二世看，我相信他的感觸肯定不會那麼多，而且很大的機率仍然會重蹈覆轍。</p>
<p>我想，聽很多名言、讀很多道理可能用途並沒有我們想像中的大，甚至可能有害。很多時候我們會誤以為自己已經理解某個理論，因為聽過好多次。然而聽過和實際上真正理解根本是兩回事，這也就是心理學中的「知識錯覺」。我們都知道拉鍊和腳踏車，因此自以為很清楚其運作原理，但當有人要我們嘗試說明時卻發現根本不懂細節。學會很多理論也同樣的意思，認為自己很了解了，反而忽視了從來沒有真正搞懂並落實在生活中。</p>
<p>任何同樣的文字會受限於每個人的生活經驗、背景知識、人生閱歷而有不一樣的差別。就像是同樣是 <code>E=mc^2</code> 這個公式，對愛因斯坦、對物理系學生、又或者是對普通人來說，意義完全不相同。為了解決這個問題，很多書籍都是為了闡述某個用一句話就說完的理論，而撰寫了一大堆論述和範例。儘管如此，我們也無法說看完一本書後就得到作者對這個議題的完整知識。</p>
<p>或許最好的方式是正視我們不可能完全理解名言和理論真正意思的現實。既然如此，應該要保持著開放謙虛的心態看待知識和理論，明白自己在不同年紀、更多經歷後可能會有不同的體會。</p>
<p>對我而言，理論只有在真正改變實際行為才有用處。人類的天性是重視經驗、感性的，唯有實際嘗試才能真正理解。我們不可能只聽老師指導、觀看教學影片就能學會游泳，最終還是得下水嘗試體驗才行，因為身體每個動作細節很多是無法透過言語傳達的。<strong>我們透過理論得到一個大略的方向，然後親身體會後就能回過頭來修正對理論的理解</strong>。透過這樣方式才能基於前人的智慧幫助我們更加理解這個世界並創造出理想的成果。</p>
<p>理論是燈塔，經驗是船，燈塔能指引方向，但船仍需要經歷風浪才能到達目的。我們需要的是不斷嘗試反思的學習過程，而不是沉溺於理論的海市蜃樓之中。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>獲取資訊來源的方法</title>
    <url>/2024/09/22/%E7%8D%B2%E5%8F%96%E8%B3%87%E8%A8%8A%E4%BE%86%E6%BA%90%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在現代社會大家獲得資訊的管道已經不侷限於新聞媒體或報章雜誌了，像是 YouTube、Podcast、短影音或部落格等等都是常見的方式。最讓人苦惱的不是有沒有資訊，而是優質的資訊源。太多的訊息反而讓自己的注意力被分散，而無法專注在真正帶來價值的事物上。不過話又說回來，適當地更新資訊也是保持我們對世界變化維持敏銳關注的必要一環，維持一個巧妙的平衡很重要。</p>
<p>這裡分享一些平常我得知新知的管道：</p>
<h2 id="Podcast"><a href="#Podcast" class="headerlink" title="Podcast"></a>Podcast</h2><p>我最常使用的資訊來源獲取管道，主要是可以邊聽邊做其他事情</p>
<ul>
<li>曼報：兩位主持人會針對某一個產業或公司進行深入介紹，可以讓人有個概括的認知</li>
<li>財報狗：裡面有個達人聊產業單元我很喜歡，來賓會分享該產業的一些概況，以及自己是怎麼經營事業的</li>
<li>解鎖地球：受訪者會講自己在世界各地經歷的不一樣風土民情</li>
<li>斐姨所思：鎖定台灣熱門議題的節目，有時候會邀請到不錯的來賓，主要看邀請到誰來決定要不要聽</li>
<li>忽左忽右：社會人文的優質節目，從歷史、文學、能源到政治無所不包</li>
<li>硅谷 101：在科技產業工作的話必聽，主要談談各個新興產業發展狀況，自動駕駛、AI、星艦、核能等等。由於受訪者常常是在矽谷工作的中國人，很常比較中國和美國兩國的產業發展狀況</li>
<li>聲東擊西：也是社會人文類的節目，但是內容有時比較從心理哲學層面出發，而在美國大選時還有一系列介紹候選人的內容</li>
<li>商業就是這樣：主要對一些時事延伸出有趣的商業主題，像是法國奧運時就會有奧委會怎麼挑選比賽項目</li>
<li>Foreign Policy：關於外交政策的訪問，嘉賓不侷限於美國人，有時會訪問國外的前元首、外交部長、國防部長等等</li>
<li>Lex Fridman Podcast：很多知名人物都有被訪問過，如川普、馬斯克、祖克柏，不過老實說他的訪問實在太長了，動輒就是幾小時，所以我只會挑有興趣的來聽</li>
<li>All-In Podcast：主要是了解這四位知名投資人對美國和世界局勢的看法，比較偏向美國國內的視角，但是他們有些觀點有時會讓人耳目一新</li>
</ul>
<h2 id="YouTube"><a href="#YouTube" class="headerlink" title="YouTube"></a>YouTube</h2><p>其實大部分情況下我都是把 YouTube 當成 Podcast 來聽</p>
<ul>
<li>小 Lin 說：淺顯易懂的經濟商業科普節目，小 Lin 的團隊很強，可以把複雜的事情轉換成簡單的架構</li>
<li>MoneyXYZ：主要是分享他的人生觀，然後會介紹一些好書。他的特點是可以把書中的論點講得很有說服力</li>
<li>RealLifeLore：介紹世界各國地緣政治的節目，很常會從地理出發，給人耳目一新的論點</li>
<li>PolyMatter：介紹各個國家狀況的節目</li>
<li>Norges Bank Investment：挪威主權基金的節目，會訪問一些優秀的企業家</li>
<li>Johnny Harris：一個獨立記者的頻道，主要鎖定國際政治</li>
</ul>
<h2 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h2><p>我大部分都是用 RSS 來訂閱一些部落格的更新以及部分快訊</p>
<ul>
<li>地球圖輯隊：世界各地的有趣事情</li>
<li>報導者：對很多社會議題做深入的報導</li>
<li>Paul Graham：有名的風險投資人，雖然發文頻率很少，但每篇都能引起廣大迴響</li>
<li>阮一峰的网络日志：每週會有一篇週報，整理一些有趣的科技新知</li>
</ul>
<h2 id="電子報"><a href="#電子報" class="headerlink" title="電子報"></a>電子報</h2><p>有些不錯的文章會透過電子報的形式發表出來，我會有限度的訂閱，畢竟也不想要塞爆自己的信箱</p>
<ul>
<li>曼報：同 Podcast，是介紹各產業的文字版本，但是有時候和 Podcast 並不會完全一致</li>
<li>M 觀點：作者是研究科技巨頭的專家，會追蹤科技企業的狀況並且分析，科技領域工作的人值得追蹤</li>
<li>瓦基：專門分享各種書籍的讀後心得，我主要是透過他的介紹來找到不錯值得一讀的書</li>
</ul>
<h2 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a>Telegram</h2><p>主要是追蹤一些有趣的資訊，由於我不使用社群媒體，所以就從 Telegram 這邊來獲取</p>
<ul>
<li>敏迪選讀：淺白口吻介紹一些國際局勢相關的新聞，一些平常我們沒注意到的地方，如孟加拉、非洲、南美也都會提及</li>
<li>IEObserve：有時會分享一些有趣事物，和科技經濟相關</li>
<li>股癌：一樣會分享科技經濟的有趣事物</li>
</ul>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>簡單分享一下自己對資訊來源的看法和原則</p>
<p>• 不需要怕自己資訊來源不夠豐富，重要的是有可以信任的優質來源，並且可以不斷隨時間更新自己的獲取管道，不合時宜的也要敢於移除。<br>• 不需要急於獲得短時間內的消息，我自己對新聞類的資訊不是很在意。因為如果真的有重要的事情發生，它自然會浮現在自己的認知圈中。<br>• 獲取的資訊盡量以長期對我們有幫助為主，例如看見不一樣的人生觀或世界觀，認識新的國家或產業等等。<br>• 我會盡量不要透過社交媒體得到資訊來源，因為很容易被其他事物所分心。<br>• 就算是挑選過的資訊來源也不一定所有的內容都要看，掃過標題，真的有興趣再看即可</p>
<p>這個列表會持續更新，也歡迎大家分享自己的資訊來源。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>《稀缺》：稀缺其實是一種陷阱</title>
    <url>/2018/05/27/%E7%A8%80%E7%BC%BA%EF%BC%9A%E6%88%91%E5%80%91%E6%98%AF%E5%A6%82%E4%BD%95%E9%99%B7%E5%85%A5%E8%B2%A7%E7%AA%AE%E8%88%87%E5%BF%99%E7%A2%8C%E7%9A%84/</url>
    <content><![CDATA[<p>我們很常聽到這些例子：有人會因為缺錢去借高利貸，結果不得翻身。有些人因為太忙於事業，忽略了家人，到了後來才後悔。雖然很常聽到，但是我們都很難想像這些人為什麼會去做這樣的決策，畢竟理智上告訴我們高利貸是不能去碰觸的，因為利息很可怕、家人比起事業更為重要，要多陪家人。「<a href="http://www.books.com.tw/products/CN11194292">稀缺：我們是如何陷入貧窮與忙碌的</a>」這本書為我們做了解答，故事中的主角都是因為稀缺導致了無法做長遠思考。</p>
<p>稀缺，也是代表了資源有限，所以我們大腦會告訴我們要節省，不要浪費，使用的時候就會再三權衡。這個也是我們演化的機制，像是老祖先可能缺乏食物，就必須要對食物存量極度小心，確保自己的生存。這樣最大好處當然就是我們可以確保稀有資源有被最大化使用。我們在日常生活中其實也有相關經驗，當我們在死線最後一刻，效率會非常高，因為這時時間是稀缺資源，會排除掉其他不重要的事情只專注在當前需要被完成的事，這也就是作者所提到的「專注紅利」。</p>
<p>甚至，這樣的專注力也可以讓我們表現更好。我們知道經濟學總是假設人類是理性的，會跟著需求供給曲線走，但是現實生活卻不是如此，人常常會被感覺所誤導。舉個例子，如果有兩家店有一段距離，我們在A看到20塊錢的東西，但是知道B有賣10元的同樣商品，大多數人願意跑去B買。但是如果現在換成比較貴的就不一樣了，A賣3000，B賣2990，大部分的人寧可在A買一買就好。因為人類有這樣不合理性的行為，所以才有行為經濟學這門學科崛起。這些不合理的概念其實都來自我們對金錢比較沒有實感，我們很難估計省下的10元到底有什麼價值，這點就連經濟學家可能也會犯錯。但是貧窮的人在使用金錢上會更有概念，不會被誤導，因為他們很清楚省下的錢要用來做什麼。我們也可以這麼說，貧窮會讓人更加理性，更接近經濟學裡面理性個體的假設。</p>
<p>儘管稀缺擁有專注的好處，但是它帶來的壞處更多。首先，我們可能會因為過度專注在稀缺資源，所以有了「管窺」現象，只看到自己所關注的，忽略掉其他事情。舉個例子，當我們在忙碌時，可能對其他外界的打擾就會很敏感，甚至脾氣會很差。除了管窺，我們用來處理事情的「帶寬」也變少了，因為心裡心心念念想著稀缺的資源，做其他事情時會很難專心，效率變差。而且因為資源稀少，我們也必須花更多精力去「權衡」怎麼使用資源，作者用行李箱的例子來具體描述這個部分。如果我們行李箱很大，我們可以什麼都不用想，把所有可能用到的東西一股腦塞進去，但是如果行李箱很小，那就必須要仔細思考到底什麼東西會用到，什麼應該用不到。這個「權衡」的行為也是消耗精力(或說帶寬)的主要來源。</p>
<p>因為管窺、帶寬減少、權衡，我們會過度放大眼前的問題，無法好好的考慮未來並且做計畫。這時就很可能出現了「借用」的狀況。我們前面提到的會去借高利貸就是因為貧窮者為了解決眼前的問題，跟未來借錢(未來要還高利貸的利息)，而且因為沒辦法客觀評估未來，所以高估自己未來還錢的能力。不斷地跟未來借用，就會陷入稀缺陷阱中，因為現在的稀缺，導致未來的稀缺，讓人無法逃出這個輪迴。這個就像是我們一天的行事曆每項任務緊接下一項任務，假設第一個事情delay了，就會影響到後面的每個行程，陷入自己需要需要不斷趕下一個行程的輪迴中。</p>
<p>很明顯的，要解決稀缺陷阱的問題，就是要保留餘裕。以前面趕行程的例子，如果我們有留一個緩衝時間，那就能利用緩衝的資源把拖延到的時間補上。但是這個緩衝機制絕對不是在問題發生時才做，<strong>我們需要在資源還充足的時候就做好這些規劃</strong>。想像你自己已經都很忙了，怎麼可能還能夠想到要留一個緩衝時間呢？除此之外，我們還有其他手段可以應付稀缺陷阱，像是我們可以用預設取代需要主動操作，一次性的任務不要分多次去做、減少自己需要權衡的機會、多個milestone取代單一deadline。這邊我就不細多提了，但是我認為這邊最主要的概念是當自己已經陷入「稀缺」中，我們要減少需要消耗精力去做的事，因為稀缺必然會導致自己去處理其他事情的精力減少，進而增加出錯的機會。一旦出錯，這個就可能會變成下個你要去救火的點。這個概念其實跟之前讀到 <a href="https://book.douban.com/subject/1019959/">精力管理</a> 還蠻像：我們該管理的不是時間，而是精力，因為能讓你把事情做好做滿的是你的精力。減少自己的精力消耗，就可以讓你更能夠專注於處理重要的事情。</p>
<p>本書是2013所出，離現在已經有點時間。我原本也想說書中的概念大概早就過時了，但是沒想到卻出乎意料，讓我重新理解大家常掛在嘴上的「沒錢、沒時間」。了解了稀缺帶給我們的影響，才能知道要怎麼去面對它，避免落入稀缺陷阱，讓自己總是忙於救火。我想，人生在世大概都會遇到某項資源缺少的問題，所以了解「稀缺」應該是我們不得不去面對的課題。</p>
]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>筆記：自己的外部大腦</title>
    <url>/2024/11/03/%E7%AD%86%E8%A8%98%EF%BC%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%96%E9%83%A8%E5%A4%A7%E8%85%A6/</url>
    <content><![CDATA[<p>對人類來說，紀錄筆記可能真的是不得不做的必要之惡。我們的大腦天生就不善於記憶東西，而為了讓自己更容易找出過去某個時間點的知識，我們需要有個外部系統來輔助，這也就是所謂的筆記。</p>
<p>以下我會針對筆記的型態和架構簡單提出自己思考，另外也分享我對一些常見問題的看法。</p>
<h2 id="筆記型態"><a href="#筆記型態" class="headerlink" title="筆記型態"></a>筆記型態</h2><p>人類最一開始筆記都是以手寫為主，然而隨著科技軟體的發展，越來越多筆記軟體被提出來，讓我們更容易且快速地紀錄想法。然而也因為軟體迭代速度實在太快了，從最早的 Onenote 以及 Evernote，到後來的 Notion，以及現在比較流行的 Hetabase 和 Obsidian，筆記方法和型態都有十足的演化。現在對我們而言，找到筆記軟體並不是問題，而是在這麼多各有特點的軟體之中如何挑出最適合我們的。</p>
<p>對我而言，挑選筆記軟體有幾個要求：</p>
<ol>
<li>該筆記軟體要能夠匯出匯入筆記。相信人類的能力在未來絕對會提出比現在更好的軟體，如果我們沒辦法輕易匯出，那只能被該軟體綁住了。</li>
<li>筆記的格式要是最簡單、最通用的，因為內容永遠比美觀重要。我會選擇支援 Markdown 格式的軟體。雖然它有很多限制，但是卻是大部份筆記軟體都有支援的格式。</li>
<li>該軟體必需是很多人使用的，也就是有廣泛的社群使用者。這樣遇到問題也才比較有可能被修復。</li>
</ol>
<p>我實際上的使用是 Obsidian，然後搭配雲端硬碟同步。不過由於筆記都是 Markdown 格式，所以其實甚至可以直接用 VSCode 來開啟並修改。這樣的彈性讓我不用擔心 Obsidian 這套軟體哪天會有問題，筆記都是掌握在自己的手裡。其實這也是我的慘痛經驗，因為種種原因，過去切換至少 3-4 次筆記軟體，然而每次的轉移都讓我痛不欲生，不少資料也在轉換過程中遺失了。筆記的功能和格式越簡單越不容易出錯，對我們而言花俏不是筆記存在的目的。</p>
<p>不過實際應用上，我其實也不是全部都用 Obsidian，畢竟在快速紀錄和追蹤事項上，並不是那麼的方便。如果突然有靈感或是有待辦事項，我會使用 Google Keep 快速記起來，這在手機上也比較好用。而如果是要追蹤某件事情而需要使用列表時，線上 Excel 相對來說更加易用。甚至有時候很常用的知識或是比較重要的提醒事項，我會紀錄在實體筆記本，更方便翻閱。但是除此之外的所有筆記我會儘可能集中在 Obsidian，方便未來的自己查閱以及整理知識庫。</p>
<h2 id="筆記架構"><a href="#筆記架構" class="headerlink" title="筆記架構"></a>筆記架構</h2><p>筆記架構非常的重要，這個關乎我們如何快速找到想要找的知識。不然有時候明明記得自己有記相關筆記，但卻一直找不到。尋找的方法如果是用筆記軟體的話，大部分都有支援全域搜尋。不過我個人更喜歡的是用階層式資料夾來分類，可以把相關的筆記集中在一起，尋找的時候按照階層點開即可。當然，我也會適度搭配 tag 使用，然而有時候會發現維護所有筆記的 tag 其實也不是容易的事項。例如要讓 tag 有用處的話，當有個新的分類要加入，可能還需要為以前的筆記加上該分類，這個工程有時候也挺浩大的。</p>
<p>另外，要有筆記可以跟我們一起成長的概念。隨著年齡增長，我們的身份會不斷產生變化，從學生、成家立業、到成為父母，所關注的知識有所不同，常翻閱的內容也有極大的變化。學生時代可能是考試會考的重點，出社會工作則是專業知識的增長，成為父母後有可能是養育的方法。或許有時會覺得過去的知識可能沒有再回顧的價值，不過我的想法是這也是我們成長的痕跡，一方面是可以回頭看看自己走過的路，另外一方面很難說哪天會需要再用到。基於如上的理由，在設計筆記架構的時候，我會以一生的角度來歸檔自己當下筆記的定位，當目前角色結束時，筆記系統也有個地方可以封存這些紀錄。</p>
<p>以下是我的筆記架構，特別注意的是我會在每個分類前加上數字，這樣方便按照我喜歡的順序排序。</p>
<p>• 100.工作：紀錄自己當前最常用的事物，例如工作上的專業知識。<br>• 200.個人：包括蒐藏的名言佳句、旅遊心得、創作等等個人的內容。<br>• 300.學習：各個方面的學習筆記，甚至當角色轉換時，也可以把工作的筆記放進這裡。<br>• 500.筆記：存放自己讀書、聽演講的筆記和心得。<br>• 800.規劃：對各方面的自我規劃，理財、職涯、健康等等。<br>• 900.日記：每日的紀錄和反省。</p>
<p>每個分類底下可以再加上你的子分類，舉例來說，學習底下你可以有 <code>310.語言</code>，再下面還能分成 <code>311.英文</code> 或 <code>312.日文</code> 等等。總之找出適合自己的分類方式就好，這是很需要個人化設計的。</p>
<h2 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h2><p>分享一些我對做筆記常見問題的看法：</p>
<ul>
<li><p>什麼樣的內容該紀錄到筆記裡面？</p>
<p>記住筆記的目的，它是我們的第二大腦，所以只需要充當提起我們記憶的角色即可。我們並不需要完完整整把紀錄對象的一字一句都紀錄到筆記內，而是要專注在怎麼樣的紀錄可以幫助回憶起當初的內容，以及自身當時的看法。有些內容，就像是網路可以輕易查到的資源，就沒必要紀錄到筆記之中了，或許紀錄自己要查詢什麼都還比內容本身還重要。</p>
<p>通常我還會思考這個筆記未來會怎麼去用它，要用自己容易使用的方式來紀錄。舉例來說，有時會紀錄跟技術相關的筆記，然而某個概念現在雖然已經理解，但很肯定幾個月之後的自己一定會忘記，這時我可能會從完整的筆記中特別提出幾個幫助回憶的核心概念，加速未來重新理解該概念。</p>
</li>
<li><p>市面上流行的筆記方法一直不斷有變化，例如心智圖筆記法、子彈筆記法、卡片盒筆記之類的，該怎麼挑選適合自己的?</p>
<p>筆記永遠只是輔助功能，只是個工具而已，過度琢磨並不會帶來價值。我認為，人真正的核心價值是自身的思考，而不是紀錄的工具。選定一個適合自己的筆記方法就好，因為永遠會有新的作法出現。我們隨時可以看看其他人應用的工具，找出其優點並適當融入自己的方法，但沒必要他人說這個方法好就一定要把自己過去的筆記全部轉換成新的方法。</p>
</li>
<li><p>過時用不到的筆記該怎麼處理或者封存？</p>
<p>基本上我會鼓勵把過去的紀錄都留下來，特別是當筆記都電子化的時候，其實也沒差那一點儲存空間了。封存的方式怎麼做都可以，只要知道自己要用的時候怎麼找到就好。如果是同一類型的資料可以就直接存在某個分類底下就好，而至於某些會不斷更新的內容，例如職涯的規劃，我會特別用日期區分，而不是把舊的規劃內容直接覆蓋，畢竟這也是自己當初的思考痕跡。</p>
<p>其實我會強調留下思考痕跡的原因除了可以讓自己回顧以外，隨著 AI 的發展未來可能也會有屬於自己的 AI agent 可以透過過去的紀錄來認識自己。特別如果你有在紀錄時留下屬於自己的想法、為何受到觸動，而不是單純複製貼上的時候。我們永遠不會知道這些會不會哪天會派上用場。</p>
</li>
<li><p>別人的筆記是否對自己有幫助？</p>
<p>對我而言，別人的筆記其實參考價值不大。大多數人的筆記都不是為了給別人看而存在，而是為了幫助自己思考。也許我們可以從他人的筆記中理解他思考的脈落，然而卻無法像當事人一樣的思考。思考是很個人化的事情，看同本書、聽同場演講，人人的想法都不一樣，沒有人可以幫我們去經歷和理解。除非那個人作筆記的目的就是為了給其他人看，不然我不認為可以有太大幫助。</p>
</li>
</ul>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>筆記只是輔助，但是卻也不可或缺。找出適合自己的筆記方法是非常值得的投資，會幫助思考並且讓生活更容易被掌握。以我的經驗來說，筆記確實讓我感到生活工作各個方面都更加可控，不過也要記得過猶不及，花太多時間在筆記上反而會阻礙了我們發揮創意並思考。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>系統演化：穩定中間態的關鍵角色</title>
    <url>/2024/12/29/%E7%B3%BB%E7%B5%B1%E6%BC%94%E5%8C%96%EF%BC%9A%E7%A9%A9%E5%AE%9A%E4%B8%AD%E9%96%93%E6%85%8B%E7%9A%84%E9%97%9C%E9%8D%B5%E8%A7%92%E8%89%B2/</url>
    <content><![CDATA[<p>系統演化是一個非常有意思的主題。不論是生物界的物競天擇、企業間的激烈競爭，還是科技的不斷革新，都是可以視為系統在不同層面的競爭與演化。透過對這些現象的觀察與總結，我們或許能找出某些規律，進而更準確地預測未來的發展趨勢。</p>
<h2 id="生物演化的穩定中間態"><a href="#生物演化的穩定中間態" class="headerlink" title="生物演化的穩定中間態"></a>生物演化的穩定中間態</h2><p>生物演化的起點，是在機緣巧合下誕生的 DNA&#x2F;RNA 分子組合。這些分子因其有效攜帶遺傳訊息並能複製的特性，被自然界篩選為穩定的媒介。隨後，蛋白質的誕生和細胞的形成為生物演化提供了更高層次的結構基礎。細胞進一步組成組織和器官，構建出複雜的生物體系。這些穩定的生物特徵能夠在世代間傳遞，並成為下一代演化的基石。</p>
<p>在這裡，我們將這些穩定結構稱為「穩定的中間態」。它們有兩種特性：<strong>一方面，可以它們能長期穩定存在，另一方面，它們又具備重新排列組合的潛力</strong>。例如所有生命體都是由 DNA&#x2F;RNA 所組成，而大多數的生物(病毒除外)則是以細胞為基本單位，這些特徵是生物演化中不可或缺的穩定支柱。因此我們可以知道在自然界演化中，複雜生命結構不會是憑空出現，而是大自然慢慢摸索，發現某種中間態可以穩定存在，然後再基於這個中間態繼續往下探索，組合出更複雜的形式。</p>
<h2 id="工具與思想：另一種系統演化"><a href="#工具與思想：另一種系統演化" class="headerlink" title="工具與思想：另一種系統演化"></a>工具與思想：另一種系統演化</h2><p>人類和生物的差別也是這種演化的延續，原本生物需要靠基因演化來慢慢增加複雜性、彼此競爭。但人類超脫出了基因的競賽，靠著工具的使用，主宰了這個生態系。工具的發明與改良比起單純基因演化能夠有更快的迭代。我們會用火、會用石矛、發明了銅器與鐵器，這些器物的出現速度遠遠快於生物物種間的變化。工具的使用是另一個新的系統競爭賽道，這個賽道上也有很多穩定的中間態，就像是懂得冶鐵後，我們才能製造更堅固的武器、農具。</p>
<p>除了工具的使用，人類的思想更是另外一種系統演化。我們的祖先學會了用文字來紀錄，文字的出現堪比 DNA 這種遺傳物質。人的思想不僅僅是能夠跨空間交流，現在更能夠跨時間交流。前人所學的事物能夠透夠文字留給後人，讓後人基於此往下繼續延伸發展。不論是哲學思想、數學、科學，都透過書籍的形式讓後人可以站在前人的肩膀上。文字是一種很重要的中間態，各個學科的基本知識和定律也是穩定的中間態，後人可以藉由它們來創造出前所未有的理論知識。</p>
<p>由此可知，<strong>任何系統的演化都會產生出一個穩定的中間狀態，後繼者會基於這樣的中間態往下演化，增加其複雜性。更重要的是，這樣演化速度越來越快</strong>。</p>
<h2 id="以科技演化為例：穩定中間態能加速演化"><a href="#以科技演化為例：穩定中間態能加速演化" class="headerlink" title="以科技演化為例：穩定中間態能加速演化"></a>以科技演化為例：穩定中間態能加速演化</h2><p>比起基因的緩慢演化，工具與思想的進步快上千萬倍。看看人類大約在 4000 年前進入到農業社會，但是 400 年左右就進入了工業社會，而最近 40 年又因為電腦的出現而有翻天覆地的變化。<strong>過去需要數代人才會出現的變化，在未來只要一代就會出了好幾輪</strong>。</p>
<p>我們特別能夠從資訊行業中看到這樣的改變：在早期，工程師需要透過電路設計來完成各種功能，每次的功能改動都需要重新設計電路圖。然而隨著 CPU 的誕生，功能的實現被轉移到軟體層面，只要改動軟體就可以讓同樣的硬體來實現多種用途。軟體的改動比起硬體更加快速容易，因此加速了科技的迭代速度。在這裡，CPU 和軟體的概念就是穩定的中間態。</p>
<p>然而隨著軟體的複雜度上升，不可能每位程式設計師都從頭撰寫跑在硬體上的軟體，最好是能夠把共同功能抽出來，程式設計師只需要關注最重要的軟體功能就好，因此有了作業系統的概念出現。有了 Windows、Linux 等等作業系統，開發者關注上層的應用程式，底層和硬體相關的細節都交由作業系統處理就好，大大增加開發的效率。作業系統和應用程式的分割在這邊就是穩定的中間態。</p>
<p>在現在軟體已經遠遠複雜於硬體的情況下，我們可以發現有更多的穩定中間態出現。不管是網路協定中的 TCP&#x2F;IP、容器化的技術等等都是支撐現在軟體的穩定結構。特別是現在 AI 的出現，更多人在探討能不能用 AI 的方式降低我們開發軟體的成本，若是能實現，可能未來軟體的演化又會是更加快速了。</p>
<h2 id="小結：演化邏輯的啟示"><a href="#小結：演化邏輯的啟示" class="headerlink" title="小結：演化邏輯的啟示"></a>小結：演化邏輯的啟示</h2><p>無論是生物演化、人類社會的發展，還是科技的進步，我們都可以發現一個共同的規律：<strong>系統的複雜度越高，越是會出現穩定的中間態，加速整體系統的演化</strong>。這些中間態不僅是現有系統的基石，更是後人未來的創新平台。</p>
<p>若我們所處的行業或工作能夠創造穩定的中間態，並成為他人建構更複雜事物的平台，那麼成功的機率將大大提升。理解並運用這樣的演化邏輯，或許正是掌握未來趨勢的關鍵。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
  <entry>
    <title>《納瓦爾寶典》：如何有智慧地獲得財富與快樂</title>
    <url>/2024/10/20/%E7%B4%8D%E7%93%A6%E7%88%BE%E5%AF%B6%E5%85%B8/</url>
    <content><![CDATA[<h2 id="這本書在說什麼-適合的人"><a href="#這本書在說什麼-適合的人" class="headerlink" title="這本書在說什麼 &amp; 適合的人"></a>這本書在說什麼 &amp; 適合的人</h2><p>「<a href="https://www.books.com.tw/products/0010977461">納瓦爾寶典</a>」是 Eric 整理 Naval Ravikant 過去 X 上的推文、部落格和 podcast 上的想法所集結而成，前一版的名字叫做「快樂實現自主富有」。Naval 是一位知名的矽谷天使投資人，創辦了 AngelList。這本書的內容主要是 Naval 對於人生的各種看法，包括金錢、創業、努力、快樂等等。</p>
<p>想要瞭解矽谷創業家是如何思考、他們的人生價值觀是什麼，非常推薦閱讀這本書。他有很多思考方式很有啟發性，常常會讓我覺得耳目一新，沒想到還可以這樣看待事情。一本書如果可以在某個角度開啟不同視野就非常有價值了，更別說它在人生的各個面向都有獨特的見解。</p>
<h2 id="我畫線的地方"><a href="#我畫線的地方" class="headerlink" title="我畫線的地方"></a>我畫線的地方</h2><p>下面提供一些對我有所感觸的句子：</p>
<ul>
<li><p>人生並不是競爭的過程，而是找出自己的天命。沒有任何人可以在成為自己上面贏過你。</p>
<blockquote>
<p>No one can compete with you on being you.Most of life is a search for who and what needs you the most.</p>
</blockquote>
</li>
<li><p>不要靠時間、勞力賺錢，要靠判斷賺錢。沒有機器或是 AI 可以取代你的判斷。</p>
<blockquote>
<p>I want a robot, capital, or computer to do the work, but I want to be paid for my judgment.</p>
</blockquote>
</li>
<li><p>如果我不再想著要為了未來而忍受當下，那就沒有退休的概念了。如果我所作的事情是自己生命中的天命，那怎麼還有退休這回事呢？</p>
<blockquote>
<p>Retirement is when you stop sacrificing today for an imaginary tomorrow. When today is complete, in and of itself, you’re retired.</p>
</blockquote>
</li>
<li><p>環境會塑造一個人，但是如果我們夠聰明的話，就會去選擇可以讓自己變更好的環境。</p>
<blockquote>
<p>The current environment programs the brain, but the clever brain can choose its upcoming environment.</p>
</blockquote>
</li>
<li><p>如果我們不想要徹徹底底變成某個人，那就沒有必要去忌妒。專注在讓自己身上，他人的經歷成就最多只能提供參考而已。</p>
<blockquote>
<p>Do you want to actually be that person with all of their reactions, their desires, their family, their happiness level, their outlook on life, their self-image? If you’re not willing to do a wholesale, 24&#x2F;7, 100 percent swap with who that person is, then there is no point in being jealous.</p>
</blockquote>
</li>
</ul>
<h2 id="個人想法"><a href="#個人想法" class="headerlink" title="個人想法"></a>個人想法</h2><p>我認為 Naval 都是用整體系統的方式來看待事情。他不會用我們一般很直覺的方式來思考，而是從社會的角度來看每個人所扮演的角色。正因為如此，他才能創造出不同常人的事業。書中很多地方都給我不一樣的觀點，不過整體來說，可以整理成如下四個點。</p>
<h3 id="金錢與財富"><a href="#金錢與財富" class="headerlink" title="金錢與財富"></a>金錢與財富</h3><p>一般我們都認為金錢就是財富，但是 Naval 強調兩者的不同。金錢不過是社會為了感謝你的貢獻所提供給你的借據，你可以用這個來換取其他商品，但是借據本身是無法創造價值的。然而財富不一樣，它在你睡覺的時候仍然可以不斷創造價值，不斷增值，例如房地產、工廠、程式等等投資。對我們而言，正確看待金錢才能善用金錢。<strong>金錢本身只是一種資源，單純放著沒有任何效益，唯有當它開始流動的時候才會產生出價值</strong>。</p>
<p>Naval 提到了三種槓桿：人力槓桿，靠雇用員工來放大產值，但是你需要去負擔管理成本。金錢槓桿，如很多現在的財富管理人或是投資者，他們玩的是一種金錢遊戲，看怎麼用錢滾錢。而最簡單的槓桿則是利用新型態的槓桿，例如程式、自媒體、書籍等等，它們的複製成本極低，一旦成功，就可以快速放大獲得利潤。有趣的是，很多自媒體在介紹本書的時候都會特別強調這句話，也許是因為剛好符合他們目前所作的事情的關係。我個人認為三種槓桿並沒有優劣之分，一個公司最終也是三種槓桿都會用到，就算是自媒體，到一定的規模也還是與需要有員工協助才行。重點是我們可以把這三種槓桿放在心中，在必要的時候選擇需要的來使用。</p>
<h3 id="競爭與努力"><a href="#競爭與努力" class="headerlink" title="競爭與努力"></a>競爭與努力</h3><p>這部分是我最喜歡的地方，因為常常都和他人比較，想要比別人好。但 Naval 提醒我們，沒有必要去嫉妒羨慕他人，畢竟我們也不願意徹底成為某個人。當羨慕某個人在某方面表現優異的時候，可以想想自己願不願意付出他所付出的代價，例如放棄與親朋好友相處的時間或是對員工很刻薄等等。另外一方面來說，<strong>競爭和比較代表自己和別人在做同樣的事情，社會也可以輕易找出其他人來替代自己</strong>。就某種程度來說社會也希望如此，因為越容易被替代，就越不需要付出高昂的代價。然而換個角度來說，若是自己發展出獨特不可取代的價值，剛好社會也需要這個價值，社會就會願意提供非常豐厚的報酬。至於怎麼找出自己不可取代的價值呢？Naval 建議可以找看看什麼東西是別人覺得無聊，但是你很有興趣的。人生其實就是一個不斷尋找什麼最需要自己的過程。</p>
<p>和他人的關係最好是正合關係，也就是利益相同，往同個方向前進。有些遊戲是零和遊戲，例如地位的競爭，某個職位只有一個，大家只能把別人擠下去來得到該位置。在這個情況下，所有參與者的努力是彼此抵消，無法共同創造價值。這給我的啟發是要避開競爭的遊戲，並且參與合作的遊戲。在一個系統中大家的方向都不同樣時，只是互相拉扯，而利益一致的時候，方向就會相同，所有的努力都會推動前進，產生的價值也是巨大的。</p>
<p>談到努力，我們從小到大都被灌輸努力很重要。有志者事竟成、一分耕耘一分收穫。努力絕對很重要，但是更常被忽略的是努力的方向。我們很常只關注付出多少努力，反而忽略了要選擇做什麼以及和誰一起做，很多時候後者影響更為巨大。因此保留時間思考很重要。以工作時間衡量一個人的價值已經是工業時代的事情了，現在的社會中如何判斷的價值更高。Naval 舉個很鮮明的例子，<strong>股東們從來不在乎巴菲特或是馬斯克一週工作多久，股東會說：「做你們自己就好」</strong>，因為這樣他們才能創造出最大的價值。這也讓我反思自己是不是也都只是用付出多少時間努力來當衡量標準，努力只是手段而已，重要的是到底能打造出什麼成果。</p>
<p>從人生的角度來看，一生中 99% 的努力都會被浪費掉，例如求學階段學的知識在考完試之後，大部分都還給老師了。可能最終我們會發現自己生命中的志願只用到 1% 的過去知識而已，就如同我們花很多時間約會找對象，最終也只為了找到適合的丈夫和妻子，中間的努力與最終成果沒有直接關係。我們不可能一開始就知道那 1% 是什麼，但是一旦發現自己找到了，就要勇於放棄其他 99% 並全心投入其中。</p>
<p>在現代社會中，各種技術和機會不斷湧現，從網路、手機到 AI，社會形態的迭代速度越來越快。不需要擔心自己會錯過時代的機會，因為機會只會越來越多。就如同 Naval 所說，如果對某個機會會猶豫，那可能就不是適合自己的，我們完全不用擔心找不到其他機會。找出真正適合自己的方向並專注投入其中，而非人云亦云跟著人群大眾去競爭。尋找與探索遠遠重要於努力競爭。</p>
<h3 id="閱讀和學習"><a href="#閱讀和學習" class="headerlink" title="閱讀和學習"></a>閱讀和學習</h3><p>Naval 提到他很喜歡閱讀，所以對於閱讀也有自己的一套想法。他並沒有被被閱讀本身所拘束，而是享受閱讀本身，所以認為閱讀的書本數量只是個空虛指標。很多時候書並不需要全部讀完，因為作者只是為了描述某個論點而不斷論述，舉了各式各樣的例子來讓理論完整且有說服力。一旦你認為已經了解核心概念了，應該就可以放下手上的書轉而去讀其他的書，沒必要完整看完。我們的社會很鼓勵閱讀，但也因此讓閱讀變得過度形式化，應該要回歸閱讀真正的本質，而不被看完一本書的形式所拘束。</p>
<p>那可以看些什麼書呢？Naval 的論點挺有意思的，他覺得<strong>如果只是去讀大家都看的書，那你的想法只會跟別人一模一樣，沒有太多不同</strong>。對我而言排行榜的書和他人推薦的書其實也是一種過濾機制，可以幫助我們找出值得一讀的書籍。不過他的提醒也讓我意識到要有能創造自己獨立想法的養份，有意識讓自己的書單與他人不同增加差異化。Naval 也有提到可以多讀第一手的書籍，例如談到看不見的手，可以去看看亞當斯密的『國富論』、談到演化論可以去看看達爾文的『物種原始』。我們可以更直接的接觸該作者的思考方式，而不間接透過他人轉述。至於一些關於人生恆久不變的古老問題，例如生命的本質這種，更可以透過時間來選書。經過時間的洗禮，會流傳到現代還有價值的書籍一定程度上能幫助我們解決問題。</p>
<p>雖然本書很多內容是從 Naval 的 X 推文整理而成，但他卻否定了收集格言的價值。格言很酷，但是我們欠缺相關的經驗和背後的思維模型的話，它並無法幫助我們思考解決問題，只會隨時間過去而遺忘。我想這個也就是為何本書會出現的原因，透過完整且有系統的論述，讓我們才能真正了解 Naval 的思考方式，這個比起格言才是更珍貴的寶藏。</p>
<p>對於 Naval 而言，除了閱讀，還有一些技能也是非常重要的。首先是各個學科的基礎知識，因為複雜的理論都是從基礎而來，這個也就是 Charlie Munger 的所謂「思維模型」。再來就是流暢的表達能力，比起高深的文學用詞，更重要的是怎麼用簡單的語言來清楚表達自己。合作是人類社會成立的基石，而要能夠合作就需要彼此能夠有效溝通，甚至是說服他人。最後就是邏輯能力，這點其實我也很有感，有時候我們會遇到非常複雜的問題不知道從何下手，這時候有清晰的邏輯能力就能夠有效分析問題。在我工作的經驗中，能力好的同事都有把複雜問題簡單化的能力，用最基本的邏輯來分析並且一一排除問題。以上這些能力都值得我們重視。</p>
<h3 id="價值觀"><a href="#價值觀" class="headerlink" title="價值觀"></a>價值觀</h3><p>一如其他人的看法，Naval 強調了健康的重要性，不管是事業、金錢、家庭，沒有健康就無法照顧到其他面向。他有提到一個有趣的論點，健康、金錢和時間這三者在人生不同階段都無法同時擁有。年輕的時候，沒錢但有時間和健康、中年時沒時間但有錢和健康、老年的時候則是有錢有閒，但沒健康。無論如何，健康對於我們人生都是要不斷去關注的課題。或許有時候我們會說沒時間關照健康，但是 Naval 說「沒有時間」意味著「這不是我的優先權」。仔細思考一下，確實也是這樣，不去做某件事，就是因為認為其他事情更重要。當別人問健康是不是比其他事情還重要時，我會說是，但是當問有沒有時間去照顧健康時卻說沒有時間，這似乎是一件很衝突的事情。<strong>因此當問到有沒有時間時，應該要換個思考方式，這個是不是我的優先權，是的話就要把其他優先度較低的事情排開</strong>。</p>
<p>Naval 提到了他有三個核心價值觀。第一個是誠實，這裡的誠實最主要是對自己誠實，不需要為了他人眼光去偽裝自己。他提到勇氣是能夠不管他人目光做自己，一旦認為某個聚會只是浪費時間，他甚至會直接中途離席。我常常認為以和為貴，所以會一定程度壓抑自己配合他人，但是這也造成需要花費精力在非目標的事情上，讓自己很不開心。第二個是不要短期思考，不管是金錢、人際關係、健康都需要長期堅持才能有複利效應，不要因為短期的快樂而造成長期的痛苦。最後則是平等待人，與他人相處沒有上下之分，我不高人一等，但也不落於人下，只有維持平等才能確保關係的長久。這非常困難，特別是我們為他人工作的時候，自己因為是下屬，自然而然就會以老闆意見為上，隱藏自己的想法。然而工作也不過是個交易關係，並不應該因此失去自我。Naval 很敢於做自己，和我的個性差異很大，雖然不可能和他一樣，但是是個可以讓我可以學習調整自己的模範。</p>
<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>總結來說，Naval 分享了他在人生方方面面的各種想法，儘管很多部分很有道理，但有些要落實在行動也不容易。舉個例子，他說如果認為自己的時間多高價值，低於該價值的事情就應該要外包，然而他也承認自己很多時候也做不到。我會覺得重點在於看看別人不一樣的價值觀，找出適合的部分並融入自己的人生中。不需要完全學他，但是可以藉此調整看待事情的方式。</p>
<p>看完整本書可以發現 Naval 很強調自我。做自己不要跟別人競爭、跟隨自己的興趣閱讀、誠實對待自己不要偽裝。我想對我而言，<strong>這本書的最大收穫就是尊重自己與他人的不同，就算活得很自我，一樣可以獲得充份的財富和快樂</strong>。</p>
<h2 id="反思與行動"><a href="#反思與行動" class="headerlink" title="反思與行動"></a>反思與行動</h2><p>如同書中最後所提： “Inspiration is perishable - act on it immediately”。下面是看完書後我希望為自己帶來不一樣改變的地方。</p>
<ol>
<li>當發現自己在用努力與別人競爭的時候，思考一下我有沒有在做自己。在做自己上是不需要跟別人競爭的。</li>
<li>當自己無法決定某個選擇時，就先不要接受該選項。因為現代社會不缺機會，好的選擇不會讓自己猶豫。</li>
<li>與他人共贏，人與人是平等關係，並不是上和下。當有共同利益且能為彼此帶來價值時，這樣的合作就更加容易成功。</li>
</ol>
]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>《被討厭的勇氣》：擁有承擔責任的勇氣</title>
    <url>/2018/10/21/%E8%A2%AB%E8%A8%8E%E5%8E%AD%E7%9A%84%E5%8B%87%E6%B0%A3/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>這篇想要介紹的是「<a href="https://www.books.com.tw/products/0010653153">被討厭的勇氣</a>」這本書，書中用哲學家和年輕人用對話方式來闡述阿德勒心理學。由於阿德勒心理學跟較廣為人知的佛洛伊德心理學相比更冷門一點，所以很多想法都給現代人帶來啟發，也因此廣受歡迎。<br>這系列書分為兩集，上集是對阿德勒心理學有個綜觀認識，而下集則是因為讀者有回饋不少意見而針對這些疑問的回答。個人認為下集比較偏向怎麼去實踐方面，其中幾乎有八成是在講教育部分。雖然我覺得一般人如何去實踐部分較少有點可惜，但是對諮商師、教師來說可能極具價值吧！<br>其實書中討論的阿德勒心理學範圍還蠻廣的，原本我想嘗試用整體架構來分析，但是發現可能以目前所掌握的相關知識不足以做這樣的評論，所以我改成會針對幾點比較有收穫的概念來介紹。</p>
<h2 id="目的論"><a href="#目的論" class="headerlink" title="目的論"></a>目的論</h2><p>目的論其實是這本書很重要的精華，反對了宿命論，強調了人類可以自我改變的能力。我們常常太過注重因果關係了，「因為過去發生怎樣怎樣，所以現在的我才變成這樣」或是「都是因為他先怎樣怎樣，我才會這樣」。雖然某種層面上可能是對的，但是更可能的是這些都只是藉口，因為我們並非受制過去原因而行動，而是朝向自己決定好的目的而行動。換句話說，<strong>自己之所以不幸，完全是自己親手所選擇的</strong>。<br>這個概念很重要，如果強調因果論，那代表的是現在的我是無法改變的，因為過去是無法改變的，這是宿命。然而將其想成是我們為了什麼目的才變成現在的自己，那隱含的意思是只要改變了目的，現在的自己也會跟著改變。不是因為過去的經驗形塑了現在的我，而是我去賦予過去經驗什麼意義來解釋自己的人生。由此可知，<strong>重要的不是經歷了什麼，而是如何去運用它</strong>。<br>我們在生活中常常會對現狀不滿，這時候就會去找理由，都是因為環境、過去等等什麼原因導致自己這樣的。但是如果用目的理論來看，我們可能是「不想去改變」而去找理由。雖然現狀令人不滿，但是改變更加痛苦，為了不去改變，我們必須要有可以歸罪的理由。說直白一點，我們是因為缺乏「<strong>改變的勇氣</strong>」，所以寧可選擇了不幸的現狀。<br>在目的論下，一切的理由都是藉口，當前現況完全是自己所選擇的。在下集有提到一個三角柱的概念，我們跟親人、朋友常常會抱怨誰誰誰很可惡，自己很可憐，這也就是三角柱其中兩面，「可惡的他」和「可憐的我」，但是更為重要的是第三面「<strong>今後該怎麼辦</strong>」。不斷地找理由不會改變現況，要專注於自己能改變的事情上面。<br>老實說，目的論真的蠻殘酷的，我們為了讓自己好過一點，感性上會想逃避自己的責任，去抱怨外在的環境，但是就現實與邏輯而言，如果真的要改變現狀，那就得承擔起自己應負的責任，並找出改變的方法。「責任」與「勇氣」說起來容易，但是當想到要用在自己身上時，才真正感受到其重量。</p>
<h2 id="逃離競爭關係"><a href="#逃離競爭關係" class="headerlink" title="逃離競爭關係"></a>逃離競爭關係</h2><p>阿德勒説：「一切的煩惱都是人際關係的煩惱」。雖然有點極端，不過確實人類的煩惱大多數是來自人際關係。其中對我而言，最常見的煩惱是怕自己輸給別人。人類與身俱來就有「追求卓越」的慾望，想奮發向上，但是一旦理想無法達成時，就會有產生自己低劣無能的「自卑感」。<br>在當前社會上，其實都會有「競爭」的關係，在學校時是同學，在公司時是同事，會害怕自己輸給別人，擔心自己可能會輸，因此要不斷贏下去。儘管這種方式可以不斷促進自己進步，但也導致看到別人成功幸福時，會無法發自內心地去祝福，甚至更惡劣的，看到別人不幸會覺得可以證明自己的成功。<br>其實我從求學階段就或多或少發現自己也有這樣的心態，不斷去比較自己與同儕間。然而競爭是一個無限循環，我打敗了一群人，還有更厲害的人在等著，就算我打敗所有人站在巔峰，還是會時時擔心自己會輸，不斷去維持自己的地位，這也意味著永遠得不到幸福。如果我們真的想獲得幸福，必須要脫離競爭模式，放棄比較。<br>目前的我會把人生當做擁有一筆錢可以隨意去買自己想要的東西，如果去比較我買的東西跟別人比起來有沒有比較大、比較好，那並不會得到快樂。不如專心在選擇自己要買哪些東西，我想要買的東西組合肯定跟別人不一樣，也無從比較起，重點是買到的東西能不能帶給我快樂，而不是比別人還要好。</p>
<h2 id="課題的切割"><a href="#課題的切割" class="headerlink" title="課題的切割"></a>課題的切割</h2><p>其實從上面提到的目的論可以看出，阿德勒心理學很重視可控制這件事，因為可控這件事對人類而言十分重要，甚至<a href="https://zhuanlan.zhihu.com/p/21918033">有研究指出會影響到健康</a>。如果用目的論來看，那代表人生是可控制的，我們能去改變。然而事實上人生還是有很多層面是不能控制的，特別是人與人關係，我沒辦法掌握別人怎麼想，如果不能控制，那就會造成自己的不安，對幸福人生來說是種破壞。<br>關於這點，阿德勒提出了「課題切割」，劃清界線，這件事從哪邊開始是自己的課題，哪邊是別人的，最簡單的區分方式是思考「因為這個決定而帶來的結果，最後會由誰來承受？」。切割課題後，不去介入他人課題，也不讓他人介入自己的課題。介入他人的課題會背負他人的人生，而讓他人介入自己的課題則會讓自己左右為難，就像父子騎驢的故事，不管自己怎麼做，都有人會不滿意的。<br>課題切割最高明的點在於確認了什麼是自己可控，什麼不是。我們只要專注在自己能改變的事情上，其他則不用太在意。按照書中的說法，這個就是人際關係的王牌，因為主動權在我手上，不用在意他人想法。<br>也許會有人認為這樣會很招人厭惡，不太能夠做到。然而不這麼做，將會讓自己的人生變得很被動，因為要不斷去迎合別人。這邊也帶出了本書的書名，為了行使自由，讓自己依照自己的生活方針過日子，必須要能接受別人的討厭，因此需要<strong>擁有被討厭的勇氣</strong>。</p>
<h2 id="建立橫向關係"><a href="#建立橫向關係" class="headerlink" title="建立橫向關係"></a>建立橫向關係</h2><p>人際關係有分為橫向和縱向，阿德勒心理學否定一切的「縱向關係」，提倡所有的人際關係都應該是「橫向關係」。縱向關係帶來的是稱讚、責罵，然而橫向關係帶來的是尊敬、感謝。<br>我會特別把這點拿出來提的原因是書中有舉一個很有趣的例子：假設你遵從上司的指示，結果卻因此面臨工作上的挫敗，這應該是誰的責任？如果是縱向關係的人就會認為是上司的責任，因為是上司的指示，然而這個卻是隱含著自己逃避了責任、閃避複雜的人際關係，因為不用思考太過困難的事、不必為失敗負責，所以仰賴他人的指示過日子。對於橫向關係的人來說，應該要拒絕並提出更好的方案，工作成敗是自己要負責的，沒有任何理由推託。其實在工作上還蠻常遇到為了避免麻煩，把問題交給別人決定的情況，讓別人決定別人負責，但是真正負責任的做法也許是自己也提出想法，然後再與別人共同討論並共識出較好的做法。<br>除了對上關係外，對下也是「縱向關係」的一種，像是對孩童的讚賞或責罵。阿德勒很尖銳地指出，大人說對孩子好而去責罵通常不是真正為了小孩好，而是因為小孩犯錯隱含著大人有教育失敗的責任，而為了自己不要被批評，所以想要控制他照著自己的想法走。然而教育是為了讓孩子能夠自立，我們只能從旁提供協助，就算是失敗也是要由自己去負起責任。有點像是學習騎腳踏車，真正騎車的人是小孩自己，跌倒也必須是自己去承擔，但我們可以提供他建議和方法，如果怕小孩受傷而不放手，那他就永遠學不會騎車，只能不斷依賴我們。這跟教育有關的部分目前我大概只有這樣的了解，也許未來有小孩之後可能會有更多的體悟吧！</p>
<h2 id="活在當下"><a href="#活在當下" class="headerlink" title="活在當下"></a>活在當下</h2><p>「活在當下」這句話大部分的人都聽膩了，幾乎都變成是一個政治正確的口號，不過這邊我想提提阿德勒對活在當下的看法。本書用旅遊來比喻人生，出去旅遊絕對不是到達目的才叫旅行，如果是這樣我們就用最快的方式飛到目的地，然後再快速返回不就達成目標了？從自己踏出家門的那一刻起，就已經稱作旅行，旅行的概念是在到達目的前的每個瞬間，認真享受每個瞬間才是旅行的目的。<br>同理人生也一樣，人生就像是登山攻頂的活動，有大半時間都在半路上，如果不能認真對待這個過程，只期待登頂的那個瞬間，那不就代表人生有一大半是沒有價值的？對我而言，常常也會期待未來會變得更好，希望「當下」趕快過去，只要我做完什麼事情人生就會不一樣了，像是學生時期要準備大考、工作時要面對大案子等等。可是再回過頭來想，面對困難挑戰永遠只想說熬過去人生會更好，好像完全沒有真正更好過，因為我只有完成挑戰那一瞬間獲得解脫的快樂，但很快又會有下一個挑戰。與其自己只能在這樣的痛苦中不斷輪迴，不如專心面對當下每個瞬間。<br>關於活在當下，其實也是呼應了前面目的論的看法。「人生是一連串的剎那，過去和未來都不存在，別想要藉著回顧過去、預見未來，給自己一個免除責任的藉口。」由於自己真正擁有的是現在，如果用過去當做藉口，就意味著放棄了現在所擁有的選擇權。當自己想把現在的不如意推給過去，或是期盼未來會更好時，都要注意是不是根本沒有活在現在，應該要認真做當下自己所能做改變的事情。</p>
<h2 id="評價"><a href="#評價" class="headerlink" title="評價"></a>評價</h2><p>以書寫手法來說，兩本書的結尾基本上是年輕人被哲學家說服，受到感動想去嘗試阿德勒心理學，說實在這有點讓人覺得矯情，我覺得其實不用用這種傳教意味濃厚的結尾也不會讓書的價值打折扣，不太清楚為什麼用這種想煽動人心的結尾。<br>另外，很多觀念在對話中並沒辦法越辯越明，個人認為講不夠詳細、邏輯不夠清楚的地方還蠻多的。舉個例子，書中有提到要無條件相信別人，但下集又提到相信不是照單全收，對於對方的思想信念要持懷疑態度，如果我都對人產生懷疑了，還稱得上是信任嗎？這裡作者沒有做更詳細的解釋。當然這可能也是對話方式的書籍所受限之處，畢竟對話類型的書比起理論類型更能讓一般人接受，但對話勢必要省略比較細節的內容了。<br>看完上下兩集後，我認為如果是要把阿德勒心理學當作是自己的人生觀，還有太多需要釐清之處了，而且這也會有洗腦之嫌。然而不可否認，他在百年前提出的這些思想確實有其高明之處，簡而有力地戳破我們不敢面對的一面，這些部分可以再好好理解並且善用在生活中。我們可以利用前人的思想來形塑自己的人生觀，但是不要只是照本宣科去執行，這樣就跟下集一開始的年輕人一樣會陷入苦惱之中了。<br>如果認為完完全全照著某個理論做就可以得到幸福，那其實不也是逃避負責任，缺乏真正去面對自己人生的勇氣呢？</p>
]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>《認知驅動》：輸出重於努力</title>
    <url>/2024/09/17/%E8%AA%8D%E7%9F%A5%E9%A9%85%E5%8B%95%EF%BC%9A%E5%81%9A%E6%88%90%E4%B8%80%E4%BB%B6%E5%B0%8D%E4%BB%96%E4%BA%BA%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="這本書在說什麼-適合的人"><a href="#這本書在說什麼-適合的人" class="headerlink" title="這本書在說什麼 &amp; 適合的人"></a>這本書在說什麼 &amp; 適合的人</h2><p>「<a href="https://www.books.com.tw/products/0010933681">認知驅動</a>」是周嶺「認知覺醒」的續作。如果要用一句話概括這本書，那就是不要過度關注內在的自我成長，要對外為他人產生創造價值，而外在的回饋將會回到自身。本書雖然零零散散引用很多其他人觀念或道理，但我覺得這些都圍繞在如何行動並對外創造價值上。</p>
<p>這本書適合那些重視自我成長，但是看了很多書，學了很多道理，卻對未來仍然迷惘的人。在中國有一句話很常見：「懂了很多大道理，卻過不好這一生」。比起不斷吸收別人灌輸的道理，當一個社會的消費者，更好的做法是用實際行動提供價值，成為這個社會的創造者。閱讀後會開始思考，自己究竟可以怎麼創造社會所需的價值，當成為社會所需要的人時，就會很明確未來要走的方向了。</p>
<h2 id="我畫線的地方"><a href="#我畫線的地方" class="headerlink" title="我畫線的地方"></a>我畫線的地方</h2><p>下面提供一些我畫的重點，幫助你認識這本書。</p>
<ul>
<li><p>當自己覺得很努力卻沒有成果時，看看是不是過度關注輸入，而沒想著對外輸出</p>
<blockquote>
<ul>
<li>內向成長，即圍繞⾃⾝展開的成長活動，⽐如早起、跑步、閱讀等。</li>
<li>外向成長，即圍繞外界展開的成長活動，⽐如寫作、畫畫、寫程式等。<br>…我們過度專注於內向成長⽽忽視了外向成長，即重習慣輕技能，重輸⼊輕輸出。</li>
</ul>
</blockquote>
</li>
<li><p>只有自己夠有價值，才能被他人強烈需要，而被需要就會創造交換的機會</p>
<blockquote>
<p>改變⾃⼰的關鍵是創造價值…因為只有當⾃⾝創造的價值⾜夠⼤時，我們才能被別⼈強烈需要，才能參與到更⼤的社會交換中去，並得到對⽅對等的回饋</p>
</blockquote>
</li>
<li><p>降低期待，不要急於求成，事情自然就會做好。有時太多的壓力都來自於好高騖遠。我們很容易高估短時間內的成果，而低估長時間所帶來的改變。</p>
<blockquote>
<p>我的⼀個減壓秘訣就是盡量不要同時設定很多⽬標，主動降低期待，不急於看到成果。這⼀秘訣⾮常奏效。因為不管是外部的還是內部的，只要⽬標或欲望⼀多，我們必然會焦慮叢⽣、急於求成</p>
</blockquote>
</li>
<li><p>讀書只是幫助我們提高視野，用不同維度看事情的手段，而非真正的目的</p>
<blockquote>
<p>讀書並不是⼈⽣成敗的分⽔嶺，那麽真正的分⽔嶺在哪裡呢？答案也是兩個字：維度。</p>
</blockquote>
</li>
<li><p>能夠創造屬於自己的價值，或許就會解決人生意義這個問題，因為我們被他人所需要</p>
<blockquote>
<p>需要我們的⼈越多，我們的幸福感就越強，就會樂此不疲地踏上⼈⽣旅途，根本沒有時間去想「⼈活著的意義到底是什麽」這樣的問題。只有當⾃⼰毫⽆價值、被⼈忽視的時候，我們才會糾結於此</p>
</blockquote>
</li>
</ul>
<h2 id="個人想法"><a href="#個人想法" class="headerlink" title="個人想法"></a>個人想法</h2><p>這本書給了我不少收穫，下面用三個角度來分享：</p>
<h3 id="輸出重於輸入，利他就是利己"><a href="#輸出重於輸入，利他就是利己" class="headerlink" title="輸出重於輸入，利他就是利己"></a>輸出重於輸入，利他就是利己</h3><p>過去幾年我每年平均也都有閱讀 30 本書左右，卻仍然覺得自己好像都沒有太多成長。常常對一件事情有不少的看法，而且也覺得確實比起他人自己對一些事物的認知角度有些不一樣，然而有時候只會覺得這些好像沒什麼意義。學更多東西還不是只是過普通的生活，與其動輒花幾小時讀完一本書，不如花在讓自己生活過得更舒服似乎更有價值。在書中的開頭作者提到的和讀者問答一下子就命中了要害，「那你有什麼產出嗎？」。的確，我好像都沒有用知識生產出什麼有用的事物。</p>
<p>為什麼自己會停在只接受輸入而已呢？因為接受輸入最容易實現，我只要被動去學習作者的思維就好，而不需要費盡心思思考怎麼創作。就像是用戰術的勤奮來彌補戰略的懶惰。每看完一本書都會感到自我感覺良好，好像等級上升，變成全新的自我。若是仔細想想，看完書的前後我真的有什麼改變嗎？好像也不太多，只能安慰自己這些改變都是潛移默化。</p>
<p>那為什麼需要輸出呢？書中提到幾個點：首先輸出就是在確保自己真的了解，我們都經歷過自以為理解，卻發現要自己複述卻講不出來的情況，這就代表並非真的學會。再來，輸出的好壞全部由外界評判，就像是練琴一樣，如果自己只是悶著頭不斷練，卻沒有外界給予回饋，那可能最終只能感動自己而已。最後就是要產出價值，這個社會其實也是遵循等價交換的，當一個人所提供的價值足夠大的時候，自然就會有相等價值的機會產生。作者對利他就是利己的解釋也是來自於此。我們被他人所需要，對方也會提供我們同等的回饋。</p>
<p>作者提到這個社會分為三種層次：消費層、生產層、創造層。消費者不需要有任何目標，他們可以無意識的消費著其他層所創造的事物，例如文字、影片或是各種有形的商品等等。生產層是由外在所逼著生產事物，就像是工作一樣，我們不是創造而是生產他人所要求的產品。至於創造層，雖然也是在生產，但是這些東西會貼上他們專屬的標記，這是屬於他們的東西。一旦社會可以給予正向回饋，巨大的成就感和意義就會隨之而來。透過主動創造，就能跳脫漫無目的消費，更加清楚自己所想要的，並且也提供給這個社會額外的價值。</p>
<h3 id="人生成敗的分水嶺不是讀書，而是維度"><a href="#人生成敗的分水嶺不是讀書，而是維度" class="headerlink" title="人生成敗的分水嶺不是讀書，而是維度"></a>人生成敗的分水嶺不是讀書，而是維度</h3><p>當初我會想閱讀這本書，正是來自這句話。老實說，這句話乍看之下有點世俗：為什麼要定義人生成敗呢？怎麼比較不同人生的好壞呢？難道我不能過著普通人的生活，而要去追求他人眼裡的成功嗎？不過或許我們可以先不要管成敗，而專注在所謂的人生歷練。有些有智慧的人可能一輩子沒讀多少書，但是可以說出直指人心的話語，正是因為他們已經經歷過這些，看過太多相同的劇情。實際親身經歷過，眼耳鼻等感官多個維度都接觸到，比起單純看他人文字敘述更加刻骨銘心，而這其中的差距就是知識與智慧差別。</p>
<p>這樣讀書就沒有意義了嗎？假設世界上有個機器，可以快速讓我們經歷無數次人生，體驗各式各樣的可能性，這個機器的效用可能比讀書更加有效益。然而這個機器是不存在的。也許我們有那個機遇可以遇到很多優秀的人事物幫助我們拓展眼界，但是更多時候我們只是個普通平凡人，日復一日過規律的生活。這時最低成本的方式是透過書籍看到其他人不一樣的人生，看見優秀的人不同的思考方式，進而認知到生命也有不一樣的可能性。擁有書本的知識後，遇到新的人生各種挑戰，就更有機會找出適合的應對方法，產生出更高的智慧。</p>
<p>不過，對我而言這句話的含義反而是在於要認清楚自己讀書的目的。不應該過度追求閱讀本身，不管是閱讀的時間或是數量。最重要的是有沒有透過閱讀這個行為改變自己的思考方式，是不是能夠從更高的維度來思考生命中遇到的各種問題，而不是拘泥在現有的眼界中。閱讀的目的在於用低成本的方式看到生命不一樣的可能性，不要把手段和目的搞錯。</p>
<h3 id="降低期待，不要急於求成"><a href="#降低期待，不要急於求成" class="headerlink" title="降低期待，不要急於求成"></a>降低期待，不要急於求成</h3><p>書中不斷反覆強調的另一個重點在於不要急於求成。我們常常都會同時設定多個目標，希望趕快達成，因此市面上也就因應產生出大量教導如何速成的書籍。這個也是現在步調快速的社會所造成的結果，大家會焦慮自己趕不上他人，任何事情都期望有捷徑可走，反而造成心裡大量的壓力。這時可以從降低期望下手：降低數量，一次只針對一個目標；降低難度，不要期待短時間可以搞定問題。</p>
<p>這也是我的親身經歷，我常常會設定多個目標，然後要求自己在每月每週每天要達成某個程度，但發現最終都做不到，又或是無法長期堅持。而在工作上面，也總是在多個任務之間快速切換，想說可以更加有效率，卻發現完成時間沒有比較快，反而品質降低，而且身心疲憊。慢即是快並不是老生常談，而是確實有用的道理。人們總是高估自己短時間可以達成的成就，低估長時間能夠做到的結果。</p>
<p>作者提到了一個解決焦慮、急於求成的方法，也就是「七年就是一輩子」這個概念。人們的一輩子常常就只專精於一項技能，而如果我們轉換思考，每七年只專注在一個技能上，那麼我們可以活上好幾輩子。這個思考方式可以避免我們對多個目標的同時追求，造成極度焦慮，也增加自己的耐心，不再用短時間刻度來看待自己的人生。若是拉長時間來看，會意外地發現自己已經成就不少事情。</p>
<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>從整體來說，我並不認為這本書的架構十分嚴謹，更像是作者把自己所瞭解的各種理論方法拼湊在一起呈現給讀者。因此有些道理我並不認為真的那麼有說服力。但是，就如同作者在書中所說的，一本書如果有一段話影響了自己，那麼閱讀這本書就十分值得了。從這本書中，我體悟到了行動的重要性。比起學了很多知識，怎麼把這些知識轉換成對他人有意義的事物更為重要，這也是我想要重新經營部落格的原因。在人生當下的階段，專心並有耐心把一件對外部有價值的事情做好，不要急於求成，等幾年過後再回頭來印證這個方法是否正確吧！</p>
<h2 id="反思與行動"><a href="#反思與行動" class="headerlink" title="反思與行動"></a>反思與行動</h2><p>若是閱讀能為自己帶來任何行動上的改變，那這本書就物超所值了。以下列出幾項我的行動清單：</p>
<ol>
<li>反思自己可以為他人創造的獨特價值為何。當學習新事物的時候，可以想想有沒有什麼方式可以輸出價值。</li>
<li>用較大的時間刻度看看自己過去的成就，可以用時間軸的方式來呈現。然後想想接下來的人生階段要以什麼事情為最大的優先目標。</li>
</ol>
]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>《請停止無效努力》：尋找適合自己的方向</title>
    <url>/2018/04/15/%E8%AB%8B%E5%81%9C%E6%AD%A2%E7%84%A1%E6%95%88%E5%8A%AA%E5%8A%9B/</url>
    <content><![CDATA[<p>第一次知道「<a href="https://www.books.com.tw/products/CN11406545">請停止無效努力</a>」這本書是跟朋友在逛書展時發現的，原本對書名並沒有什麼興趣，但是忽然瞄到作者是孫圈圈，馬上就有興致了。之前都會在她的公眾號發現不錯的文章，內容有條理，而且不會流於口號，都有如何實行的方法論。而這本書看完後的確是不負所望，內容很紮實，有把她做諮詢累積的經驗分享出來，我覺得非常適合初入職場的人閱讀。</p>
<p>本書大致上分為好幾個部分：挖掘天賦、如何學習、思維、溝通、職涯規劃、情緒等等，每個都有寫出作者的見解和方法論，這本書編排很好的地方是在每篇文章最後面都會有總結，以及可以怎麼做讀後練習，就像書中一開始所說，現在「道」和「器」的書太多了，但很多都沒有實作方法，所以她想要寫一篇關於「術」的文章。</p>
<p>簡單分享一下我在書中特別有感觸的觀念。挖掘天賦這塊作者列舉了各種職業定位並做簡單分析，並且合理推出天賦型的定位比較適合我們，然後再給出了挖掘自己天賦的方法。雖然我不認同作者說的每個人天生上就有各自的天賦，因為我覺得只要是硬體沒差很多(人的身體)，基本上差異都是後天學習造成的，但是作者在這邊有擴大天賦的定義，她認為意願也是種天賦，有些人可能因為家庭等後天學習因素而喜歡做什麼事、不喜歡做什麼事，這也算天賦的優勢。這個觀念我以前並沒有想過，不過想想也是很合理，理論上人透過一定正確的訓練應該能力不會差太多，但是如果有些人本身就不喜歡該領域，就更不可能去做正確的訓練了，因此能力上就會出現落差。</p>
<p>學習的部分並沒有提到什麼新東西，大概還是離不開刻意練習的概念，然而在思維和溝通的部分就有很多可以參考的點了。畢竟作者是做諮商的，所以這兩個領域都算是她的專業吧！思維的話可以分為結構化思維和創造性的思維，而這其中是有些方法論可以運用來思考的。像是結構化思維可以用常用的架構來輔助思考，或是透過歸納法從資訊找出有意義的內容等等。除了思維，定義問題也是其中一個很重要的因素，我們要清楚自己要解決什麼問題，而且不是所有問題都值得被解決。我以前常常都會想說每個遇到的事情都要全力去做，不這樣做的話就好像是沒有負責任，但是作者反駁這樣的想法，應該是要看CP值，高的才需要全力找最佳解，一般的就只要能處理掉即可。溝通部分則是描述有條理發表言論、與人找話題聊天的方法，這邊是我的弱項，應該可以再好好地吸收消化一下。</p>
<p>職涯規劃的部分有提到可以使用個人商業模式畫布，這個概念我在「<a href="https://read.douban.com/ebook/7611058/">程序員跳槽全攻略</a>」看過，不過當初自己做職涯規劃只有幾年後要達到什麼目標，學到什麼能力之類，結果列完後還是沒有去做到，應該說連去回顧都沒有了。作者強調說我們做職涯規劃不該強調目標，而是要強調過程、實現的路徑是什麼，這樣的概念相對來說也比較踏實，不會只是空中畫大餅而已。書中最後情緒的部分有個概念讓我非常受用：<strong>面對所謂的性格缺陷，最佳策略不是對抗，而是找應對方式</strong>。我很清楚自己的弱點，包括不擅長社交、不喜歡在人多的地方、不喜歡引人注目，但是有時還是會想說要克服自己的缺陷，努力去改變。然而作者的說法是性格是我們的天性，需要花很多資源去改變，因此與其去改變，不如想想如何提高其他的能力來彌補這個缺陷。例如社交要做得好有很多因素，性格只是其中一項，我們可以強化其他因素來達到同樣結果。這個概念在前面的天賦也有提過，不要想著要彌補自己的弱點，而是將彌補劣勢的時間拿來強化自己的天賦，發揮他並且用其他能力彌補弱勢的部分。這個概念就如同巴菲特的<a href="https://jamesclear.com/buffett-focus">雙目標清單系統(Two-List System)</a>一樣，集中資源在自己的目標、強項，不會變成樣樣通樣樣鬆。</p>
<p>本書的內容從我的角度來看，雖然還是有些自己並不是很認同或是覺得有邏輯不清的地方，但是這本書提供給我們一個可以去嘗試的方法，利用這個方法來嘗試改變自己，而我們可以基於這些方法開始思考要怎麼建立屬於自己的方法論，而不會遇到職業、人生的問題時總是滿頭霧水，不斷窮緊張。透過不斷參考、試錯，就可以找到更適合的方法來面對自己的人生。</p>
]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>《軟技能》：軟體界的「原則」</title>
    <url>/2018/07/04/%E8%BB%9F%E6%8A%80%E8%83%BD%EF%BC%9A%E4%BB%A3%E7%A2%BC%E4%B9%8B%E5%A4%96%E7%9A%84%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>今天想要來介紹一本對軟體工程師來說很棒的書，叫做<a href="https://www.tenlong.com.tw/products/9787115429476">軟技能：代碼之外的生存指南 (Soft Skills : The software developer’s life manual)</a>。最一開始會關注到這本書是因為有人介紹說這本書堪稱是軟體界的「<a href="http://www.books.com.tw/products/0010782941">原則</a>」。由於對「原則」有還不錯的評價，所以就有了閱讀的興趣。這本書號稱是給軟體工程師看的書，但是裡面卻沒有任何一行程式碼，作者希望告訴讀者的是要成好的軟體工程師，不能只專注在專業上，要把重點放在「整個人」上。書中分享了如何找工作、自我營銷、自我學習等等，甚至還有理財、健身和愛情。同樣身為軟體工程師，我認為可以從前人身上觀察和學習他的經驗應該是蠻有幫助的，因此下面會分享幾個從書中學到比較重要的概念。</p>
<p>第一個是就算是受聘於公司，也應該要當作自己是在經營生意。只有把「我」當成是一家公司看待，才能做出好的商業決策。在一般公司朝九晚六(如果沒加班的話)的生活，很容易把個人的思維限制住，認為就是把固定事情做好然後領固定的薪水。然而，如果從經濟學的角度來看，其實我們都是在販賣服務並且獲取報酬，只是販賣的對象是固定某個客戶而已。當可以用比較宏觀的角度看待工作的時候，就會發現可以選擇的策略比想像中多很多，例如開始評估自己所提供的服務和價錢跟當前市場狀況是否有吻合，不吻合的話就會進一步精進服務的內容(提升能力)，或是開拓其他可能的客戶(找其他公司)。這種心態上的轉變會讓我們不會只是被動接受現況，而會有積極的思維去影響現實，獲得更好的結果。</p>
<p>再來關於自我行銷的方面作者也提到很多，自我行銷其實跟前面相呼應，如果要把工作當作在經營生意，怎麼讓潛在客戶知道自己就很重要。找工作最容易的方法是讓工作來找你，當別人有求於你時，就更容易得到比較好的條件。對軟體工程師來說，最好的行銷方式就是寫blog，有許多有價值的文章，自然知名度就會打開。書中強調了好幾次經營blog的重要性，然後還提到最重要的就是毅力，只要持之以恆地撰寫文章，就已經勝過大多數的同行了。雖然我本身已經有意識地在經營blog了，但是常常都只是想說留個紀錄供自己未來參考。然而作者反對這種做法，他認為如果要能吸引別人最重要的是出發點是對他人有益，如果能夠對他人產生價值，就會受到關注，因此文章不是自己寫開心就好。這對我過去寫文章的方式是一種震撼，現在開始會思考我的記錄事情的角度是否可以解決讀者遇到的問題，是否容易閱讀及理解。</p>
<p>在變動很快的科技業中，如何自我學習是非常重要的，特別是軟體業，沒多久就有新的framework或程式語言出現，這些技術大概很難透過學校老師教導，只能靠著自己尋找資源去學習。書中作者介紹了十步學習法，不過我不打算在這裡細部講解這個方法，取而代之，我想分享作者提到的四個自學方式循環：學習、實踐、掌握、教授。我們不應該期待自己把某個領域學完後再開始應用，要盡量在最短時間內找到必須要學會的內容，然後就去實踐，從實踐過程中一定會遇到問題，這時再回去翻資料掌握這些問題，當有一定程度的理解後，嘗試跟他人分享，確認是否真的理解。透過這樣的循環，可以幫助自己更快掌握該領域知識。其實這套方法跟之前我看過的有效自學方式很類似，例如<a href="https://rocket.cafe/talks/85231">最小必要知識架構術</a>、<a href="https://www.drcleaner.com/zh-hans/%E6%9C%80%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%9A%E8%B4%B9%E6%9B%BC%E6%B3%95/">費曼法</a>，很明顯這些方法已經成為主流了。我想，不應該被傳統的學習概念(從基礎知識一步步慢慢學習)所限制，而是從應用面來學習，也就是知道自己要做到什麼，反推回去需要學習哪些知識，不但有效率，而且也更符合這個社會緊湊的腳步。</p>
<p>關於時間管理的部分，作者推薦用使用番茄鐘(通常代表的是工作25min後休息5min)，如果不知道番茄鐘可以參考<a href="https://zh.wikipedia.org/zh-tw/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95">wiki的介紹</a>。這一年下來，其實我都是用番茄鐘來管理我的時間，目前也覺得透過番茄鐘，確實可以幫助專注力，然而我卻從書中發現自己並沒有善用番茄鐘最大的威力。番茄鐘並不只是用來幫助自己提升效率的工具，更重要的是可以用來幫助時間規劃。在時間管理上，最常遇到的問題就是不知道每項工作到底要花多少時間做完，而在固定時間內，到底可以做完多少事情。這兩個問題番茄鐘都幫忙解決了，透過把一項大任務切割成番茄鐘的長度，代表的是強迫自己分割大任務變成可估算完成時間的小任務，而每個人每天可以完成多少的番茄鐘是有數量限制的，也代表我們會很清楚每天可以做多少事情，這樣規劃方式可以加強預測工作進度的準確度。另外番茄鐘帶來的另一個好處是可以更安心地進行休閒活動，大家應該會有經驗如果去玩樂會有種罪惡感想逼自己去工作，如果清楚每日能做到的番茄鐘數量，那休息享樂時就不會感到內疚，因為每天該完成的工作都已經達成了！</p>
<p>最後一點是關於自我弱點的方面，從小到大我們所受的教育都是要把缺點彌補起來，然而這在專業上其實是說不通的，大家應該常聽過樣樣通，樣樣鬆。與其告訴他人自己會很多東西，不如專精在比較小的領域(或是大領域中的某種應用)，也許在市場上並沒有那麼多的需求，但是錄取機率則會大幅增加。不過也是有要去彌補弱點的情況，那就是該弱點會大幅影響效率時。當不知道某項技術其實可以很容易達成某件事前，可能都會很排斥去學習，但其實只要花幾個小時就能獲得很大的效益，也就是常聽到的CP值很高。然而要怎麼找到這些CP值高的技術呢？我們可以記錄每個自己沒聽過技術的遇到頻率，當遇到頻率高於一定值時，那就代表有學習的價值。舉個例子，其實我有時候看經濟新聞都會聽到A輪、B輪等等名詞，但是都一直沒動力去搞懂，結果對新聞內容都一知半解。在看本書的理財部份時，作者有做一個簡單的解釋，結果花不到半小時，就對這些常見名詞有初步認識了，也變相了加深我對經濟新聞理解，像是這種知識就很值得花時間投資。</p>
<p>當然這本書還有很多很有價值的內容，不過受限於篇幅，無法每個都說。如果對上面的分享心有戚戚焉的話，我想這本書應該蠻適合你。進入科技業也不過快三年而已，未來應該還有很長的職業生涯，如何好好經營是很大的課題。目前還是以多多參考前輩們的經驗以及不斷自我反省為主，找出真正適合自己的道路。</p>
]]></content>
      <categories>
        <category>讀書心得</category>
      </categories>
      <tags>
        <tag>自我成長</tag>
      </tags>
  </entry>
  <entry>
    <title>閱讀是一種朋友間的對話</title>
    <url>/2024/09/29/%E9%96%B1%E8%AE%80%E6%98%AF%E4%B8%80%E7%A8%AE%E6%9C%8B%E5%8F%8B%E9%96%93%E7%9A%84%E5%B0%8D%E8%A9%B1/</url>
    <content><![CDATA[<p>我喜歡閱讀，而且很多人也很熱愛閱讀。儘管如此享受讀書，但有時候不免會被問到你看了那麼多書，到底學到了什麼？又或是聊天間提到某本書，你很興奮自己有看過，然而卻支支吾吾講不出其中的重點。當時間一久，書中內容逐漸忘去，自己也會感覺好像白讀那麼多書。雖然還是很愛閱讀，但是這些種種有時候還是很困擾。<br>以上這些都是我之前遇到的問題。為此，我慢慢摸索出一套方法讓閱讀的過程更加充實。在這個過程中，也逐漸理解讀書對自身的意義為何，可以用什麼心態來看待閱讀。下面會分成方法和心態來分別分享我的作法。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>我閱讀每本書時都會創一個筆記檔案，其中記錄下面幾項內容，方便自己未來追蹤閱讀時的收穫和想法。不過要特別注意的是這樣的方式並不適合任何書籍，至少像是小說、詩集等文學類型就不能用這種方式。</p>
<h3 id="閱讀前先問自己"><a href="#閱讀前先問自己" class="headerlink" title="閱讀前先問自己"></a>閱讀前先問自己</h3><p>這邊我會先問兩個問題：</p>
<ol>
<li>為什麼我想要看這本書？我想從中得到什麼？</li>
<li>這本書的架構是什麼？作者用什麼方法來論述？</li>
</ol>
<p>第一個問題主要是先知道自己的目的是什麼、想解決什麼問題。這樣在閱讀的過程中可以不斷反問自己作者是怎麼回答的。另外也會比較清楚這本書對自己的意義為何。第二個問題則是從宏觀的角度來觀察作者怎麼論述一個主題，我可以直接針對感興趣的部分先下手。其實這兩個問題都是用來釐清自己是否要閱讀這本書。深入了解一本書是需要幾個小時的時間，在投入之前先初步認識一下「新朋友」也是必要的。除此之外，也可以先去查查別人對這本書的評價和讀書心得，避免到後來才發現這本書和自己的預期差別太大。</p>
<h3 id="劃線上加上原因"><a href="#劃線上加上原因" class="headerlink" title="劃線上加上原因"></a>劃線上加上原因</h3><p>我想大部分的人都會在讀書的過程中劃線，記錄自己感動的句子。然而有時候會發現這些句子只是當下感動自己而已，事後回過頭來卻不知道為何要記錄下來。這個的原因在於我們會被感動是因為要搭配當下的那個情境，也就是那句話的上下文。失去了當時的脈絡，再好的句子也會讓人不知其所以然。</p>
<p><strong>劃線就如同是單向的輸入而已，要有效率的學習，需要有雙向的溝通，也就是輸出</strong>。我通常會在每句有感觸的劃線上，加上一些筆記，記錄當下的想法。這些包括但不僅限於：為何這句話有感觸？我聯想到了什麼？有什麼樣新的想法？這樣的好處是能夠強迫去思考這句話觸動自己的真正原因，這個原因才是我們真正想要記錄下來的本質。</p>
<h3 id="歸納數個重點"><a href="#歸納數個重點" class="headerlink" title="歸納數個重點"></a>歸納數個重點</h3><p>當閱讀完一本書，會有幾十、甚至上百道劃線。這時從這些劃線和我們記錄的想法精煉中出幾個重點。<strong>記得一定要用自己的話來重新寫出來，代表是經過自己思考過後的結論</strong>。這些重點就是簡化版的你從書中獲得的收穫。當別人問你對這本書的看法時，你可以直接回答這些歸納重點，藉此介紹這本書。重點越少越好，如果太多，反而會失去焦點。我個人建議是盡量在五個內，最多不要超過十個。</p>
<p>做這些歸納還有一個好處，未來你要回過頭複習這本書在講什麼時，可以直接先看這些歸納就好。因為有經過自己的思考，只要看到很快就可以回憶起這本書的內容。如果你想要更多細節，這時還可以回去看劃線的句子以及記錄的筆記。透過這樣的方式，基本上就不會有忘記這本書內容的情況發生了。</p>
<h3 id="如何採取行動"><a href="#如何採取行動" class="headerlink" title="如何採取行動"></a>如何採取行動</h3><p>對我而言，讀書的目的是要改變自己。可能是改變生活方式，可能是改變心態，也可能是發掘自己對某個領域的興趣。這時我會記錄下未來要採取什麼行動。一本書論述再好、內容再精采，如果只是看過就好，那其實幫助並不是很大。反過來說，閱讀一本書後，只要有改變自己，不論多麼微小，這本書就功德圓滿了。<strong>透過寫下要做的改變，正是強迫讓書真正進入生活影響自己的一種方法</strong>。</p>
<h3 id="心得發表"><a href="#心得發表" class="headerlink" title="心得發表"></a>心得發表</h3><p>最好的學習方式是能夠用自己的話把這本書複述出來。寫成心得需要對書有足夠的了解以及思考，最終轉換成有架構的文章。當然大部分的人沒有這麼多時間做這件事情。我自己是只有在看到很喜歡的書時才會透過心得分享來整理想法，這樣才更方便推坑給其他朋友。</p>
<h2 id="心態"><a href="#心態" class="headerlink" title="心態"></a>心態</h2><p>除了方法以外，我認為重新認知閱讀這件事非常重要。用不恰當的心態來閱讀，不但無法享受讀書本身，更無法吸收其中內容，只是帶來焦慮感而已。下面分享四點我對閱讀的想法。</p>
<h3 id="閱讀是作者與自己對話的過程"><a href="#閱讀是作者與自己對話的過程" class="headerlink" title="閱讀是作者與自己對話的過程"></a>閱讀是作者與自己對話的過程</h3><p>以前我會想，有很多人把各種書的重點整理好了，像是幾分鐘了解一本書這類的文章、影音，是不是我就可以不用去看了，直接吸收他人的重點整理就好。甚至現在 AI 已經很方便，讓 AI 幫忙抓重點就好，根本沒必要自己去閱讀。畢竟很多書就只是為了講述一兩個道理而不斷論證而已。後來我才察覺，如果只是一兩句話就可以改變一個人的認知，那世界上大家都只要去讀讀格言佳句就好，書籍根本沒存在必要。</p>
<p>閱讀是一種對話的過程，作者提出了想法，刺激我們的思考，激發出了創意。在這個過程中我們和作者的認知世界開始交疊產生影響，有了新的思維方式。<strong>我們真正想要收穫的從來不是作者的思想理論，而是藉由這些所帶來的刺激</strong>。在閱讀某些書籍時，可能有人覺得內容了無新意，但是有些人卻很喜愛，因為作者的敘述方法能夠不斷激發他產生出新的想法。這些想法而非內容，才是閱讀的價值所在。</p>
<h3 id="閱讀沒有-KPI"><a href="#閱讀沒有-KPI" class="headerlink" title="閱讀沒有 KPI"></a>閱讀沒有 KPI</h3><p>我個人的閱讀經驗是從一開始很愛讀書，到後來追求讀書速度和數量，最終才回歸閱讀的本質。閱讀的目的在於改變自己的思維方式，但很多人都會搞錯方向以為讀越多書越好。最終出現了很多怎麼一年讀 N 本書的理論，或是怎麼樣練成速讀的方法。我明白看到明確數字的提高是對人類成就感的一種刺激，會讓人更願意努力去達成。然而，我還是覺得這樣雖然能達成目標但是卻會養成畸形的心態。</p>
<p>由於現在清楚知道讀書是為了有新的思考，我更願意放慢速度，有意識拉長讀一本書的時間。我們都知道跟優秀的人相處會改變自己，相處越久影響越大，那為什麼不願意多花點時間跟優秀的書慢慢相處呢？每天都接觸一點，拉長時間，這樣更可以潛移默化影響思考習慣。人總是有慣性的，<strong>看完一本書後的刺激往往只能維持短短數天，但是透過長時間每天相處，這樣的影響力才能滲入生活之中</strong>。</p>
<h3 id="閱讀不該形式化"><a href="#閱讀不該形式化" class="headerlink" title="閱讀不該形式化"></a>閱讀不該形式化</h3><p>從過去的學校教育中，其實制約了我們書要從頭開始看到尾的習慣。不但要按照順序看，還需要注意課本中的每個細節，因為考試很有可能就是從某個沒注意到的地方出題的。然而這樣的習慣並不適用真的想要從書中得到收穫。我們會想看一本書，大部分情況都是懷抱著某個課題希望獲得解答，想看看作者對此的看法。既然是想得到答案，那就沒必要用傳統方式閱讀，可以隨意跳著看，尋找解答。有些對自己幫助不大的內容基本上都可以跳過或快速帶過。不需要有強迫症一定要每個地方都看過才是真正讀完。</p>
<p>除此之外，看書這個行為，只要有從書中一句話獲得啟發，就值回票價了。過去我會希望把這本書提到的所有道理方法都記錄下來，並且細細理解。特別是有些作者會把方法或想法列點出來，這讓人覺得是重點，一定要記起來。但是後來發現這樣並沒有意義，有些自己沒有觸動的知識就算紀錄起來也沒有幫助，很快就忘記了。不如全心專注在真正為自己帶來影響地方，好好品味理解。<strong>一本好書在不同的人生階段看本來就會有不同的理解，劃線的地方也會不一樣</strong>。接受這個事實，知道未來可能會在合適的時間重新閱讀，因此現在只要享受這本書就好。就算是重讀，透過比較過去的筆記和擁有更多人生經驗現在自己的想法，也是一種有趣的體悟。</p>
<h3 id="閱讀就像與朋友相處"><a href="#閱讀就像與朋友相處" class="headerlink" title="閱讀就像與朋友相處"></a>閱讀就像與朋友相處</h3><p>閱讀本質上就是用比較低的成本認識跟你有不一樣視野的朋友。我們都有過這樣的體會，跟朋友聊天，透過分享他的經歷，看見了不同的選擇、不同的人生，拓展了認知圈。然而這樣的朋友，特別是和自己性質相異的，並不是那麼多，大部分認識的朋友還是在同溫層中的居多。不過，閱讀卻可以帶來相似的效果。閱讀的過程就是在和作者交流，他分享自己的人生視角，為讀者帶來新的啟發。這也是突破同溫層，看見不一樣世界的好方法。</p>
<p>把書當成朋友還有一個好處，我們不再著急要把書看完了。試想，有哪個人會為了交更多朋友，只是跟眼前的人快速聊聊就結束嗎？<strong>我們會更專注跟這位「朋友」互動交流，從他身上獲得知識，並且反饋自己的想法，建立起一種「對話」</strong>。透過思考他的生命和我的有什麼不同，啟發了新的想法，開啟自己人生不一樣的可能性。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>以上分享是從我過去看書的經歷中摸索出的作法，在享受閱讀的同時也能從中獲得扎實的收穫。當然，每個人都有自己一套和書相處的方式，適合自己最重要。如果我的分享能有稍稍為你帶來啟發，那就再好不過了。</p>
]]></content>
      <categories>
        <category>雜七雜八</category>
      </categories>
  </entry>
</search>
